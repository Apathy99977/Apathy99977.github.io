<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux快速入门</title>
    <url>/2022/05/25/Linux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>前言：</p>
<p>本教程是根据B站Up主狂神说记得笔记，有需要查看视频的小伙伴可以去看看狂神的视频，真的非常好！</p>
<p>狂神说Linux视频地址：<a href="https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384">https://www.bilibili.com/video/BV187411y7hF?vd_source=ac95d1e4dae5cfd66da910c649ab5384</a></p>
<h1 id="服务器相关知识"><a href="#服务器相关知识" class="headerlink" title="服务器相关知识"></a>服务器相关知识</h1><blockquote>
<p>为什么程序员都需要一个自己的服务器？</p>
</blockquote>
<ol>
<li>作为一个程序员，必须要学会发布自己的网站和项目!</li>
<li>练习Linux操作</li>
<li>把自己的远程仓库、远程数据库、远程tomcat等搭建在服务器上</li>
<li>练习Linux进行任意的环境部署操作! 大部人都是Window下开发，不熟悉Linux</li>
</ol>
<blockquote>
<p>如何购买服务器？</p>
</blockquote>
<p>新手可以先去阿里云领一个免费的服务器先用着</p>
<p>阿里云新人服务器领取地址：<br><a href="https://imgtu.com/i/jFDbm6"><img src="https://s1.ax1x.com/2022/06/25/jFDbm6.jpg" alt="jFDbm6.jpg"></a><br>学生的话后期可以购买学生机，阿里云只有未满24周岁都可以享受学生机优惠</p>
<p>优惠地址：<a href="https://www.aliyun.com/minisite/goods?userCode=0phtycgr">https://www.aliyun.com/minisite/goods?userCode=0phtycgr</a></p>
<p>购买服务器时系统选择CentOS 推荐版本7.X，因为8.0之后改了好多命令，云盘的话选择40G就够用了，如下图所示：<br><a href="https://imgtu.com/i/jFDzpd"><img src="https://s1.ax1x.com/2022/06/25/jFDzpd.jpg" alt="jFDzpd.jpg"></a></p>
<blockquote>
<p>买完服务器之后该干什么？</p>
</blockquote>
<p>首先服务器就是一个远程的Linux</p>
<ol>
<li>在阿里云购买服务器需要开通安全组设置去进行端口的映射，比如8080或者3306<br><a href="https://imgtu.com/i/jFcwxH"><img src="https://s1.ax1x.com/2022/06/25/jFcwxH.jpg" alt="jFcwxH.jpg"></a></li>
<li>获取服务器的公网ip地址，修改实例名称和密码，记住第一次修改需要重启，修改后就可以使用Xshell进行远程连接了</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>运维</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵模式</title>
    <url>/2022/05/23/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h1><p><strong>介绍：</strong></p>
<p>主从切换技术的方法是:当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel (哨兵）架构来解决这个问题。</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数<strong>自动将从库转换为主库</strong>。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令,等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p>
<p><img src="https://s2.loli.net/2022/02/23/SJBvaebKFPW6Lxs.png" alt="image-20220223160951455"></p>
<p>这里的哨兵有两个作用<br>·通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。<br>·当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它<br>们切换主机。<br>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><img src="https://s2.loli.net/2022/02/23/cSP9LAlOKHjoTfX.png" alt="image-20220223161321009"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机,这个过程称为<strong>客观下线</strong>。</p>
<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p>创建一个哨兵的一个配置文件，文件名随意：sentinel.conf </p>
<p>配置文件：这里我就配置简单点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>



<p><strong>正常的一主二从:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6362,state=online,offset=141888,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6361,state=online,offset=141888,lag=1</span><br></pre></td></tr></table></figure>



<p><strong>启动哨兵模式：</strong></p>
<p><img src="https://s2.loli.net/2022/02/23/7OSxgQsbL6nyFRi.png" alt="image-20220223165032216"></p>
<p>命令：redis-sentinel  选用的配置文件，如果是哨兵集群就需要多个配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos StudyHardConfig]# redis-sentinel sentinel.conf </span><br><span class="line">742116:X 23 Feb 2022 16:29:48.399 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">742116:X 23 Feb 2022 16:29:48.399 # Redis version=6.0.6, bits=64, commit=00000000, modified=0, pid=742116, just started</span><br><span class="line">742116:X 23 Feb 2022 16:29:48.399 # Configuration loaded</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &#x27;&#x27;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &#x27;&#x27;-._           Redis 6.0.6 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &#x27;&#x27;-._                                   </span><br><span class="line"> (    &#x27;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&#x27;` _.-&#x27;|     Port: 26379   #哨兵端口</span><br><span class="line"> |    `-._   `._    /     _.-&#x27;    |     PID: 742116  </span><br><span class="line">  `-._    `-._  `-./  _.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span><br><span class="line"> |    `-._`-._        _.-&#x27;_.-&#x27;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span><br><span class="line">      `-._    `-.__.-&#x27;    _.-&#x27;                                       </span><br><span class="line">          `-._        _.-&#x27;                                           </span><br><span class="line">              `-.__.-&#x27;                                               </span><br><span class="line"></span><br><span class="line">742116:X 23 Feb 2022 16:29:48.404 # Sentinel ID is d0592a16972e6c88a456c5c2969cf4141a0e2f07</span><br><span class="line">742116:X 23 Feb 2022 16:29:48.404 # +monitor master mymaster 127.0.0.1 6360 quorum 1</span><br><span class="line">#侦测到两个从节点，并表明主节点是谁，现在主节点表明的6360这个端口的redis</span><br><span class="line">742116:X 23 Feb 2022 16:29:48.404 * +slave slave 127.0.0.1:6362 127.0.0.1 6362 @ mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:29:48.408 * +slave slave 127.0.0.1:6361 127.0.0.1 6361 @ mymaster 127.0.0.1 6360</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>断供主节点，让哨兵自动选择一个从节点当主节点：</strong> </p>
<p>如果master节点断开了，这个时候就会从 从机中随机选择一个服务器（根据一个投票算法）</p>
<p>哨兵打印的新信息：</p>
<p>这里投票，选择6362当主节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Feb 2022 16:37:29.007 # +sdown master mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.007 # +odown master mymaster 127.0.0.1 6360 #quorum 1/1</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.007 # +new-epoch 1</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.007 # +try-failover master mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.011 # +vote-for-leader d0592a16972e6c88a456c5c2969cf4141a0e2f07 1</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.011 # +elected-leader master mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.011 # +failover-state-select-slave master mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.066 # +selected-slave slave 127.0.0.1:6362 127.0.0.1 6362 @ mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.066 * +failover-state-send-slaveof-noone slave 127.0.0.1:6362 127.0.0.1 6362 @ mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.138 * +failover-state-wait-promotion slave 127.0.0.1:6362 127.0.0.1 6362 @ mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.419 # +promoted-slave slave 127.0.0.1:6362 127.0.0.1 6362 @ mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.420 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:29.498 * +slave-reconf-sent slave 127.0.0.1:6361 127.0.0.1 6361 @ mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:30.445 * +slave-reconf-inprog slave 127.0.0.1:6361 127.0.0.1 6361 @ mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:30.445 * +slave-reconf-done slave 127.0.0.1:6361 127.0.0.1 6361 @ mymaster 127.0.0.1 6360</span><br><span class="line">742116:X 23 Feb 2022 16:37:30.529 # +failover-end master mymaster 127.0.0.1 6360  #故障切换主线</span><br><span class="line">742116:X 23 Feb 2022 16:37:30.529 # +switch-master mymaster 127.0.0.1 6360 127.0.0.1 6362   #这里依旧选择了6362来当主节点</span><br><span class="line">742116:X 23 Feb 2022 16:37:30.529 * +slave slave 127.0.0.1:6361 127.0.0.1 6361 @ mymaster 127.0.0.1 6362</span><br><span class="line">742116:X 23 Feb 2022 16:37:30.529 * +slave slave 127.0.0.1:6360 127.0.0.1 6360 @ mymaster 127.0.0.1 6362</span><br><span class="line">742116:X 23 Feb 2022 16:38:00.593 # +sdown slave 127.0.0.1:6360 127.0.0.1 6360 @ mymaster 127.0.0.1 6362</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>我们来看看6362信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6362&gt;  SLAVEOF 127.0.0.1 6360</span><br><span class="line">OK Already connected to specified master</span><br><span class="line">127.0.0.1:6362&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master   		#身份依旧是主节点了</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6361,state=online,offset=191774,lag=1</span><br><span class="line">master_replid:01fa8e86c3fa6a51f5c111e46ef4e8622d062f23</span><br><span class="line">master_replid2:8009003a269bcd5e8af84c76891fc4bdc72dbf10</span><br><span class="line">master_repl_offset:191774</span><br><span class="line">second_repl_offset:170703</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:191774</span><br><span class="line">127.0.0.1:6362&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>如果这时6360这个节点重启呢？</p>
<p>​	如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则!</p>
<p>​	6362：  可以看到 它变成从节点，哨兵也同样会打印信息，我就不打出来了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6362&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6361,state=online,offset=198720,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=6360,state=online,offset=198720,lag=0</span><br><span class="line">master_replid:01fa8e86c3fa6a51f5c111e46ef4e8622d062f23</span><br><span class="line">master_replid2:8009003a269bcd5e8af84c76891fc4bdc72dbf10</span><br><span class="line">master_repl_offset:198720</span><br><span class="line">second_repl_offset:170703</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:198720</span><br><span class="line">127.0.0.1:6362&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p><strong>全部配置信息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Example sentinel.conf</span><br><span class="line"># 哨兵sentinel实例运行的端口 默认26379</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># 哨兵sentinel的工作目录</span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line"># 哨兵sentinel监控的redis主节点的 ip port</span><br><span class="line"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span><br><span class="line"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="line"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span><br><span class="line">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="line">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="line">#3.当想要取消一个正在进行的failover所需要的时间。 </span><br><span class="line">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="line"># 默认三分钟</span><br><span class="line"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"># SCRIPTS EXECUTION</span><br><span class="line">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="line">#对于脚本的运行结果有以下规则：</span><br><span class="line">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="line">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="line">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="line">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="line">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="line"></span><br><span class="line">#通知脚本</span><br><span class="line"># shell编程</span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"># 客户端重新配置主节点参数脚本</span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="line"># 以下参数将会在调用脚本时传给脚本:</span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="line"># 目前&lt;state&gt;总是“failover”,</span><br><span class="line"># &lt;role&gt;是“leader”或者“observer”中的一个。</span><br><span class="line"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="line"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh # 一般都是由运维来配置！</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="哨兵模式优缺点："><a href="#哨兵模式优缺点：" class="headerlink" title="哨兵模式优缺点："></a>哨兵模式优缺点：</h2><p>哨兵模式<br>优点︰<br>1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有2、主从可以切接，故障可以转移﹐系统的可用性就会史好3、哨兵模式就是主从模式的升级，手动到自动，更加建壮!缺点:</p>
<ol>
<li>Redis不好啊在。扩容的,集群容量一旦到达上限，在线扩容就十分麻烦!2、实现哨兵模式的配置只实是很麻烦的，里面有很多选择!</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务</title>
    <url>/2022/05/21/Redis%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列号，在事务执行过程中，会按照顺序执行！ 一次性，顺序性，排他性！执行一些列的命令！</p>
<p><strong>Redis事务没有隔离级别的概念！</strong> 所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行（Exec）</p>
<p><strong>Redis单条命令式保存原则性的，但是事务不保证原子性！</strong> 在事务中，就算中途发生错误后面的命令依旧会执行</p>
<p><strong>redis的事务：</strong> 1，开启命令（multi） 2，命令入队(…) 3，执行事务(exec) 4,退出事务（DISCARD）</p>
<p><strong>正常使用事务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set key1 value1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set key2 value2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list 1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>退出事务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set key aa</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>



<p><strong>编译型异常（代码有问题！命令有错！），事务中所有的命令都不会执行！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set s1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset sss</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;getset&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; set s2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure>



<p><strong>运行时异常（如果出现错误会打印出来，但并不妨碍接下来的命令执行）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr key1   #加1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set key2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) (error) ERR value is not an integer or out of range</span><br><span class="line">2) OK</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>



<h3 id="使用乐观锁"><a href="#使用乐观锁" class="headerlink" title="使用乐观锁"></a>使用乐观锁</h3><p>使用watch可充当乐观锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch key  #选择要监控的key</span><br><span class="line">unwatch   #当执行失败时放弃监视，并重新监视</span><br><span class="line">执行失败是因为值改变了，所以需要重新监视</span><br></pre></td></tr></table></figure>

<p>实际这部分是接着事务那一块，加了一个watch命令。</p>
<p>这里要有一个乐观锁和悲观锁的概念：<br>悲观锁：</p>
<p>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</p>
<p>乐观锁：</p>
<p>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据<br>获取version<br>更新的时候比较version</p>
<p>watch命令<br>使用watch key监控指定数据，相当于乐观锁加锁。类似一个CAS操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set money 100 # 设置余额:100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set use 0 # 支出使用:0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money # 监视money (上锁)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec # 监视值没有被中途修改，事务正常执行</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 20</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p>
<p>起两个客户端模拟多线程<br>线程一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money # money上锁</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; 	# 此时事务并没有执行</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程二</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY money 500 # 修改了线程一中监视的money</span><br><span class="line">(integer) 600</span><br></pre></td></tr></table></figure>

<p>回到线程一客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败</span><br><span class="line">(nil) # 没有结果，说明事务执行失败</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get money # 线程2 修改生效</span><br><span class="line">&quot;600&quot;</span><br><span class="line">127.0.0.1:6379&gt; get use # 线程1事务执行失败，数值没有被修改</span><br><span class="line">&quot;0&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解锁获取最新值，然后再加锁进行事务。</p>
<p>unwatch进行解锁。</p>
<p>实际上用得不多，很多利用redis分布式锁一般是setex+lua脚本（Redisson）</p>
<p>但是redis分布式锁是最简单实现的，但是也会有问题GC阻塞时间太长，导致时间失效，或者是redis服务器时钟漂移（就是两台服务器时间不一致，一个快导致两个服务器一把锁），还有单点故障master挂掉slave成为master也会带来问题。</p>
<p>解决单点故障有redlock，就是对多个端设置时间，但是对于每个redis实例设置一个超时时间，比如书1min有效时间，超时时间是1秒，你在1秒内获取不到这个实例，就取获取下一个锁。</p>
<p><strong>Redis乐观锁摘抄链接</strong>：<a href="https://blog.csdn.net/FeiChangWuRao/article/details/122824426">https://blog.csdn.net/FeiChangWuRao/article/details/122824426</a></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的三大特殊类型</title>
    <url>/2022/05/21/Redis%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Redis的三大特殊类型"><a href="#Redis的三大特殊类型" class="headerlink" title="Redis的三大特殊类型"></a>Redis的三大特殊类型</h2><h2 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h2><p>使用场景：朋友定位，附近的人，打车距离计数</p>
<p>Redis的Geo在Redis3.2版本就推出了</p>
<p>查询经度纬度：<a href="https://www.toolnb.com/tools/gps.html">https://www.toolnb.com/tools/gps.html</a></p>
<h3 id="相关命令："><a href="#相关命令：" class="headerlink" title="相关命令："></a>相关命令：</h3><h4 id="GEOADD（添加地理位置）"><a href="#GEOADD（添加地理位置）" class="headerlink" title="GEOADD（添加地理位置）"></a>GEOADD（添加地理位置）</h4><p>将指定的地理空间位置（经度、纬度、名称）添加到指定的key中 保存精度维度： 规则：南极北极不能添加，我们一般都是下载城市数据，使用java程序导入 参数：key-value（经度、纬度、名称）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.405289 39.904987 beijin</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 102.71 25.04 kunming</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 115.89 28.67 nanchang</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.15 30.28 hanzuo</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 113.28 23.12 guanzuo</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 104.06 30.65 chengdu 123.42 41.79 shenyang</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<h4 id="GEOPOS（读取存入的地理位置）"><a href="#GEOPOS（读取存入的地理位置）" class="headerlink" title="GEOPOS（读取存入的地理位置）"></a>GEOPOS（读取存入的地理位置）</h4><p>注意是直线距离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijin</span><br><span class="line">1) 1) &quot;116.40528827905654907&quot;</span><br><span class="line">   2) &quot;39.90498588819134085&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijin hanzuo</span><br><span class="line">1) 1) &quot;116.40528827905654907&quot;</span><br><span class="line">   2) &quot;39.90498588819134085&quot;</span><br><span class="line">2) 1) &quot;120.15000075101852417&quot;</span><br><span class="line">   2) &quot;30.2800007575645509&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<h4 id="GEODIST（返回两个维度之间的距离）"><a href="#GEODIST（返回两个维度之间的距离）" class="headerlink" title="GEODIST（返回两个维度之间的距离）"></a>GEODIST（返回两个维度之间的距离）</h4><p>127.0.0.1:6379&gt; GEODIST china:city beijin hanzuo km “1123.1795” 末尾是输入以那种发生计数距离，如显示km还是m GEOHASH</p>
<h4 id="GEORADIUS（以给定的极度伟度为中心，找出给定半径的城市）"><a href="#GEORADIUS（以给定的极度伟度为中心，找出给定半径的城市）" class="headerlink" title="GEORADIUS（以给定的极度伟度为中心，找出给定半径的城市）"></a>GEORADIUS（以给定的极度伟度为中心，找出给定半径的城市）</h4><p>注意：找的是已在集合中的地理位置</p>
<p>georadius key 精度 维度 距离 单位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km</span><br><span class="line">1) &quot;kunming&quot;</span><br><span class="line">2) &quot;chengdu&quot;</span><br><span class="line">3) &quot;guanzuo&quot;</span><br><span class="line">4) &quot;nanchang&quot;</span><br><span class="line">5) &quot;hanzuo&quot;</span><br></pre></td></tr></table></figure>



<p>加上withdist会显示直线距离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withdist</span><br><span class="line">1) 1) &quot;kunming&quot;</span><br><span class="line">   2) &quot;905.9321&quot;</span><br><span class="line">2) 1) &quot;chengdu&quot;</span><br><span class="line">   2) &quot;574.7802&quot;</span><br><span class="line">3) 1) &quot;guanzuo&quot;</span><br><span class="line">   2) &quot;831.7713&quot;</span><br><span class="line">4) 1) &quot;nanchang&quot;</span><br><span class="line">   2) &quot;589.8814&quot;</span><br><span class="line">5) 1) &quot;hanzuo&quot;</span><br><span class="line">   2) &quot;976.4868&quot;</span><br></pre></td></tr></table></figure>



<p>加上withcoord 显示经度纬度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withcoord</span><br><span class="line">1) 1) &quot;kunming&quot;</span><br><span class="line">   2) 1) &quot;102.70999878644943237&quot;</span><br><span class="line">      2) &quot;25.03999958679589355&quot;</span><br><span class="line">2) 1) &quot;chengdu&quot;</span><br><span class="line">   2) 1) &quot;104.05999749898910522&quot;</span><br><span class="line">      2) &quot;30.6499990746355806&quot;</span><br><span class="line">3) 1) &quot;guanzuo&quot;</span><br><span class="line">   2) 1) &quot;113.27999979257583618&quot;</span><br><span class="line">      2) &quot;23.1199990030198208&quot;</span><br><span class="line">4) 1) &quot;nanchang&quot;</span><br><span class="line">   2) 1) &quot;115.88999837636947632&quot;</span><br><span class="line">      2) &quot;28.66999910629679249&quot;</span><br><span class="line">5) 1) &quot;hanzuo&quot;</span><br><span class="line">   2) 1) &quot;120.15000075101852417&quot;</span><br><span class="line">      2) &quot;30.2800007575645509&quot;</span><br></pre></td></tr></table></figure>



<p>加上count * 可以限制显示几个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km  count 2</span><br><span class="line">1) &quot;chengdu&quot;</span><br><span class="line">2) &quot;nanchang&quot;</span><br></pre></td></tr></table></figure>



<p>withdist，withcoord，count *，在末尾可随意组合添加</p>
<h4 id="GEORADIUSBYMEMBER（根据指定的城市，查询他的半径的元素）"><a href="#GEORADIUSBYMEMBER（根据指定的城市，查询他的半径的元素）" class="headerlink" title="GEORADIUSBYMEMBER（根据指定的城市，查询他的半径的元素）"></a>GEORADIUSBYMEMBER（根据指定的城市，查询他的半径的元素）</h4><p>使用集合中的元素查询</p>
<p>普通查询：GEORADIUSBYMEMBER key 距离 单位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijin 1000 km  </span><br><span class="line">1) &quot;beijin&quot;</span><br><span class="line">2) &quot;shenyang&quot;</span><br></pre></td></tr></table></figure>



<p>加上withdist会显示直线距离</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijin 1000 km withdist</span><br><span class="line">1) 1) &quot;beijin&quot;</span><br><span class="line">   2) &quot;0.0000&quot;</span><br><span class="line">2) 1) &quot;shenyang&quot;</span><br><span class="line">   2) &quot;626.1044&quot;</span><br></pre></td></tr></table></figure>



<p>加上withcoord 显示经度纬度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijin 1000 km withcoord</span><br><span class="line">1) 1) &quot;beijin&quot;</span><br><span class="line">   2) 1) &quot;116.40528827905654907&quot;</span><br><span class="line">      2) &quot;39.90498588819134085&quot;</span><br><span class="line">2) 1) &quot;shenyang&quot;</span><br><span class="line">   2) 1) &quot;123.41999977827072144&quot;</span><br><span class="line">      2) &quot;41.78999971580505246&quot;</span><br></pre></td></tr></table></figure>



<p>加上count * 可以限制显示几个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijin 1000 km count 1</span><br><span class="line">1) &quot;beijin&quot;</span><br></pre></td></tr></table></figure>

<p>withdist，withcoord，count *，在末尾可随意组合添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijin 1500 km withcoord withdist count 2</span><br><span class="line">1) 1) &quot;beijin&quot;</span><br><span class="line">   2) &quot;0.0000&quot;</span><br><span class="line">   3) 1) &quot;116.40528827905654907&quot;</span><br><span class="line">      2) &quot;39.90498588819134085&quot;</span><br><span class="line">2) 1) &quot;shenyang&quot;</span><br><span class="line">   2) &quot;626.1044&quot;</span><br><span class="line">   3) 1) &quot;123.41999977827072144&quot;</span><br><span class="line">      2) &quot;41.78999971580505246&quot;</span><br></pre></td></tr></table></figure>



<h4 id="GEOHASH（返回11个字符的Geohash字符串）"><a href="#GEOHASH（返回11个字符的Geohash字符串）" class="headerlink" title="GEOHASH（返回11个字符的Geohash字符串）"></a>GEOHASH（返回11个字符的Geohash字符串）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEOHASH china:city beijin </span><br><span class="line">1) &quot;wx4g0b7xru0&quot;</span><br></pre></td></tr></table></figure>

<p>GEO底层的实现原来其实就是Zset,我们可以使用Zset命令来操作GEO 如： ZRANGE china:city 0 -1 #显示指定geo可以的数据 127.0.0.1:6379&gt; zrem china:city chengdu #删除</p>
<h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Redis2.8.9版本就跟新了Hyperlogog数据结构！ Redis Htperloglog 基数统计的算法！ 优点：占用的内存是固定，只需要废12KB内存！如果要从内存角度来比较的话Hyperloglog首选！ <strong>网页的UV（一个人访问一个网站多次，但是还是算做一个人）</strong> 传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断！（set不可重复） 这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；（使用Hyperloglog会有0.18的错误率！统计UV任务，可以忽略不计，如果要精确则不可使用）</p>
<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PFadd key element [element...]  #添加 将用户id存进去</span><br><span class="line">PFCOUNT key  #读取当前keu总数</span><br><span class="line">PFMERGE key3  key1  key2   #将key1和key2的数据合并到key3中，重复的会去除</span><br></pre></td></tr></table></figure>

<h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="### Bitmaps"></a>### Bitmaps</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>Bitmaps位图，数据结构！都是操作二进制来进行记录，就只有0和1两个状态！</p>
<p>使用场景：打卡，登录</p>
<p>操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit key offset value  #setbit sign 1 0 末尾只能是0和1</span><br><span class="line">getbit key offset   #获取指定的offset的值</span><br><span class="line">bitcount key   #获取指定的key中有多少个1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>redis总笔记</title>
    <url>/2022/05/21/redis%E6%80%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>这个博主的redis会比较详细，可以去观看它的，还有可以去看看它的视频</p>
<p>博主：狂神说</p>
<p><a href="https://www.cnblogs.com/meditation5201314/p/14882992.htm">https://www.cnblogs.com/meditation5201314/p/14882992.htm</a></p>
<p><strong>发布订阅简单使用：</strong></p>
<p><img src="https://s2.loli.net/2022/02/21/CilvKd8sFBtSJo9.png" alt="image-20220221140950917"></p>
]]></content>
      <tags>
        <tag>优秀文章</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的五大数据类型</title>
    <url>/2022/05/21/redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Redis简单了解与5大数据类型"><a href="#Redis简单了解与5大数据类型" class="headerlink" title="Redis简单了解与5大数据类型"></a>Redis简单了解与5大数据类型</h2><h2 id="Redis是单线程的"><a href="#Redis是单线程的" class="headerlink" title="Redis是单线程的"></a>Redis是单线程的</h2><p>Redis是很快的，官方表示，Redis是基于内存操作，cpu并不是Redis性能瓶颈，Redis的瓶颈是根据机器和网络带宽。</p>
<p>Redis是C语言写的，官方提供的数据为 100000+ 的Qps，完成不比同样是使用key-value的Memecahe差！</p>
<h2 id="Redis为什么单线程还那么快？"><a href="#Redis为什么单线程还那么快？" class="headerlink" title="Redis为什么单线程还那么快？"></a>Redis为什么单线程还那么快？</h2><p>1，高性能的服务器不一定是多线程的 2，多线程不一定比单线程效率高！</p>
<p>redis是将所有的数据全部放置内存中的，所以使用单线程去操作效率就是最高的，多线程cpu上下文切换耗时，对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都在一个cpu上的，在内存情况下，这个就是最佳方案</p>
<p>redis一共有16个数据库 默认使用第0个</p>
<h2 id="5大数据类型"><a href="#5大数据类型" class="headerlink" title="5大数据类型"></a>5大数据类型</h2><p>不区分大小写</p>
<h3 id="String-的一些命令"><a href="#String-的一些命令" class="headerlink" title="String 的一些命令"></a>String 的一些命令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select <span class="number">1</span> #改变数字可切换数据库</span><br><span class="line">keys *  #查看当前数据库使用的key</span><br><span class="line">set key value  #向数据库填充kv键值对数据</span><br><span class="line">get key  #获取指定key的value</span><br><span class="line">flushall  #清空全部 会将其他库的也清除</span><br><span class="line">flushdb   #清空单前数据库</span><br><span class="line">EXISTS key  #判断当前key是否存在 存在返回<span class="number">1</span> 否者<span class="number">0</span></span><br><span class="line">move key <span class="number">1</span> #将指定的key键值对移动到指定的数据库</span><br><span class="line">EXPIRE key <span class="number">10</span>  #将指定key在指定的时间过期 <span class="number">10</span>为<span class="number">10</span>秒</span><br><span class="line">ttl key  #查看指定的key还剩余多少存活时间 -<span class="number">1</span>为永久存活 -<span class="number">2</span>为死亡</span><br><span class="line">type key  #查看当前key的数据类型</span><br><span class="line">APPEND key content  #追加指定key的value的内容 content为追加内容 </span><br><span class="line">STRLEN key  #查看指定key的value长度</span><br><span class="line">incr key  #可以为指定的key自增</span><br><span class="line">decr key #为指定的key减<span class="number">1</span></span><br><span class="line">INCRBY key i  #为指定的key 加上 i个（数字）</span><br><span class="line">DECRBY key i  #为指定的key 减 i (数字)</span><br><span class="line">GETRANGE key s e  #截取指定长度字符串 ，该方法区间（ &#125;</span><br><span class="line">GETRANGE key i -<span class="number">1</span>  #结尾为-<span class="number">1</span>可以查看全部字符串 和 get一样</span><br><span class="line">SETRANGE key s content  #替换指定位置开始的字符串 输入几个就替换几个</span><br><span class="line">setex key time value  #创建或修改一个键值对，并设置过期时间</span><br><span class="line">setnx key value  #创建一个键值对 、当如何已经有这个键值对了就会创建失败</span><br><span class="line">mset key value [k v...]  #可一次设置多个，kv键值对</span><br><span class="line">mget key [key...]  #一次获取多个value</span><br><span class="line">msetnx key value [k v...]  #可一次设置多个，kv键值对，但要满足原子性，同时成功，同时失败</span><br><span class="line">getset key value  #读取并修改 先读，可以用于更新新内容</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>list可以当作链表来看，左右都可以插入</p>
<p>可控制向左向右添加后移出，是需要开头加 L（左） 或 R（右），List的命令以L开头，除控制左右外，可存在重复值</p>
<p>添加后内容顺序为 54321</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LPUSH key element [element...] #tianj或创建并添加值</span><br><span class="line">LRANGE key s e  ;#查看List的数据 从s开始 到e结束的位置</span><br><span class="line">LPOP #移出左第一个，（左右可调节）</span><br><span class="line">LINDEX key index   #根据下标查看值，必须大写，只能从左</span><br><span class="line">LLEN key   #获取指定list的长度</span><br><span class="line">LREM key count value  #移出指定的内容，并且可以设置移出几个</span><br><span class="line">ltrim key start stop  #通过下标截取要的部分 不在区间的则都移出</span><br><span class="line">rpoplpush key1 key2  #移出key1中最右的第一个并添加到key2的左边第一个</span><br><span class="line">lset key index value  #可修改list中指定下标的value，如果不存在列表就会报错</span><br><span class="line">LINSERT key before|after pivot element #向指定key里的value的前或后插入内容。 pivot key里的内容 element 插入的内容</span><br></pre></td></tr></table></figure>



<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>set的命令都是以s开头的 set中的值是无需不能重复的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sadd key value  #创建或添加</span><br><span class="line">SMEMBERS key  #查看set中的元素</span><br><span class="line">SISMEMBER key value  #判断当前set中是否有当前value</span><br><span class="line">scard setkey  #获取当前set的个数</span><br><span class="line">srem setkey element[element..]  #移出指定的值</span><br><span class="line">SRANDMEMBER setkey 【count】  #在指定的key中随机获取count个元素</span><br><span class="line">SPOP setkey 【count】  #随机移除count个元素</span><br><span class="line">SMOVE setkey1 setkey2 value  #将setkey1的value移出到setkey2中</span><br><span class="line">SINTER key [key...]  #获取选中key的交集，要都有的才会显示</span><br><span class="line">SUNION key [key...] #获取选中的并集，不会输出重复的 #并集解释：若A和B是集合，则A和B并集是有所有A的元素和所有B的元素，而没有其他元素的集合。A和B的并集通常写作 <span class="string">&quot;A∪B&quot;</span>，读作“A并B”</span><br></pre></td></tr></table></figure>



<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash类型为key-（key-value） 所有的hash命令是以h开头的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hset key field value [field value...]  #创建Hash</span><br><span class="line">#示例：hset hash field1 value1 ；key（hash）-value（field1-value1）</span><br><span class="line">#注意：低版本一次填充多个需要使用hmset命令</span><br><span class="line">hget key field   #获取field value值，需要两个key的值</span><br><span class="line">hmget key field [field...]  #获取多个 field ，高版本可能没有这个命令，而是直接使用hset</span><br><span class="line">hdel key field [field...]  #删除指定的field，</span><br><span class="line">hgetall key    #查看当前key中的value（k-v键值对都会显示）</span><br><span class="line">HEXISTS key field   #查询hash中是否存在指定的key</span><br><span class="line">hkeys key     #查看hash中所有的key</span><br><span class="line">hvals key     #查看hasg中所有的value</span><br><span class="line">HINCRBY key field i    #为指定key中的field 的value进行相加，可以加负数，这样就是相减</span><br><span class="line">hsetnx key field value #如果field存在则无需，不存在创建</span><br></pre></td></tr></table></figure>



<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>有序集合，，从小到大</p>
<p>在set的基础上加了一个值， zadd k score v ,多了个score多了了，可以用于表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zadd key sroce value [...]  #添加zset</span><br><span class="line">zrange key start stop  #查看指定key数据范围</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORCES] [LIMIT offset ount]   #用于指定key筛选排序  min可以使用-inf 意思为负无限制，max使用+inf 正无限，获取score包含在他们的区间值</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORCES] [LIMIT offset ount]  #上面排正序，这个是倒叙</span><br><span class="line">zrem key member [member...]   #使用要删除的value并移除</span><br><span class="line">ZCARD key   #查询当前集合key有多少个值</span><br><span class="line">ZCOUNT key min max #获取指定key的指定区间内有多个个值</span><br></pre></td></tr></table></figure>



<h2 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h2><p>一切以官网为准 <a href="http://www.redis.cn/" title="Redis官网">Redis官网</a></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的安装</title>
    <url>/2022/05/21/redis%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><h2 id="如何安装redis"><a href="#如何安装redis" class="headerlink" title="如何安装redis"></a>如何安装redis</h2><p>先去redis的官网下安装redis： <a href="http://www.redis.cn/">Redis中文官网</a></p>
<p>redis不推荐在windos上安装</p>
<p>CentOS7以上 安装方法： 安装ridis前需要先安装：gcc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<p>安装好gcc后解压你的Redis安装包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf Reids安装包   #gz为后缀的</span><br></pre></td></tr></table></figure>

<p>解压好后进入到redis里make编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd rieds</span><br><span class="line">make   #编译</span><br><span class="line">make install  #安装确认一下 也可以不执行</span><br></pre></td></tr></table></figure>

<p>到这就安装完成了！</p>
<p>我们可以去看下我们安装的程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/bin</span><br></pre></td></tr></table></figure>

<p>我们自己安装的程序都会在里面！</p>
<p>我们可以在这里创建一个文件夹存放我们配置文件，这里我们创建一个存放Redis的配置文件，以后修改也是修改这里的配置文件而不修改软件里的，可以确保安全性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir SHconfig</span><br><span class="line">cp /opt/Redis/redis-6.0.6/redis.conf SHconfig</span><br></pre></td></tr></table></figure>

<p>redis默认不是后台启动的，需要修改配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">将daemonize no 改为 daemonize yes</span><br><span class="line">设置密码</span><br><span class="line">requirepass foobared</span><br><span class="line">requirepass 123   指定密码123</span><br><span class="line">设置完密码后每次登录操作需要使用auth进行登录才能使用</span><br><span class="line">[root@VM-4-12-centos StudyHardConfig]# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set key1 q</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 031215</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set key1 v1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>



<h2 id="启动Redis："><a href="#启动Redis：" class="headerlink" title="启动Redis："></a>启动Redis：</h2><h3 id="在安装目录下执行："><a href="#在安装目录下执行：" class="headerlink" title="在安装目录下执行："></a>在安装目录下执行：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server shconfig/redis.conf #后面的参数是表示选用的配置文件</span><br></pre></td></tr></table></figure>

<h3 id="在安装目录下测试连接并退出："><a href="#在安装目录下测试连接并退出：" class="headerlink" title="在安装目录下测试连接并退出："></a>在安装目录下测试连接并退出：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos bin]# redis-cli -p 6379 #连接</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; set name studyhard</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;studyhard&quot;</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">127.0.0.1:6379&gt; shutdown #关闭reids</span><br><span class="line">not connected&gt; exit   #退出</span><br></pre></td></tr></table></figure>

<h2 id="当然还有更简单的方法"><a href="#当然还有更简单的方法" class="headerlink" title="当然还有更简单的方法"></a>当然还有更简单的方法</h2><p>使用宝塔面板~~ 十分的快捷</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>redis配置文件介绍</title>
    <url>/2022/05/19/redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Redis的配置文件解释"><a href="#Redis的配置文件解释" class="headerlink" title="Redis的配置文件解释"></a>Redis的配置文件解释</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1   #绑定的ip地址 这个是只运行本地访问</span><br><span class="line">protected-mode yes   # 保护模式   是为了禁止公网访问redis cache，加强redis安全的</span><br><span class="line">port  6379   #端口设置</span><br></pre></td></tr></table></figure>



<h2 id="通用GENERAL"><a href="#通用GENERAL" class="headerlink" title="通用GENERAL"></a>通用GENERAL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonize yes     #以守护线程的方式运行，默认是no，我们需要直接开启为yes！</span><br><span class="line"></span><br><span class="line">supervised no</span><br><span class="line">#如果需要在机器启动（upstart模式 或systemd模式）时就启动Redis服务器，可以通过该选项来配置Redis。</span><br><span class="line">#supervised no - 不会与supervised tree进行交互</span><br><span class="line">#supervised upstart - 将Redis服务器添加到SIGSTOP 模式中</span><br><span class="line">#supervised systemd - 将READY=1 写入 $NOTIFY_SOCKET</span><br><span class="line">#supervised auto - 根据环境变量UPSTART_JOB 或 NOTIFY_SOCKET检测upstart 还是 systemd</span><br><span class="line">#上述 supervision 方法（upstart或systemd）仅发出“程序已就绪”信号，不会继续给supervisor返回ping回复。</span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis_6379.pid   # 如果以后台方式运行，我们就需要指定一个pid文件！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">databases 16   # 有多少个数据库 默认16个</span><br><span class="line"></span><br><span class="line">logfile &quot;&quot;   #日志的文件位置名</span><br><span class="line"></span><br><span class="line">loglevel notice    #需要哪些情况打印log</span><br><span class="line">#日志</span><br><span class="line"># Specify the server verbosity level.</span><br><span class="line"># This can be one of:</span><br><span class="line"># debug (a lot of information, useful for development/testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably) 生产环境</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line"></span><br><span class="line">always-show-logo yes  #是否总是显示LOGO</span><br></pre></td></tr></table></figure>





<h2 id="SNAPSHOTTING-（快照）"><a href="#SNAPSHOTTING-（快照）" class="headerlink" title="SNAPSHOTTING :（快照）"></a>SNAPSHOTTING :（快照）</h2><p><strong>什么是快照？用来做什么？</strong></p>
<p>快照是特定数据集的一个完整可用的拷贝，该数据集包含源数据在拷贝点的静态映象，它可以是数据再现的一个副本或者复制。</p>
<p>说起来有些文绉绉的不好理解，那么这究竟是什么意思？<strong>通俗地讲，咱们可以把快照理解成拍照。</strong></p>
<p>譬如说，在某一时刻用手机给你拍了一张照片，那么照片中的你的状态就定格在了拍照的那一瞬间。当明天的你再来看这张照片的时候，你就能看到拍照时你的状态是如何的，这就是简单意义上的快照。</p>
<p>那么，快照的实际应用场景是哪些呢？前面其实有说到，快照是备份技术的一种，一旦原来的数据发生了变化（可能因为某些原因数据发生了丢失等等），使用快照就可以恢复原来的数据。</p>
<p><strong>redis是内存数据库，如果没有持久化，那么数据断电及失！</strong></p>
<p>持久化，在规定的时间内，执行了对少次操作，则会持久化到文件 .rdb .aof</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#如果在900秒内执行至少有一个 key进行了修改，我们就进行持久化操作</span><br><span class="line">save 900 1</span><br><span class="line">#如果在300秒内执行至少有10个 key进行了修改，我们就进行持久化操作</span><br><span class="line">save 300 10</span><br><span class="line">#如果在60秒内执行至少有10000个 key进行了修改，我们就进行持久化操作</span><br><span class="line">save 60 10000</span><br><span class="line">#这个持久化是可以自定义的，根据同上来自定义</span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes   #持久化如果出错。是否停止工作！</span><br><span class="line"></span><br><span class="line">rdbcompression yes   #是否压缩rad文件，是否需要消耗一些cpu资源！</span><br><span class="line"></span><br><span class="line">rdbchecksum yes   #保存rad文件的时候，进行错误的检查校验！</span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb  #持久化数据库的文件名</span><br><span class="line"></span><br><span class="line">dir ./  #rdb 文件保存的目录！</span><br></pre></td></tr></table></figure>



<h2 id="CLIENTS-（限制）"><a href="#CLIENTS-（限制）" class="headerlink" title="CLIENTS （限制）"></a>CLIENTS （限制）</h2><p><strong>这些默认不开启</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxclients 10000   #设置能连接上redis的最大客户端数量</span><br><span class="line"></span><br><span class="line">maxmemory &lt;bytes&gt;  # redis 配置最大的内存容量</span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction  #内存到达上限之后的处理策略</span><br><span class="line"># volatile-lru -&gt; 只对设置了过去时间的key进行LRU（默认值）</span><br><span class="line"># allkeys-lru -&gt; 删除LRU算法的key</span><br><span class="line"># allkeys-lfu -&gt; 随机删除</span><br><span class="line"># volatile-random -&gt; 随机删除即将过期的key</span><br><span class="line"># allkeys-random -&gt; 随机删除</span><br><span class="line"># volatile-ttl -&gt; 删除即将过期的</span><br><span class="line"># noeviction -&gt; 永不过期，返回错误</span><br></pre></td></tr></table></figure>



<h2 id="APPEND-ONLY模式-aof配置"><a href="#APPEND-ONLY模式-aof配置" class="headerlink" title="APPEND ONLY模式  aof配置"></a>APPEND ONLY模式  aof配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly no   #默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用！</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;  #持久化的文件名字</span><br><span class="line"></span><br><span class="line"># appendfsync always  #每次修改都会sync 。 消耗性能</span><br><span class="line">appendfsync everysec  #每次执行sync，可能会丢失这1秒的数据！</span><br><span class="line"># appendfsync no      #不执行sync，这个时候操作系统自己同步数据，速度最快</span><br></pre></td></tr></table></figure>





<h2 id="REPLICATION"><a href="#REPLICATION" class="headerlink" title="REPLICATION"></a>REPLICATION</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;    #设置连接主机ip 端口</span><br><span class="line">masterauth &lt;master-password&gt;     #设置连接主机需要的密码</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java经典面试题总结(含答案)</title>
    <url>/2022/05/28/Java%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E5%90%AB%E7%AD%94%E6%A1%88)/</url>
    <content><![CDATA[<p>前言：</p>
<p>本文为CSDN博主「哪 吒」的原创文章，本篇仅供学习使用，尊重原创</p>
<p>原文链接：<a href="https://blog.csdn.net/guorui_java/article/details/119299329">https://blog.csdn.net/guorui_java/article/details/119299329</a></p>
<hr>
<h3 id="1、JDK-和-JRE-有什么区别？"><a href="#1、JDK-和-JRE-有什么区别？" class="headerlink" title="1、JDK 和 JRE 有什么区别？"></a>1、JDK 和 JRE 有什么区别？</h3><p>JDK（Java Development Kit），Java开发工具包</p>
<p>JRE（Java Runtime Environment），Java运行环境</p>
<p>JDK中包含JRE，JDK中有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是JVM，lib就是JVM工作所需要的类库。</p>
<h3 id="2、-x3D-x3D-和-equals-的区别是什么？"><a href="#2、-x3D-x3D-和-equals-的区别是什么？" class="headerlink" title="2、&#x3D;&#x3D; 和 equals 的区别是什么？"></a>2、&#x3D;&#x3D; 和 equals 的区别是什么？</h3><p>对于基本类型，&#x3D;&#x3D;比较的是值；<br>对于引用类型，&#x3D;&#x3D;比较的是地址；<br>equals不能用于基本类型的比较；<br>如果没有重写equals，equals就相当于&#x3D;&#x3D;；<br>如果重写了equals方法，equals比较的是对象的内容；</p>
<h3 id="3、final-在-java-中有什么作用？"><a href="#3、final-在-java-中有什么作用？" class="headerlink" title="3、final 在 java 中有什么作用？"></a>3、final 在 java 中有什么作用？</h3><h4 id="（1）用来修饰一个引用"><a href="#（1）用来修饰一个引用" class="headerlink" title="（1）用来修饰一个引用"></a>（1）用来修饰一个引用</h4><p> 如果引用为基本数据类型，则该引用为常量，该值无法修改；<br> 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。<br> 如果引用时类的成员变量，则必须当场赋值，否则编译会报错。</p>
<h4 id="（2）用来修饰一个方法"><a href="#（2）用来修饰一个方法" class="headerlink" title="（2）用来修饰一个方法"></a>（2）用来修饰一个方法</h4><p>当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p>
<h4 id="（3）用来修饰类"><a href="#（3）用来修饰类" class="headerlink" title="（3）用来修饰类"></a>（3）用来修饰类</h4><p>当用final修改类时，该类成为最终类，无法被继承。</p>
<p>比如常用的String类就是最终类。</p>
<h3 id="4、java-中的-Math-round-1-5-等于多少？"><a href="#4、java-中的-Math-round-1-5-等于多少？" class="headerlink" title="4、java 中的 Math.round(-1.5) 等于多少？"></a>4、java 中的 Math.round(-1.5) 等于多少？</h3><p>Math提供了三个与取整有关的方法：ceil、floor、round</p>
<h4 id="（1）ceil：向上取整；"><a href="#（1）ceil：向上取整；" class="headerlink" title="（1）ceil：向上取整；"></a>（1）ceil：向上取整；</h4><p>Math.ceil(11.3) &#x3D; 12;</p>
<p>Math.ceil(-11.3) &#x3D; 11;</p>
<h4 id="（2）floor：向下取整；"><a href="#（2）floor：向下取整；" class="headerlink" title="（2）floor：向下取整；"></a>（2）floor：向下取整；</h4><p>Math.floor(11.3) &#x3D; 11;</p>
<p>Math.floor(-11.3) &#x3D; -12;</p>
<h4 id="（3）round：四舍五入；"><a href="#（3）round：四舍五入；" class="headerlink" title="（3）round：四舍五入；"></a>（3）round：四舍五入；</h4><p>加0.5然后向下取整。</p>
<p>Math.round(11.3) &#x3D; 11;</p>
<p>Math.round(11.8) &#x3D; 12;</p>
<p>Math.round(-11.3) &#x3D; -11;</p>
<p>Math.round(-11.8) &#x3D; -12;</p>
<h3 id="5、String-属于基础的数据类型吗？"><a href="#5、String-属于基础的数据类型吗？" class="headerlink" title="5、String 属于基础的数据类型吗？"></a>5、String 属于基础的数据类型吗？</h3><p>不属于。</p>
<p>八种基本数据类型：byte、short、char、int、long、double、float、boolean。</p>
<h3 id="6、String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？"><a href="#6、String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗？" class="headerlink" title="6、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？"></a>6、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</h3><p>String str&#x3D;”i”会将起分配到常量池中，常量池中没有重复的元素，如果常量池中存中i，就将i的地址赋给变量，如果没有就创建一个再赋给变量。</p>
<p>String str&#x3D;new String(“i”)会将对象分配到堆中，即使内存一样，还是会重新创建一个新的对象。</p>
<h3 id="7、如何将字符串反转？"><a href="#7、如何将字符串反转？" class="headerlink" title="7、如何将字符串反转？"></a>7、如何将字符串反转？</h3><p>将对象封装到stringBuilder中，调用reverse方法反转。</p>
<h3 id="8、String-类的常用方法都有那些？"><a href="#8、String-类的常用方法都有那些？" class="headerlink" title="8、String 类的常用方法都有那些？"></a>8、String 类的常用方法都有那些？</h3><h4 id="（1）常见String类的获取功能"><a href="#（1）常见String类的获取功能" class="headerlink" title="（1）常见String类的获取功能"></a>（1）常见String类的获取功能</h4><p>length：获取字符串长度；<br>charAt(int index)：获取指定索引位置的字符；<br>indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引；<br>substring(int start)：从指定位置开始截取字符串,默认到末尾；<br>substring(int start,int end)：从指定位置开始到指定位置结束截取字符串；</p>
<h4 id="（2）常见String类的判断功能"><a href="#（2）常见String类的判断功能" class="headerlink" title="（2）常见String类的判断功能"></a>（2）常见String类的判断功能</h4><p>equals(Object obj)： 比较字符串的内容是否相同,区分大小写；<br>contains(String str): 判断字符串中是否包含传递进来的字符串；<br>startsWith(String str): 判断字符串是否以传递进来的字符串开头；<br>endsWith(String str): 判断字符串是否以传递进来的字符串结尾；<br>isEmpty(): 判断字符串的内容是否为空串””；</p>
<h4 id="（3）常见String类的转换功能"><a href="#（3）常见String类的转换功能" class="headerlink" title="（3）常见String类的转换功能"></a>（3）常见String类的转换功能</h4><p>byte[] getBytes(): 把字符串转换为字节数组；<br>char[] toCharArray(): 把字符串转换为字符数组；<br>String valueOf(char[] chs): 把字符数组转成字符串。valueOf可以将任意类型转为字符串；<br>toLowerCase(): 把字符串转成小写；<br>toUpperCase(): 把字符串转成大写；<br>concat(String str): 把字符串拼接；</p>
<h4 id="（4）常见String类的其他常用功能"><a href="#（4）常见String类的其他常用功能" class="headerlink" title="（4）常见String类的其他常用功能"></a>（4）常见String类的其他常用功能</h4><p>replace(char old,char new) 将指定字符进行互换<br>replace(String old,String new) 将指定字符串进行互换<br>trim() 去除两端空格<br>int compareTo(String str) 会对照ASCII 码表 从第一个字母进行减法运算 返回的就是这个减法的结果，如果前面几个字母一样会根据两个字符串的长度进行减法运算返回的就是这个减法的结果，如果连个字符串一摸一样 返回的就是0。</p>
<h3 id="9、new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#9、new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="9、new String(“a”) + new String(“b”) 会创建几个对象？"></a>9、new String(“a”) + new String(“b”) 会创建几个对象？</h3><p>对象1：new StringBuilder()</p>
<p>对象2：new String(“a”)</p>
<p>对象3：常量池中的”a”</p>
<p>对象4：new String(“b”)</p>
<p>对象5：常量池中的”b”</p>
<p>深入剖析：StringBuilder中的toString()：</p>
<p>对象6：new String(“ab”)</p>
<p>强调一下，toString()的调用，在字符串常量池中，没有生成”ab”</p>
<p>附加题</p>
<p>String s1 &#x3D; new String(“1”) + new String(“1”);&#x2F;&#x2F;s1变量记录的地址为：new String<br>s1.intern();&#x2F;&#x2F;在字符串常量池中生成”11”。如何理解：jdk6：创建了一个新的对象”11”，也就有新的地址；jdk7：此时常量池中并没有创建”11”，而是创建了一个指向堆空间中new String(“11”)的地址；<br>String s2 &#x3D; “11”;<br>System.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;jdk6:false;jdk7:true</p>
<h3 id="10、如何将字符串反转？"><a href="#10、如何将字符串反转？" class="headerlink" title="10、如何将字符串反转？"></a>10、如何将字符串反转？</h3><p>添加到StringBuilder中，然后调用reverse()。</p>
<h3 id="11、String-类的常用方法都有那些？"><a href="#11、String-类的常用方法都有那些？" class="headerlink" title="11、String 类的常用方法都有那些？"></a>11、String 类的常用方法都有那些？</h3><p>equals、length、contains、replace、split、hashcode、indexof、substring、trim、toUpperCase、toLowerCase、isEmpty等等。</p>
<h3 id="12、普通类和抽象类有哪些区别？"><a href="#12、普通类和抽象类有哪些区别？" class="headerlink" title="12、普通类和抽象类有哪些区别？"></a>12、普通类和抽象类有哪些区别？</h3><p>抽象类不能被实例化；<br>抽象类可以有抽象方法，只需申明，无须实现；<br>有抽象方法的类一定是抽象类；<br>抽象类的子类必须实现抽象类中的所有抽象方法，否则子类仍然是抽象类；<br>抽象方法不能声明为静态、不能被static、final修饰。</p>
<h3 id="13、接口和抽象类有什么区别？"><a href="#13、接口和抽象类有什么区别？" class="headerlink" title="13、接口和抽象类有什么区别？"></a>13、接口和抽象类有什么区别？</h3><h4 id="（1）接口"><a href="#（1）接口" class="headerlink" title="（1）接口"></a>（1）接口</h4><p>接口使用interface修饰；<br>接口不能实例化；<br>类可以实现多个接口；</p>
<p>java8之前，接口中的方法都是抽象方法，省略了public abstract。②java8之后；接口中可以定义静态方法，静态方法必须有方法体，普通方法没有方法体，需要被实现；</p>
<h4 id="（2）抽象类"><a href="#（2）抽象类" class="headerlink" title="（2）抽象类"></a>（2）抽象类</h4><p>抽象类使用abstract修饰；<br>抽象类不能被实例化；<br>抽象类只能单继承；<br>抽象类中可以包含抽象方法和非抽象方法，非抽象方法需要有方法体；<br>如果一个类继承了抽象类，①如果实现了所有的抽象方法，子类可以不是抽象类；②如果没有实现所有的抽象方法，子类仍然是抽象类。</p>
<h3 id="14、java-中-IO-流分为几种？"><a href="#14、java-中-IO-流分为几种？" class="headerlink" title="14、java 中 IO 流分为几种？"></a>14、java 中 IO 流分为几种？</h3><p>（1）按流划分，可以分为输入流和输出流；</p>
<p>（2）按单位划分，可以分为字节流和字符流；</p>
<p>字节流：inputStream、outputStream；</p>
<p>字符流：reader、writer；</p>
<h3 id="15、BIO、NIO、AIO-有什么区别？"><a href="#15、BIO、NIO、AIO-有什么区别？" class="headerlink" title="15、BIO、NIO、AIO 有什么区别？"></a>15、BIO、NIO、AIO 有什么区别？</h3><h4 id="（1）同步阻塞BIO"><a href="#（1）同步阻塞BIO" class="headerlink" title="（1）同步阻塞BIO"></a>（1）同步阻塞BIO</h4><p>一个连接一个线程。</p>
<p>JDK1.4之前，建立网络连接的时候采用BIO模式，先在启动服务端socket，然后启动客户端socket，对服务端通信，客户端发送请求后，先判断服务端是否有线程响应，如果没有则会一直等待或者遭到拒绝请求，如果有的话会等待请求结束后才继续执行。</p>
<h4 id="（2）同步非阻塞NIO"><a href="#（2）同步非阻塞NIO" class="headerlink" title="（2）同步非阻塞NIO"></a>（2）同步非阻塞NIO</h4><p>NIO主要是想解决BIO的大并发问题，BIO是每一个请求分配一个线程，当请求过多时，每个线程占用一定的内存空间，服务器瘫痪了。</p>
<p>JDK1.4开始支持NIO，适用于连接数目多且连接比较短的架构，比如聊天服务器，并发局限于应用中。</p>
<p>一个请求一个线程。</p>
<h4 id="（3）异步非阻塞AIO"><a href="#（3）异步非阻塞AIO" class="headerlink" title="（3）异步非阻塞AIO"></a>（3）异步非阻塞AIO</h4><p>一个有效请求一个线程。</p>
<p>JDK1.7开始支持AIO，适用于连接数目多且连接比较长的结构，比如相册服务器，充分调用OS参与并发操作。</p>
<h3 id="16、Files的常用方法都有哪些？"><a href="#16、Files的常用方法都有哪些？" class="headerlink" title="16、Files的常用方法都有哪些？"></a>16、Files的常用方法都有哪些？</h3><p>exist<br>createFile<br>createDirectory<br>write<br>read<br>copy<br>size<br>delete<br>move</p>
<h3 id="17、什么是反射？"><a href="#17、什么是反射？" class="headerlink" title="17、什么是反射？"></a>17、什么是反射？</h3><p>所谓反射，是java在运行时进行自我观察的能力，通过class、constructor、field、method四个方法获取一个类的各个组成部分。</p>
<p>在Java运行时环境中，对任意一个类，可以知道类有哪些属性和方法。这种动态获取类的信息以及动态调用对象的方法的功能来自于反射机制。</p>
<h3 id="18、什么是-java-序列化？什么情况下需要序列化？"><a href="#18、什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="18、什么是 java 序列化？什么情况下需要序列化？"></a>18、什么是 java 序列化？什么情况下需要序列化？</h3><p>序列化就是一种用来处理对象流的机制。将对象的内容流化，将流化后的对象传输于网络之间。</p>
<p>序列化是通过实现serializable接口，该接口没有需要实现的方法，implement Serializable只是为了标注该对象是可被序列化的，使用一个输出流（FileOutputStream）来构造一个ObjectOutputStream对象，接着使用ObjectOutputStream对象的writeObejct（Object object）方法就可以将参数的obj对象到磁盘，需要恢复的时候使用输入流。</p>
<p>序列化是将对象转换为容易传输的格式的过程。</p>
<p>例如，可以序列化一个对象，然后通过HTTP通过Internet在客户端和服务器之间传输该对象。在另一端，反序列化将从流中心构造成对象。</p>
<p>一般程序在运行时，产生对象，这些对象随着程序的停止而消失，但我们想将某些对象保存下来，这时，我们就可以通过序列化将对象保存在磁盘，需要使用的时候通过反序列化获取到。</p>
<p>对象序列化的最主要目的就是传递和保存对象，保存对象的完整性和可传递性。</p>
<p>譬如通过网络传输或者把一个对象保存成本地一个文件的时候，需要使用序列化。</p>
<h3 id="19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？"><a href="#19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？" class="headerlink" title="19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？"></a>19、为什么要使用克隆？如何实现对象克隆？深拷贝和浅拷贝区别是什么？</h3><h4 id="（1）什么要使用克隆？"><a href="#（1）什么要使用克隆？" class="headerlink" title="（1）什么要使用克隆？"></a>（1）什么要使用克隆？</h4><p>想对一个对象进行复制，又想保留原有的对象进行接下来的操作，这个时候就需要克隆了。</p>
<h4 id="（2）如何实现对象克隆？"><a href="#（2）如何实现对象克隆？" class="headerlink" title="（2）如何实现对象克隆？"></a>（2）如何实现对象克隆？</h4><p>实现Cloneable接口，重写clone方法；<br>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。<br>BeanUtils，apache和Spring都提供了bean工具，只是这都是浅克隆。</p>
<h4 id="（3）深拷贝和浅拷贝区别是什么？"><a href="#（3）深拷贝和浅拷贝区别是什么？" class="headerlink" title="（3）深拷贝和浅拷贝区别是什么？"></a>（3）深拷贝和浅拷贝区别是什么？</h4><p>浅拷贝：仅仅克隆基本类型变量，不克隆引用类型变量；<br>深克隆：既克隆基本类型变量，又克隆引用类型变量；</p>
<h4 id="（4）代码实例"><a href="#（4）代码实例" class="headerlink" title="（4）代码实例"></a>（4）代码实例</h4><p><a href="https://imgtu.com/i/jkNEwQ"><img src="https://s1.ax1x.com/2022/06/25/jkNEwQ.png" alt="jkNEwQ.png"></a><br><a href="https://imgtu.com/i/jkNFOS"><img src="https://s1.ax1x.com/2022/06/25/jkNFOS.png" alt="jkNFOS.png"></a></p>
<h3 id="20、throw-和-throws-的区别？"><a href="#20、throw-和-throws-的区别？" class="headerlink" title="20、throw 和 throws 的区别？"></a>20、throw 和 throws 的区别？</h3><h4 id="（1）throw"><a href="#（1）throw" class="headerlink" title="（1）throw"></a>（1）throw</h4><p>作用在方法内，表示抛出具体异常，由方法体内的语句处理；<br>一定抛出了异常；</p>
<h4 id="（2）throws"><a href="#（2）throws" class="headerlink" title="（2）throws"></a>（2）throws</h4><p>作用在方法的声明上，表示抛出异常，由调用者来进行异常处理；<br>可能出现异常，不一定会发生异常；</p>
<h3 id="21、final、finally、finalize-有什么区别？"><a href="#21、final、finally、finalize-有什么区别？" class="headerlink" title="21、final、finally、finalize 有什么区别？"></a>21、final、finally、finalize 有什么区别？</h3><p>final可以修饰类，变量，方法，修饰的类不能被继承，修饰的变量不能重新赋值，修饰的方法不能被重写</p>
<p>finally用于抛异常，finally代码块内语句无论是否发生异常，都会在执行finally，常用于一些流的关闭。</p>
<p>finalize方法用于垃圾回收。</p>
<p>一般情况下不需要我们实现finalize，当对象被回收的时候需要释放一些资源，比如socket链接，在对象初始化时创建，整个生命周期内有效，那么需要实现finalize方法，关闭这个链接。</p>
<p>但是当调用finalize方法后，并不意味着gc会立即回收该对象，所以有可能真正调用的时候，对象又不需要回收了，然后到了真正要回收的时候，因为之前调用过一次，这次又不会调用了，产生问题。所以，不推荐使用finalize方法。</p>
<h3 id="22、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#22、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>22、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p><a href="https://imgtu.com/i/jkNAeg"><img src="https://s1.ax1x.com/2022/06/25/jkNAeg.png" alt="jkNAeg.png"></a></p>
<h3 id="23、常见的异常类有哪些？"><a href="#23、常见的异常类有哪些？" class="headerlink" title="23、常见的异常类有哪些？"></a>23、常见的异常类有哪些？</h3><p>NullPointerException：空指针异常；<br>SQLException：数据库相关的异常；<br>IndexOutOfBoundsException：数组下角标越界异常；<br>FileNotFoundException：打开文件失败时抛出；<br>IOException：当发生某种IO异常时抛出；<br>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出此异常；<br>NoSuchMethodException：无法找到某一方法时，抛出；<br>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常；<br>NumberFormatException：当试图将字符串转换成数字时，失败了，抛出；<br>IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。<br>ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 </p>
<h3 id="24、hashcode是什么？有什么作用？"><a href="#24、hashcode是什么？有什么作用？" class="headerlink" title="24、hashcode是什么？有什么作用？"></a>24、hashcode是什么？有什么作用？</h3><p>Java中Object有一个方法：</p>
<p>public native int hashcode();</p>
<h4 id="（1）hashcode-方法的作用"><a href="#（1）hashcode-方法的作用" class="headerlink" title="（1）hashcode()方法的作用"></a>（1）hashcode()方法的作用</h4><p>hashcode()方法主要配合基于散列的集合一起使用，比如HashSet、HashMap、HashTable。</p>
<p>当集合需要添加新的对象时，先调用这个对象的hashcode()方法，得到对应的hashcode值，实际上hashmap中会有一个table保存已经存进去的对象的hashcode值，如果table中没有改hashcode值，则直接存入，如果有，就调用equals方法与新元素进行比较，相同就不存了，不同就存入。</p>
<h4 id="（2）equals和hashcode的关系"><a href="#（2）equals和hashcode的关系" class="headerlink" title="（2）equals和hashcode的关系"></a>（2）equals和hashcode的关系</h4><p>如果equals为true，hashcode一定相等； </p>
<p>如果equals为false，hashcode不一定不相等；</p>
<p>如果hashcode值相等，equals不一定相等；</p>
<p>如果hashcode值不等，equals一定不等；</p>
<h4 id="（3）重写equals方法时，一定要重写hashcode方法"><a href="#（3）重写equals方法时，一定要重写hashcode方法" class="headerlink" title="（3）重写equals方法时，一定要重写hashcode方法"></a>（3）重写equals方法时，一定要重写hashcode方法</h4><h4 id="（4）百度百科"><a href="#（4）百度百科" class="headerlink" title="（4）百度百科"></a>（4）百度百科</h4><blockquote>
<p>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。 </p>
<p>hashCode 的常规协定是：<br>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。<br>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。<br>以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。） </p>
<p>当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
</blockquote>
<h4 id="（5）小白解释"><a href="#（5）小白解释" class="headerlink" title="（5）小白解释"></a>（5）小白解释</h4><blockquote>
<p>1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有<br>例如内存中有这样的位置<br>0  1  2  3  4  5  6  7<br>而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。<br>但如果用hashcode那就会使效率提高很多。<br>我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。</p>
<p>2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。<br>也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。<br>那么。重写了equals()，为什么还要重写hashCode()呢？<br>想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊。</p>
</blockquote>
<h3 id="25、java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#25、java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="25、java 中操作字符串都有哪些类？它们之间有什么区别？"></a>25、java 中操作字符串都有哪些类？它们之间有什么区别？</h3><h4 id="（1）String"><a href="#（1）String" class="headerlink" title="（1）String"></a>（1）String</h4><p>String是不可变对象，每次对String类型的改变时都会生成一个新的对象。</p>
<h4 id="（2）StringBuilder"><a href="#（2）StringBuilder" class="headerlink" title="（2）StringBuilder"></a>（2）StringBuilder</h4><p>线程不安全，效率高，多用于单线程。</p>
<h4 id="（3）StringBuffer"><a href="#（3）StringBuffer" class="headerlink" title="（3）StringBuffer"></a>（3）StringBuffer</h4><p>线程安全，由于加锁的原因，效率不如StringBuilder，多用于多线程。</p>
<p>不频繁的字符串操作使用String，操作频繁的情况不建议使用String。</p>
<p>StringBuilder &gt; StringBuffer &gt; String。</p>
<h3 id="26、java-中都有哪些引用类型？"><a href="#26、java-中都有哪些引用类型？" class="headerlink" title="26、java 中都有哪些引用类型？"></a>26、java 中都有哪些引用类型？</h3><h4 id="（1）强引用"><a href="#（1）强引用" class="headerlink" title="（1）强引用"></a>（1）强引用</h4><p>Java中默认声明的就是强引用，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象。如果想被回收，可以将对象置为null； </p>
<h4 id="（2）软引用（SoftReference）"><a href="#（2）软引用（SoftReference）" class="headerlink" title="（2）软引用（SoftReference）"></a>（2）软引用（SoftReference）</h4><p>在内存足够的时候，软引用不会被回收，只有在内存不足时，系统才会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会跑出内存溢出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; sr = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(buff);</span><br></pre></td></tr></table></figure>
<p>####（3）弱引用（WeakReference）</p>
<p>进行垃圾回收时，弱引用就会被回收。</p>
<h4 id="（4）虚引用（PhantomReference）"><a href="#（4）虚引用（PhantomReference）" class="headerlink" title="（4）虚引用（PhantomReference）"></a>（4）虚引用（PhantomReference）</h4><h4 id="（5）引用队列（ReferenceQueue）"><a href="#（5）引用队列（ReferenceQueue）" class="headerlink" title="（5）引用队列（ReferenceQueue）"></a>（5）引用队列（ReferenceQueue）</h4><p>引用队列可以与软引用、弱引用、虚引用一起配合使用。</p>
<p>当垃圾回收器准备回收一个对象时，如果发现它还有引用，就会在回收对象之前，把这个引用加入到引用队列中。</p>
<p>程序可以通过判断引用队列中是否加入了引用，来判断被引用的对象是否将要被垃圾回收，这样可以在对象被回收之前采取一些必要的措施。</p>
<h3 id="27、在-Java-中，为什么不允许从静态方法中访问非静态变量？"><a href="#27、在-Java-中，为什么不允许从静态方法中访问非静态变量？" class="headerlink" title="27、在 Java 中，为什么不允许从静态方法中访问非静态变量？"></a>27、在 Java 中，为什么不允许从静态方法中访问非静态变量？</h3><p>静态变量属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问；<br>非静态变量属于类的对象，只有在类的对象产生时，才会分配内存，通过类的实例去访问；<br>静态方法也属于类本身，但是此时没有类的实例，内存中没有非静态变量，所以无法调用。</p>
<h3 id="28、说说Java-Bean的命名规范"><a href="#28、说说Java-Bean的命名规范" class="headerlink" title="28、说说Java Bean的命名规范"></a>28、说说Java Bean的命名规范</h3><p>JavaBean 类必须是一个公共类，并将其访问属性设置为 public<br>JavaBean 类必须有一个空的构造函数：类中必须有一个不带参数的公用构造器，此构造器也应该通过调用各个特性的设置方法来设置特性的缺省值。<br>一个javaBean类不应有公共实例变量，类变量都为private<br>持有值应该通过一组存取方法（getXxx 和 setXxx）来访问：对于每个特性，应该有一个带匹配公用 getter 和 setter 方法的专用实例变量。<br>属性为布尔类型，可以使用 isXxx() 方法代替 getXxx() 方法。</p>
<p>通常属性名是要和 包名、类名、方法名、字段名、常量名作出区别的:</p>
<p>首先:必须用英文，不要用汉语拼音</p>
<h4 id="（1）包-package"><a href="#（1）包-package" class="headerlink" title="（1）包(package)"></a>（1）包(package)</h4><p>用于将完成不同功能的类分门别类，放在不同的目录(包)下，包的命名规则：将公司域名反转作为包名。比如<a href="http://www.sohu.com/">www.sohu.com</a> 对于包名：每个字母都需要小写。比如：com.sohu.test;该包下的Test类的全名是：com.sohu.Test.Java 。</p>
<p>如果定义类的时候没有使用package,那么java就认为我们所定义的类位于默认包里面(default package)。</p>
<h4 id="（2）类"><a href="#（2）类" class="headerlink" title="（2）类"></a>（2）类</h4><p>首字母大写，如果一个类由多个单词构成，那么每个单词的首字母都大写，而且中间不使用任何的连接符。尽量使用英文。如ConnectionFactory</p>
<h4 id="（3）方法"><a href="#（3）方法" class="headerlink" title="（3）方法"></a>（3）方法</h4><p>首单词全部小写，如果一个方法由多个单词构成，那么从第二个单词开始首字母大写，不使用连接符。addPerson</p>
<h4 id="（4）字段"><a href="#（4）字段" class="headerlink" title="（4）字段"></a>（4）字段</h4><p>与方法相同。如ageOfPerson</p>
<h4 id="（5）常量"><a href="#（5）常量" class="headerlink" title="（5）常量"></a>（5）常量</h4><p>所有单词的字母都是大写，如果有多个单词，那么使用下划线链接即可。</p>
<p>如：public static final int AGE_OF_PERSON &#x3D; 20; &#x2F;&#x2F;通常加上static</p>
<h3 id="29、Java-Bean-属性命名规范问题分析"><a href="#29、Java-Bean-属性命名规范问题分析" class="headerlink" title="29、Java Bean 属性命名规范问题分析"></a>29、Java Bean 属性命名规范问题分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String busName;</span><br><span class="line">	<span class="keyword">private</span> String pCount;</span><br><span class="line">	<span class="keyword">private</span> Boolean isRunning;</span><br><span class="line">	<span class="comment">//正确的命名方式，驼峰式的</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getBusName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> busName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBusName</span><span class="params">(String busName)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.busName = busName;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//这是什么？</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getpCount</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> pCount;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setpCount</span><span class="params">(String pCount)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.pCount = pCount;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//这个也是不允许的</span></span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">getIsRunning</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> isRunning;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIsRunning</span><span class="params">(Boolean isRunning)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.isRunning = isRunning;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>javabean属性命名尽量使用常规的驼峰式命名规则</li>
<li>属性名第一个单词尽量避免使用一个字母：如eBook， eMail。</li>
<li>boolean属性名避免使用 “is” 开头的名称</li>
<li>随着jdk， eclipse， spring 等软件版本的不断提高， 底版本的出现的问题可能在高版本中解决了， 低版本原来正常的代码可能在高版本环境下不再支持。</li>
</ol>
<h3 id="30、什么是-Java-的内存模型"><a href="#30、什么是-Java-的内存模型" class="headerlink" title="30、什么是 Java 的内存模型?"></a>30、什么是 Java 的内存模型?</h3><p>在了解什么是 Java 内存模型之前，先了解一下为什么要提出 Java 内存模型。</p>
<p>之前提到过并发编程有三大问题</p>
<p>CPU 缓存，在多核 CPU 的情况下，带来了可见性问题<br>操作系统对当前执行线程的切换，带来了原子性问题<br>译器指令重排优化，带来了有序性问题<br>为了解决并发编程的三大问题，提出了 JSR-133，新的 Java 内存模型，JDK 5 开始使用。</p>
<p>简单总结下</p>
<p>Java 内存模型是 JVM 的一种规范<br>定义了共享内存在多线程程序中读写操作行为的规范<br>屏蔽了各种硬件和操作系统的访问差异，保证了 Java 程序在各种平台下对内存的访问效果一致<br>解决并发问题采用的方式：限制处理器优化和使用内存屏障<br>增强了三个同步原语（synchronized、volatile、final）的内存语义<br>定义了 happens-before 规则</p>
<h3 id="31、在-Java-中，什么时候用重载，什么时候用重写？"><a href="#31、在-Java-中，什么时候用重载，什么时候用重写？" class="headerlink" title="31、在 Java 中，什么时候用重载，什么时候用重写？"></a>31、在 Java 中，什么时候用重载，什么时候用重写？</h3><p>（1）重载是多态的集中体现，在类中，要以统一的方式处理不同类型数据的时候，可以用重载。</p>
<p>（2）重写的使用是建立在继承关系上的，子类在继承父类的基础上，增加新的功能，可以用重写。</p>
<p>（3）简单总结：</p>
<p>重载是多样性，重写是增强剂；<br>目的是提高程序的多样性和健壮性，以适配不同场景使用时，使用重载进行扩展；<br>目的是在不修改原方法及源代码的基础上对方法进行扩展或增强时，使用重写；</p>
<p>生活例子：</p>
<blockquote>
<p>你想吃一碗面，我给你提供了拉面，炒面，刀削面，担担面供你选择，这是重载；</p>
<p>你想吃一碗面，我不但给你端来了面，还给你加了青菜，加了鸡蛋，这个是重写；</p>
</blockquote>
<p>设计模式：</p>
<blockquote>
<p>cglib实现动态代理，核心原理用的就是方法的重写；</p>
</blockquote>
<p>详细解答：</p>
<blockquote>
<p>Java的重载(overload) 最重要的应用场景就是构造器的重载，构造器重载后，提供多种形参形式的构造器，可以应对不同的业务需求，加强程序的健壮性和可扩展性，比如我们最近学习的Spring源码中的ClassPathXmlApplicationContext，它的构造函数使用重载一共提供了10个构造函数，这样就为业务的选择提供了多选择性。在应用到方法中时，主要是为了增强方法的健壮性和可扩展性，比如我们在开发中常用的各种工具类，比如我目前工作中的短信工具类SMSUtil, 发短信的方法就会使用重载，针对不同业务场景下的不同形参，提供短信发送方法，这样提高了工具类的扩展性和健壮性。<br>总结：重载必须要修改方法(构造器)的形参列表，可以修改方法的返回值类型，也可以修改方法的异常信息即访问权限；使用范围是在同一个类中，目的是对方法(构造器)进行功能扩展，以应对多业务场景的不同使用需求。提高程序的健壮性和扩展性。<br> java的重写(override) 只要用于子类对父类方法的扩展或修改，但是在我们开发中，为了避免程序混乱，重写一般都是为了方法的扩展，比如在cglib方式实现的动态代理中，代理类就是继承了目标类，对目标类的方法进行重写，同时在方法前后进行切面织入。</p>
</blockquote>
<p>总结：方法重写时，参数列表，返回值得类型是一定不能修改的，异常可以减少或者删除，但是不能抛出新的异常或者更广的异常，方法的访问权限可以降低限制，但是不能做更严格的限制。</p>
<p>（4）在里氏替换原则中，子类对父类的方法尽量不要重写和重载。（我们可以采用final的手段强制来遵循）</p>
<h3 id="32、举例说明什么情况下会更倾向于使用抽象类而不是接口？"><a href="#32、举例说明什么情况下会更倾向于使用抽象类而不是接口？" class="headerlink" title="32、举例说明什么情况下会更倾向于使用抽象类而不是接口？"></a>32、举例说明什么情况下会更倾向于使用抽象类而不是接口？</h3><p>接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：在 Java 中，你只能继承一个类，但可以实现多个接口。所以一旦你继承了一个类，你就失去了继承其他类的机会了。</p>
<p>接口通常被用来表示附属描述或行为如： Runnable 、 Clonable 、 Serializable 等等，因此当你使用抽象类来表示行为时，你的类就不能同时是 Runnable 和 Clonable( 注：这里的意思是指如果把 Runnable 等实现为抽象类的情况 ) ，因为在 Java 中你不能继承两个类，但当你使用接口时，你的类就可以同时拥有多个不同的行为。</p>
<p>在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。</p>
<h3 id="33、实例化对象有哪几种方式"><a href="#33、实例化对象有哪几种方式" class="headerlink" title="33、实例化对象有哪几种方式"></a>33、实例化对象有哪几种方式</h3><ul>
<li><p>new</p>
</li>
<li><p>clone()</p>
</li>
<li><p>通过反射机制创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用 Class.forName方法获取类，在调用类的newinstance（）方法</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;com.dao.User&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)cls.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p>序列化反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将一个对象实例化后，进行序列化，再反序列化，也可以获得一个对象（远程通信的场景下使用）</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span> (<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"><span class="comment">//序列化对象</span></span><br><span class="line">out.writeObject(user1); </span><br><span class="line">out.close();</span><br><span class="line"><span class="comment">//反序列化对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/data.txt&quot;</span>));</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) in.readObject();</span><br><span class="line">System.out.println(<span class="string">&quot;反序列化user：&quot;</span> + user2);</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="34、byte类型127-1等于多少"><a href="#34、byte类型127-1等于多少" class="headerlink" title="34、byte类型127+1等于多少"></a>34、byte类型127+1等于多少</h3><p>byte的范围是-128~127。</p>
<p>字节长度为8位，最左边的是符号位，而127的二进制为01111111，所以执行+1操作时，01111111变为10000000。</p>
<p>大家知道，计算机中存储负数，存的是补码的兴衰。左边第一位为符号位。</p>
<p>那么负数的补码转换成十进制如下：</p>
<p>一个数如果为正，则它的原码、反码、补码相同；一个正数的补码，将其转化为十进制，可以直接转换。</p>
<p>已知一个负数的补码，将其转换为十进制数，步骤如下：</p>
<p>先对各位取反；<br>将其转换为十进制数；<br>加上负号，再减去1；<br>例如10000000，最高位是1，是负数，①对各位取反得01111111，转换为十进制就是127，加上负号得-127，再减去1得-128；</p>
<h3 id="35、Java-容器都有哪些？"><a href="#35、Java-容器都有哪些？" class="headerlink" title="35、Java 容器都有哪些？"></a>35、Java 容器都有哪些？</h3><p>（1）Collection</p>
<p>① set</p>
<p>HashSet、TreeSet</p>
<p>② list</p>
<p>ArrayList、LinkedList、Vector</p>
<p>（2）Map</p>
<p>HashMap、HashTable、TreeMap</p>
<h3 id="36、Collection-和-Collections-有什么区别？"><a href="#36、Collection-和-Collections-有什么区别？" class="headerlink" title="36、Collection 和 Collections 有什么区别？"></a>36、Collection 和 Collections 有什么区别？</h3><p>（1）Collection是最基本的集合接口，Collection派生了两个子接口list和set，分别定义了两种不同的存储方式。</p>
<p>（2）Collections是一个包装类，它包含各种有关集合操作的静态方法（对集合的搜索、排序、线程安全化等）。</p>
<p>此类不能实例化，就像一个工具类，服务于Collection框架。</p>
<h3 id="37、list与Set区别"><a href="#37、list与Set区别" class="headerlink" title="37、list与Set区别"></a>37、list与Set区别</h3><h4 id="（1）List简介"><a href="#（1）List简介" class="headerlink" title="（1）List简介"></a>（1）List简介</h4><p>实际上有两种List：一种是基本的ArrayList,其优点在于随机访问元素，另一种是LinkedList,它并不是为快速随机访问设计的，而是快速的插入或删除。<br>ArrayList：由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。<br>LinkedList ：对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。<br>还具有下列方 法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法 (没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。</p>
<h4 id="（2）Set简介"><a href="#（2）Set简介" class="headerlink" title="（2）Set简介"></a>（2）Set简介</h4><p>Set具有与Collection完全一样的接口，因此没有任何额外的功能。实际上Set就是Collection,只是行为不同。这是继承与多态思想的典型应用：表现不同的行为。Set不保存重复的元素(至于如何判断元素相同则较为负责) </p>
<p>Set : 存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。<br>HashSet：为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。<br>TreeSet： 保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。 </p>
<h4 id="（3）list与Set区别"><a href="#（3）list与Set区别" class="headerlink" title="（3）list与Set区别"></a>（3）list与Set区别</h4><p>① List,Set都是继承自Collection接口</p>
<p>② List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。） </p>
<p>③ Set和List对比： </p>
<p>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</p>
<h3 id="38、HashMap-和-Hashtable-有什么区别？"><a href="#38、HashMap-和-Hashtable-有什么区别？" class="headerlink" title="38、HashMap 和 Hashtable 有什么区别？"></a>38、HashMap 和 Hashtable 有什么区别？</h3><p>HashMap是线程不安全的，HashTable是线程安全的；<br>HashMap中允许键和值为null，HashTable不允许；<br>HashMap的默认容器是16，为2倍扩容，HashTable默认是11，为2倍+1扩容；</p>
<h3 id="39、说一下-HashMap-的实现原理？"><a href="#39、说一下-HashMap-的实现原理？" class="headerlink" title="39、说一下 HashMap 的实现原理？"></a>39、说一下 HashMap 的实现原理？</h3><h4 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>HashMap基于map接口，元素以键值对方式存储，允许有null值，HashMap是线程不安全的。</p>
<h4 id="（2）基本属性"><a href="#（2）基本属性" class="headerlink" title="（2）基本属性"></a>（2）基本属性</h4><p>初始化大小，默认16，2倍扩容；<br>负载因子0.75；<br>初始化的默认数组；<br>size<br>threshold。判断是否需要调整hashmap容量</p>
<h4 id="（3）HashMap的存储结构"><a href="#（3）HashMap的存储结构" class="headerlink" title="（3）HashMap的存储结构"></a>（3）HashMap的存储结构</h4><p>JDK1.7中采用数组+链表的存储形式。</p>
<p>HashMap采取Entry数组来存储key-value，每一个键值对组成了一个Entry实体，Entry类时机上是一个单向的链表结构，它具有next指针，指向下一个Entry实体，以此来解决Hash冲突的问题。</p>
<p>HashMap实现一个内部类Entry，重要的属性有hash、key、value、next。<br><a href="https://imgtu.com/i/jkaUsK"><img src="https://s1.ax1x.com/2022/06/25/jkaUsK.jpg" alt="jkaUsK.jpg"></a></p>
<p>JDK1.8中采用数据+链表+红黑树的存储形式。当链表长度超过阈值（8）时，将链表转换为红黑树。在性能上进一步得到提升。<br><a href="https://imgtu.com/i/jkaNM6"><img src="https://s1.ax1x.com/2022/06/25/jkaNM6.jpg" alt="jkaNM6.jpg"></a></p>
<h3 id="40、set有哪些实现类？"><a href="#40、set有哪些实现类？" class="headerlink" title="40、set有哪些实现类？"></a>40、set有哪些实现类？</h3><h4 id="（1）HashSet"><a href="#（1）HashSet" class="headerlink" title="（1）HashSet"></a>（1）HashSet</h4><p>HashSet是set接口的实现类，set下面最主要的实现类就是HashSet（也就是用的最多的），此外还有LinkedHashSet和TreeSet。<br>HashSet是无序的、不可重复的。通过对象的hashCode和equals方法保证对象的唯一性。<br>HashSet内部的存储结构是哈希表，是线程不安全的。</p>
<h4 id="（2）TreeSet"><a href="#（2）TreeSet" class="headerlink" title="（2）TreeSet"></a>（2）TreeSet</h4><p>TreeSet对元素进行排序的方式：</p>
<p>元素自身具备比较功能，需要实现Comparable接口，并覆盖compareTo方法。<br>元素自身不具备比较功能，需要实现Comparator接口，并覆盖compare方法。</p>
<h4 id="（3）LinkedHashSet"><a href="#（3）LinkedHashSet" class="headerlink" title="（3）LinkedHashSet"></a>（3）LinkedHashSet</h4><p>LinkedHashSet是一种有序的Set集合，即其元素的存入和输出的顺序是相同的。</p>
<h3 id="41、说一下-HashSet-的实现原理？"><a href="#41、说一下-HashSet-的实现原理？" class="headerlink" title="41、说一下 HashSet 的实现原理？"></a>41、说一下 HashSet 的实现原理？</h3><p>HashSet实际上是一个HashMap实例，数据存储结构都是数组+链表。</p>
<p>HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value都是一个统一的对象PRESENT。</p>
<p>private static final Object PRESENT &#x3D; new Object();<br>HashSet中add方法调用的是底层HashMap中的put方法，put方法要判断插入值是否存在，而HashSet的add方法，首先判断元素是否存在，如果存在则插入，如果不存在则不插入，这样就保证了HashSet中不存在重复值。</p>
<p> 通过对象的hashCode和equals方法保证对象的唯一性。</p>
<h3 id="42、ArrayList-和-LinkedList-的区别是什么？"><a href="#42、ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="42、ArrayList 和 LinkedList 的区别是什么？"></a>42、ArrayList 和 LinkedList 的区别是什么？</h3><p>ArrayList是动态数组的数据结构实现，查找和遍历的效率较高；</p>
<p>LinkedList 是双向链表的数据结构，增加和删除的效率较高；</p>
<h3 id="43、如何实现数组和-List-之间的转换？"><a href="#43、如何实现数组和-List-之间的转换？" class="headerlink" title="43、如何实现数组和 List 之间的转换？"></a>43、如何实现数组和 List 之间的转换？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;zs&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ww&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">list1.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">String[] arr1 = list1.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list1.size()]);</span><br><span class="line">System.out.println(arr1);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">    System.out.println(arr1[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44、在-Queue-中-poll-和-remove-有什么区别？"><a href="#44、在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="44、在 Queue 中 poll()和 remove()有什么区别？"></a>44、在 Queue 中 poll()和 remove()有什么区别？</h3><h4 id="（1）offer-和add-区别："><a href="#（1）offer-和add-区别：" class="headerlink" title="（1）offer()和add()区别："></a>（1）offer()和add()区别：</h4><p>增加新项时，如果队列满了，add会抛出异常，offer返回false。</p>
<h4 id="（2）poll-和remove-区别："><a href="#（2）poll-和remove-区别：" class="headerlink" title="（2）poll()和remove()区别："></a>（2）poll()和remove()区别：</h4><p>poll()和remove()都是从队列中删除第一个元素，remove抛出异常，poll返回null。</p>
<h4 id="（3）peek-和element（）区别："><a href="#（3）peek-和element（）区别：" class="headerlink" title="（3）peek()和element（）区别："></a>（3）peek()和element（）区别：</h4><p>peek()和element（）用于查询队列头部元素，为空时element抛出异常，peek返回null。</p>
<h3 id="45、哪些集合类是线程安全的"><a href="#45、哪些集合类是线程安全的" class="headerlink" title="45、哪些集合类是线程安全的"></a>45、哪些集合类是线程安全的</h3><p>Vector：就比Arraylist多了个同步化机制（线程安全）。</p>
<p>Stack：栈，也是线程安全的，继承于Vector。</p>
<p>Hashtable：就比Hashmap多了个线程安全。</p>
<p>ConcurrentHashMap:是一种高效但是线程安全的集合。</p>
<h3 id="46、迭代器-Iterator-是什么？"><a href="#46、迭代器-Iterator-是什么？" class="headerlink" title="46、迭代器 Iterator 是什么？"></a>46、迭代器 Iterator 是什么？</h3><p>为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator)。</p>
<h3 id="47、Iterator-怎么使用？有什么特点？"><a href="#47、Iterator-怎么使用？有什么特点？" class="headerlink" title="47、Iterator 怎么使用？有什么特点？"></a>47、Iterator 怎么使用？有什么特点？</h3><p>Iterator 接口源码中的方法：</p>
<ol>
<li><p>java.lang.Iterable 接口被 java.util.Collection 接口继承，java.util.Collection 接口的 iterator() 方法返回一个 Iterator 对象</p>
</li>
<li><p>next() 方法获得集合中的下一个元素</p>
</li>
<li><p>hasNext() 检查集合中是否还有元素</p>
</li>
<li><p>remove() 方法将迭代器新返回的元素删除</p>
</li>
</ol>
<h3 id="48、Iterator-和-ListIterator-有什么区别？"><a href="#48、Iterator-和-ListIterator-有什么区别？" class="headerlink" title="48、Iterator 和 ListIterator 有什么区别？"></a>48、Iterator 和 ListIterator 有什么区别？</h3><p>（1）ListIterator 继承 Iterator</p>
<p>（2）ListIterator 比 Iterator多方法</p>
<ol>
<li><p>add(E e)  将指定的元素插入列表，插入位置为迭代器当前位置之前</p>
</li>
<li><p>set(E e)  迭代器返回的最后一个元素替换参数e</p>
</li>
<li><p>hasPrevious()  迭代器当前位置，反向遍历集合是否含有元素</p>
</li>
<li><p>previous()  迭代器当前位置，反向遍历集合，下一个元素</p>
</li>
<li><p>previousIndex()  迭代器当前位置，反向遍历集合，返回下一个元素的下标</p>
</li>
<li><p>nextIndex()  迭代器当前位置，返回下一个元素的下标<br>（3）使用范围不同，Iterator可以迭代所有集合；ListIterator 只能用于List及其子类</p>
</li>
<li><p>ListIterator 有 add 方法，可以向 List 中添加对象；Iterator 不能</p>
</li>
<li><p>ListIterator 有 hasPrevious() 和 previous() 方法，可以实现逆向遍历；Iterator不可以</p>
</li>
<li><p>ListIterator 有 nextIndex() 和previousIndex() 方法，可定位当前索引的位置；Iterator不可以</p>
</li>
<li><p>ListIterator 有 set()方法，可以实现对 List 的修改；Iterator 仅能遍历，不能修改。</p>
</li>
</ol>
<h3 id="49、怎么确保一个集合不能被修改？"><a href="#49、怎么确保一个集合不能被修改？" class="headerlink" title="49、怎么确保一个集合不能被修改？"></a>49、怎么确保一个集合不能被修改？</h3><p>我们很容易想到用final关键字进行修饰，我们都知道</p>
<p>final关键字可以修饰类，方法，成员变量，final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的成员变量必须初始化值，如果这个成员变量是基本数据类型，表示这个变量的值是不可改变的，如果说这个成员变量是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的。</p>
<p>那么，我们怎么确保一个集合不能被修改？首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的。</p>
<p>我们可以做一个实验：</p>
<p>可以看到：我们用final关键字定义了一个map集合，这时候我们往集合里面传值，第一个键值对1,1；我们再修改后，可以把键为1的值改为100，说明我们是可以修改map集合的值的。</p>
<p>那我们应该怎么做才能确保集合不被修改呢？<br>我们可以采用Collections包下的unmodifiableMap方法，通过这个方法返回的map,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。</p>
<p>同理：Collections包也提供了对list和set集合的方法。</p>
<p>Collections.unmodifiableList(List)<br>Collections.unmodifiableSet(Set)<br><a href="https://imgtu.com/i/jkabQ0"><img src="https://s1.ax1x.com/2022/06/25/jkabQ0.md.jpg" alt="jkabQ0.md.jpg"></a></p>
<h3 id="50、队列和栈是什么？有什么区别？"><a href="#50、队列和栈是什么？有什么区别？" class="headerlink" title="50、队列和栈是什么？有什么区别？"></a>50、队列和栈是什么？有什么区别？</h3><p>（1）队列先进先出，栈先进后出。</p>
<p>（2）遍历数据速度不同。</p>
<p>栈只能从头部取数据 也就最先放入的需要遍历整个栈最后才能取出来，而且在遍历数据的时候还得为数据开辟临时空间，保持数据在遍历前的一致性；</p>
<p>队列则不同，他基于地址指针进行遍历，而且可以从头或尾部开始遍历，但不能同时遍历，无需开辟临时空间，因为在遍历的过程中不影像数据结构，速度要快的多。</p>
<h3 id="51、Java8开始ConcurrentHashMap-为什么舍弃分段锁？"><a href="#51、Java8开始ConcurrentHashMap-为什么舍弃分段锁？" class="headerlink" title="51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？"></a>51、Java8开始ConcurrentHashMap,为什么舍弃分段锁？</h3><p>ConcurrentHashMap的原理是引用了内部的 Segment ( ReentrantLock )  分段锁，保证在操作不同段 map 的时候， 可以并发执行， 操作同段 map 的时候，进行锁的竞争和等待。从而达到线程安全， 且效率大于 synchronized。</p>
<p>但是在 Java 8 之后， JDK 却弃用了这个策略，重新使用了 synchronized+CAS。</p>
<p>弃用原因</p>
<p>通过  JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p>
<p>加入多个分段锁浪费内存空间。<br>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。<br>为了提高 GC 的效率<br>新的同步方案</p>
<p>既然弃用了分段锁， 那么一定由新的线程安全方案， 我们来看看源码是怎么解决线程安全的呢？（源码保留了segment 代码， 但并没有使用）。</p>
<h3 id="52、ConcurrentHashMap-JDK1-8-为什么要使用synchronized而不是如ReentranLock这样的可重入锁？"><a href="#52、ConcurrentHashMap-JDK1-8-为什么要使用synchronized而不是如ReentranLock这样的可重入锁？" class="headerlink" title="52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？"></a>52、ConcurrentHashMap(JDK1.8)为什么要使用synchronized而不是如ReentranLock这样的可重入锁？</h3><p>我想从下面几个角度讨论这个问题：</p>
<p>（1）锁的粒度</p>
<p>首先锁的粒度并没有变粗，甚至变得更细了。每当扩容一次，ConcurrentHashMap的并发度就扩大一倍。</p>
<p>（2）Hash冲突</p>
<p>JDK1.7中，ConcurrentHashMap从过二次hash的方式（Segment -&gt; HashEntry）能够快速的找到查找的元素。在1.8中通过链表加红黑树的形式弥补了put、get时的性能差距。<br>JDK1.8中，在ConcurrentHashmap进行扩容时，其他线程可以通过检测数组中的节点决定是否对这条链表（红黑树）进行扩容，减小了扩容的粒度，提高了扩容的效率。</p>
<p>下面是我对面试中的那个问题的一下看法。</p>
<p>为什么是synchronized，而不是ReentranLock</p>
<p>（1）减少内存开销</p>
<p>假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p>
<p>（2）获得JVM的支持</p>
<p>可重入锁毕竟是API这个级别的，后续的性能优化空间很小。<br>synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。这就使得synchronized能够随着JDK版本的升级而不改动代码的前提下获得性能上的提升。</p>
<p>53、concurrentHashMap和HashTable有什么区别<br>concurrentHashMap融合了hashmap和hashtable的优势，hashmap是不同步的，但是单线程情况下效率高，hashtable是同步的同步情况下保证程序执行的正确性。</p>
<p>但hashtable每次同步执行的时候都要锁住整个结构，如下图：<br><a href="https://imgtu.com/i/jkdpWR"><img src="https://s1.ax1x.com/2022/06/25/jkdpWR.md.jpg" alt="jkdpWR.md.jpg"></a></p>
<p>concurrentHashMap锁的方式是细粒度的。concurrentHashMap将hash分为16个桶（默认值），诸如get、put、remove等常用操作只锁住当前需要用到的桶。</p>
<p>concurrentHashMap的读取并发，因为读取的大多数时候都没有锁定，所以读取操作几乎是完全的并发操作，只是在求size时才需要锁定整个hash。</p>
<p>而且在迭代时，concurrentHashMap使用了不同于传统集合的快速失败迭代器的另一种迭代方式，弱一致迭代器。在这种方式中，当iterator被创建后集合再发生改变就不会抛出ConcurrentModificationException，取而代之的是在改变时new新的数据而不是影响原来的数据，iterator完成后再讲头指针替代为新的数据，这样iterator时使用的是原来的数据。</p>
<h3 id="54、HashMap和HashSet的区别"><a href="#54、HashMap和HashSet的区别" class="headerlink" title="54、HashMap和HashSet的区别"></a>54、HashMap和HashSet的区别</h3><p>（1）先了解一下HashCode</p>
<p>Java中的集合有两类，一类是List，一类是Set。</p>
<p>List：元素有序，可以重复；</p>
<p>Set：元素无序，不可重复；</p>
<p>要想保证元素的不重复，拿什么来判断呢？这就是Object.equals方法了。如果元素有很多，增加一个元素，就要判断n次吗？</p>
<p>显然不现实，于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一根地址上，初学者可以简单的理解为，HashCode方法返回的就是对象存储的物理位置（实际上并不是）。</p>
<p>这样一来，当集合添加新的元素时，先调用这个元素的hashcode()方法，就一下子能定位到他应该放置的物理位置上。如果这个位置上没有元素，他就可以直接存储在这个位置上，不用再进行任何比较了。如果这个位置上有元素，就调用它的equals方法与新元素进行比较，想同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际上调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<p>简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率。</p>
<p>Java对象的equals方法和hashCode方法时这样规定的：</p>
<p>相等的对象就必须具有相等的hashcode。</p>
<p>如果两个对象的hashcode相同，他们并不一定相同。<br>如果两个对象的hashcode相同，他们并不一定相同。<br>如果两个Java对象A和B，A和B不相等，但是A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同，这时HashMap会在该位置建立一个链接表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用规则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法避免哈希冲突。</p>
<p>equals()相等的两个对象，hashcode()一定相等；equals()不相等的两个对象，却并不能证明他们的hashcode()不相等。</p>
<p>（2）HashMap和HashSet的区别</p>
<p><a href="https://imgtu.com/i/jVQ1ER"><img src="https://s1.ax1x.com/2022/06/27/jVQ1ER.jpg" alt="jVQ1ER.jpg"></a></p>
<h3 id="55、请谈谈-ReadWriteLock-和-StampedLock"><a href="#55、请谈谈-ReadWriteLock-和-StampedLock" class="headerlink" title="55、请谈谈 ReadWriteLock 和 StampedLock"></a>55、请谈谈 ReadWriteLock 和 StampedLock</h3><h4 id="ReadWriteLock包括两种子锁"><a href="#ReadWriteLock包括两种子锁" class="headerlink" title="ReadWriteLock包括两种子锁"></a>ReadWriteLock包括两种子锁</h4><p>（1）ReadWriteLock</p>
<p>ReadWriteLock 可以实现多个读锁同时进行，但是读与写和写于写互斥，只能有一个写锁线程在进行。</p>
<p>（2）StampedLock</p>
<p>StampedLock是Jdk在1.8提供的一种读写锁，相比较ReentrantReadWriteLock性能更好，因为ReentrantReadWriteLock在读写之间是互斥的，使用的是一种悲观策略，在读线程特别多的情况下，会造成写线程处于饥饿状态，虽然可以在初始化的时候设置为true指定为公平，但是吞吐量又下去了，而StampedLock是提供了一种乐观策略，更好的实现读写分离，并且吞吐量不会下降。</p>
<h4 id="StampedLock包括三种锁："><a href="#StampedLock包括三种锁：" class="headerlink" title="StampedLock包括三种锁："></a>StampedLock包括三种锁：</h4><p>（1）写锁writeLock：</p>
<p>writeLock是一个独占锁写锁，当一个线程获得该锁后，其他请求读锁或者写锁的线程阻塞， 获取成功后，会返回一个stamp（凭据）变量来表示该锁的版本，在释放锁时调用unlockWrite方法传递stamp参数。提供了非阻塞式获取锁tryWriteLock。</p>
<p>（2）悲观读锁readLock：</p>
<p>readLock是一个共享读锁，在没有线程获取写锁情况下，多个线程可以获取该锁。如果有写锁获取，那么其他线程请求读锁会被阻塞。悲观读锁会认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据进行加锁，这是在读少写多的情况下考虑的。请求该锁成功后会返回一个stamp值，在释放锁时调用unlockRead方法传递stamp参数。提供了非阻塞式获取锁方法tryWriteLock。</p>
<p>（3）乐观读锁tryOptimisticRead：</p>
<p>tryOptimisticRead相对比悲观读锁，在操作数据前并没有通过CAS设置锁的状态，如果没有线程获取写锁，则返回一个非0的stamp变量，获取该stamp后在操作数据前还需要调用validate方法来判断期间是否有线程获取了写锁，如果是返回值为0则有线程获取写锁，如果不是0则可以使用stamp变量的锁来操作数据。由于tryOptimisticRead并没有修改锁状态，所以不需要释放锁。这是读多写少的情况下考虑的，不涉及CAS操作，所以效率较高，在保证数据一致性上需要复制一份要操作的变量到方法栈中，并且在操作数据时可能其他写线程已经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性得到了保证。</p>
<h3 id="56、线程的run-和start-有什么区别？"><a href="#56、线程的run-和start-有什么区别？" class="headerlink" title="56、线程的run()和start()有什么区别？"></a>56、线程的run()和start()有什么区别？</h3><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<p>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p>
<h3 id="57、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#57、为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>57、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>这是另一个非常经典的 java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p>
<h3 id="58、Synchronized-用过吗，其原理是什么？"><a href="#58、Synchronized-用过吗，其原理是什么？" class="headerlink" title="58、Synchronized 用过吗，其原理是什么？"></a>58、Synchronized 用过吗，其原理是什么？</h3><p>（1）可重入性</p>
<p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁；</p>
<p>可重入的好处：<br>可以避免死锁；<br>可以让我们更好的封装代码；<br>synchronized是可重入锁，每部锁对象会有一个计数器记录线程获取几次锁，在执行完同步代码块时，计数器的数量会-1，直到计数器的数量为0，就释放这个锁。</p>
<p>（2）不可中断性</p>
<p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断；<br>synchronized 属于不可被中断；<br>Lock lock方法是不可中断的；<br>Lock tryLock方法是可中断的；</p>
<h3 id="59、JVM-对-Java-的原生锁做了哪些优化？"><a href="#59、JVM-对-Java-的原生锁做了哪些优化？" class="headerlink" title="59、JVM 对 Java 的原生锁做了哪些优化？"></a>59、JVM 对 Java 的原生锁做了哪些优化？</h3><p>（1）自旋锁</p>
<p>在线程进行阻塞的时候，先让线程自旋等待一段时间，可能这段时间其它线程已经解锁，这时就无需让线程再进行阻塞操作了。</p>
<p>自旋默认次数是10次。</p>
<p>（2）自适应自旋锁</p>
<p>自旋锁的升级，自旋的次数不再固定，由前一次自旋次数和锁的拥有者的状态决定。</p>
<p>（3）锁消除</p>
<p>在动态编译同步代码块的时候，JIT编译器借助逃逸分析技术来判断锁对象是否只被一个线程访问，而没有其他线程，这时就可以取消锁了。</p>
<p>4、锁粗化</p>
<p>当JIT编译器发现一系列的操作都对同一个对象反复加锁解锁，甚至加锁操作出现在循环中，此时会将加锁同步的范围粗化到整个操作系列的外部。</p>
<p>锁粒度：不要锁住一些无关的代码。</p>
<p>锁粗化：可以一次性执行完的不要多次加锁执行。</p>
<h3 id="60、为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#60、为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？"></a>60、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h3><p>Java中，任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。</p>
<p>wait(), notify()和 notifyAll()这些方法在同步代码块中调用</p>
<p>有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。</p>
<p>综上所述，wait()、notify()和notifyAll()方法要定义在Object类中。</p>
<h3 id="61、Java-如何实现多线程之间的通讯和协作？"><a href="#61、Java-如何实现多线程之间的通讯和协作？" class="headerlink" title="61、Java 如何实现多线程之间的通讯和协作？"></a>61、Java 如何实现多线程之间的通讯和协作？</h3><p>可以通过中断 和 共享变量的方式实现线程间的通讯和协作</p>
<p>比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p>
<p>Java中线程通信协作的最常见的两种方式：</p>
<p>1、syncrhoized加锁的线程的Object类的wait()&#x2F;notify()&#x2F;notifyAll()</p>
<p>2、ReentrantLock类加锁的线程的Condition类的await()&#x2F;signal()&#x2F;signalAll()</p>
<p>线程间直接的数据交换：</p>
<p>通过管道进行线程间通信：1）字节流；2）字符流</p>
<h3 id="62、Thread-类中的-yield-方法有什么作用？"><a href="#62、Thread-类中的-yield-方法有什么作用？" class="headerlink" title="62、Thread 类中的 yield 方法有什么作用？"></a>62、Thread 类中的 yield 方法有什么作用？</h3><p>yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</p>
<p>结论：yield()从未导致线程转到等待&#x2F;睡眠&#x2F;阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。</p>
<h3 id="63、为什么说-Synchronized-是非公平锁？"><a href="#63、为什么说-Synchronized-是非公平锁？" class="headerlink" title="63、为什么说 Synchronized 是非公平锁？"></a>63、为什么说 Synchronized 是非公平锁？</h3><p>当锁被释放后，任何一个线程都有机会竞争得到锁，这样做的目的是提高效率，但缺点是可能产生线程饥饿现象。</p>
<h3 id="64、请谈谈-volatile-有什么特点，为什么它能保证变量对所有线程的可见性？"><a href="#64、请谈谈-volatile-有什么特点，为什么它能保证变量对所有线程的可见性？" class="headerlink" title="64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？"></a>64、请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？</h3><p>volatile只能作用于变量，保证了操作可见性和有序性，不保证原子性。</p>
<p>在Java的内存模型中分为主内存和工作内存，Java内存模型规定所有的变量存储在主内存中，每条线程都有自己的工作内存。</p>
<p>主内存和工作内存之间的交互分为8个原子操作：</p>
<ol>
<li>lock</li>
<li>unlock</li>
<li>read</li>
<li>load</li>
<li>assign</li>
<li>use</li>
<li>store</li>
<li>write</li>
</ol>
<p>volatile修饰的变量，只有对volatile进行assign操作，才可以load，只有load才可以use，，这样就保证了在工作内存操作volatile变量，都会同步到主内存中。</p>
<h3 id="65、为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？"><a href="#65、为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？" class="headerlink" title="65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？"></a>65、为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？</h3><p>Synchronized的并发策略是悲观的，不管是否产生竞争，任何数据的操作都必须加锁。</p>
<p>乐观锁的核心是CAS，CAS包括内存值、预期值、新值，只有当内存值等于预期值时，才会将内存值修改为新值。</p>
<h3 id="66、乐观锁一定就是好的吗？"><a href="#66、乐观锁一定就是好的吗？" class="headerlink" title="66、乐观锁一定就是好的吗？"></a>66、乐观锁一定就是好的吗？</h3><p>乐观锁认为对一个对象的操作不会引发冲突，所以每次操作都不进行加锁，只是在最后提交更改时验证是否发生冲突，如果冲突则再试一遍，直至成功为止，这个尝试的过程称为自旋。</p>
<p>乐观锁没有加锁，但乐观锁引入了ABA问题，此时一般采用版本号进行控制；<br>也可能产生自旋次数过多问题，此时并不能提高效率，反而不如直接加锁的效率高；<br>只能保证一个对象的原子性，可以封装成对象，再进行CAS操作；</p>
<h3 id="67、请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。"><a href="#67、请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。" class="headerlink" title="67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。"></a>67、请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</h3><h4 id="（1）相似点"><a href="#（1）相似点" class="headerlink" title="（1）相似点"></a>（1）相似点</h4><p>它们都是阻塞式的同步，也就是说一个线程获得了对象锁，进入代码块，其它访问该同步块的线程都必须阻塞在同步代码块外面等待，而进行线程阻塞和唤醒的代码是比较高的。</p>
<h4 id="（2）功能区别"><a href="#（2）功能区别" class="headerlink" title="（2）功能区别"></a>（2）功能区别</h4><p>Synchronized是java语言的关键字，是原生语法层面的互斥，需要JVM实现；ReentrantLock 是JDK1.5之后提供的API层面的互斥锁，需要lock和unlock()方法配合try&#x2F;finally代码块来完成。<br>Synchronized使用较ReentrantLock 便利一些；<br>锁的细粒度和灵活性：ReentrantLock强于Synchronized；</p>
<h4 id="（3）性能区别"><a href="#（3）性能区别" class="headerlink" title="（3）性能区别"></a>（3）性能区别</h4><p>Synchronized引入偏向锁，自旋锁之后，两者的性能差不多，在这种情况下，官方建议使用Synchronized。</p>
<h4 id="①-Synchronized"><a href="#①-Synchronized" class="headerlink" title="① Synchronized"></a>① Synchronized</h4><p>Synchronized会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。</p>
<p>在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计数器+1，相应的执行monitorexit时，计数器-1，当计数器为0时，锁就会被释放。如果获取锁失败，当前线程就要阻塞，知道对象锁被另一个线程释放为止。</p>
<h4 id="②-ReentrantLock"><a href="#②-ReentrantLock" class="headerlink" title="② ReentrantLock"></a>② ReentrantLock</h4><p>ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有如下三项：</p>
<p>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized避免出现死锁的情况。通过lock.lockInterruptibly()来实现这一机制；<br>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁是非公平锁；ReentrantLock默认也是非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好；<br>锁绑定多个条件，一个ReentrantLock对象可以同时绑定多个对象。ReentrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像Synchronized要么随机唤醒一个线程，要么唤醒全部线程。</p>
<h3 id="68、ReentrantLock-是如何实现可重入性的？"><a href="#68、ReentrantLock-是如何实现可重入性的？" class="headerlink" title="68、ReentrantLock 是如何实现可重入性的？"></a>68、ReentrantLock 是如何实现可重入性的？</h3><h4 id="（1）什么是可重入性"><a href="#（1）什么是可重入性" class="headerlink" title="（1）什么是可重入性"></a>（1）什么是可重入性</h4><p>一个线程持有锁时，当其他线程尝试获取该锁时，会被阻塞；而这个线程尝试获取自己持有锁时，如果成功说明该锁是可重入的，反之则不可重入。</p>
<h4 id="（2）synchronized是如何实现可重入性"><a href="#（2）synchronized是如何实现可重入性" class="headerlink" title="（2）synchronized是如何实现可重入性"></a>（2）synchronized是如何实现可重入性</h4><p>synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令。每个锁对象内部维护一个计数器，该计数器初始值为0，表示任何线程都可以获取该锁并执行相应的方法。根据虚拟机规范要求，在执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没有被锁定，或者当前线程已经拥有了对象的锁，把锁的计数器+1，相应的在执行monitorexit指令后锁计数器-1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p>
<h4 id="（3）ReentrantLock如何实现可重入性"><a href="#（3）ReentrantLock如何实现可重入性" class="headerlink" title="（3）ReentrantLock如何实现可重入性"></a>（3）ReentrantLock如何实现可重入性</h4><p>ReentrantLock使用内部类Sync来管理锁，所以真正的获取锁是由Sync的实现类控制的。Sync有两个实现，分别为NonfairSync（非公公平锁）和FairSync（公平锁）。Sync通过继承AQS实现，在AQS中维护了一个private volatile int state来计算重入次数，避免频繁的持有释放操作带来的线程问题。</p>
<h4 id="（4）ReentrantLock代码实例"><a href="#（4）ReentrantLock代码实例" class="headerlink" title="（4）ReentrantLock代码实例"></a>（4）ReentrantLock代码实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync继承于AQS</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock默认是非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 可以通过向构造方法中传true来实现公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前想要获取锁的线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 当前锁的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">            <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">                <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">                <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">    <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>

<h4 id="（5）代码分析"><a href="#（5）代码分析" class="headerlink" title="（5）代码分析"></a>（5）代码分析</h4><p>当一个线程在获取锁过程中，先判断state的值是否为0，如果是表示没有线程持有锁，就可以尝试获取锁。<br>当state的值不为0时，表示锁已经被一个线程占用了，这时会做一个判断current&#x3D;&#x3D;getExclusiveOwnerThread()，这个方法返回的是当前持有锁的线程，这个判断是看当前持有锁的线程是不是自己，如果是自己，那么将state的值+1，表示重入返回即可。</p>
<h3 id="69、什么是锁消除和锁粗化？"><a href="#69、什么是锁消除和锁粗化？" class="headerlink" title="69、什么是锁消除和锁粗化？"></a>69、什么是锁消除和锁粗化？</h3><h4 id="（1）锁消除"><a href="#（1）锁消除" class="headerlink" title="（1）锁消除"></a>（1）锁消除</h4><p>所消除就是虚拟机根据一个对象是否真正存在同步情况，若不存在同步情况，则对该对象的访问无需经过加锁解锁的操作。</p>
<p>比如StringBuffer的append方法，因为append方法需要判断对象是否被占用，而如果代码不存在锁竞争，那么这部分的性能消耗是无意义的。于是虚拟机在即时编译的时候就会将上面的代码进行优化，也就是锁消除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，append方法用了 synchronized关键字，它是线程安全的。但我们可能仅在线程内部把StringBuffer当做局部变量使用；StringBuffer仅在方法内作用域有效，不存在线程安全的问题，这时我们可以通过编译器将其优化，将锁消除，前提是Java必须运行在server模式，同时必须开启逃逸分析；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-server -XX:+DoEscapeAnalysis -XX:+EliminateLocks</span><br><span class="line"></span><br><span class="line">其中+DoEscapeAnalysis表示开启逃逸分析，+EliminateLocks表示锁消除。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sBuf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sBuf.append(str1);<span class="comment">// append方法是同步操作</span></span><br><span class="line">    sBuf.append(str2);</span><br><span class="line">    <span class="keyword">return</span> sBuf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>逃逸分析：比如上面的代码，它要看sBuf是否可能逃出它的作用域？如果将sBuf作为方法的返回值进行返回，那么它在方法外部可能被当作一个全局对象使用，就有可能发生线程安全问题，这时就可以说sBuf这个对象发生逃逸了，因而不应将append操作的锁消除，但我们上面的代码没有发生锁逃逸，锁消除就可以带来一定的性能提升。 </p>
<h4 id="（2）锁粗化"><a href="#（2）锁粗化" class="headerlink" title="（2）锁粗化"></a>（2）锁粗化</h4><p>锁的请求、同步、释放都会消耗一定的系统资源，如果高频的锁请求反而不利于系统性能的优化，锁粗化就是把多次的锁请求合并成一个请求，扩大锁的范围，降低锁请求、同步、释放带来的性能损耗。</p>
<h3 id="70、跟-Synchronized-相比，可重入锁-ReentrantLock-其实现原理有什么不同？"><a href="#70、跟-Synchronized-相比，可重入锁-ReentrantLock-其实现原理有什么不同？" class="headerlink" title="70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？"></a>70、跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？</h3><p>1、都是可重入锁；</p>
<p>2、ReentrantLock内部是实现了Sync，Sync继承于AQS抽象类。Sync有两个实现，一个是公平锁，一个是非公平锁，通过构造函数定义。AQS中维护了一个state来计算重入次数，避免频繁的持有释放操作带来的线程问题。</p>
<p>3、ReentrantLock只能定义代码块，而Synchronized可以定义方法和代码块；</p>
<p>4、Synchronized是JVM的一个内部关键字，ReentrantLock是JDK1.5之后引入的一个API层面的互斥锁；</p>
<p>5、Synchronized实现自动的加锁、释放锁，ReentrantLock需要手动加锁和释放锁，中间可以暂停；</p>
<p>6、Synchronized由于引进了偏向锁和自旋锁，所以性能上和ReentrantLock差不多，但操作上方便很多，所以优先使用Synchronized。</p>
<h3 id="71、那么请谈谈-AQS-框架是怎么回事儿？"><a href="#71、那么请谈谈-AQS-框架是怎么回事儿？" class="headerlink" title="71、那么请谈谈 AQS 框架是怎么回事儿？"></a>71、那么请谈谈 AQS 框架是怎么回事儿？</h3><p>（1）AQS是AbstractQueuedSynchronizer的缩写，它提供了一个FIFO队列，可以看成是一个实现同步锁的核心组件。</p>
<p>AQS是一个抽象类，主要通过继承的方式来使用，它本身没有实现任何的同步接口，仅仅是定义了同步状态的获取和释放的方法来提供自定义的同步组件。</p>
<p>（2）AQS的两种功能：独占锁和共享锁</p>
<p>（3）AQS的内部实现</p>
<p>AQS的实现依赖内部的同步队列，也就是FIFO的双向队列，如果当前线程竞争失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点（线程）。</p>
<p><a href="https://imgtu.com/i/jV6pBd"><img src="https://s1.ax1x.com/2022/06/27/jV6pBd.jpg" alt="jV6pBd.jpg"></a></p>
<p>AQS队列内部维护的是一个FIFO的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向直接的后继节点和直接前驱节点。所以双向链表可以从任意一个节点开始很方便的范文前驱和后继节点。每个Node其实是由线程封装，当线程争抢锁失败后会封装成Node加入到AQS队列中。</p>
<h3 id="72、AQS-对资源的共享方式？"><a href="#72、AQS-对资源的共享方式？" class="headerlink" title="72、AQS 对资源的共享方式？"></a>72、AQS 对资源的共享方式？</h3><p>AQS定义两种资源共享方式</p>
<p>（1）Exclusive（独占）</p>
<p>只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：</p>
<p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁<br>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的<br>（2）Share（共享）</p>
<p>多个线程可同时执行，如Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p>
<p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。</p>
<h3 id="73、如何让-Java-的线程彼此同步？"><a href="#73、如何让-Java-的线程彼此同步？" class="headerlink" title="73、如何让 Java 的线程彼此同步？"></a>73、如何让 Java 的线程彼此同步？</h3><p>synchronized<br>volatile<br>ReenreantLock<br>使用局部变量实现线程同步</p>
<h3 id="74、你了解过哪些同步器？请分别介绍下。"><a href="#74、你了解过哪些同步器？请分别介绍下。" class="headerlink" title="74、你了解过哪些同步器？请分别介绍下。"></a>74、你了解过哪些同步器？请分别介绍下。</h3><p>（1）Semaphore同步器</p>
<p>特征：</p>
<p>经典的信号量，通过计数器控制对共享资源的访问<br>Semaphore(int count):创建拥有count个许可证的信号量<br>acquire()&#x2F;acquire(int num) : 获取1&#x2F;num个许可证<br>release&#x2F;release(int num) : 释放1&#x2F;num个许可证</p>
<p>（2）CountDownLatch同步器</p>
<p>特征：</p>
<p>必须发生指定数量的事件后才可以继续运行(比如赛跑比赛，裁判喊出3,2,1之后大家才同时跑)<br>CountDownLatch(int count):必须发生count个数量才可以打开锁存器<br>await:等待锁存器<br>countDown:触发事件</p>
<p>（3）CyclicBarrier同步器</p>
<p>特征：</p>
<p>适用于只有多个线程都到达预定点时才可以继续执行(比如斗地主，需要等齐三个人才开始)<br>CyclicBarrier(int num) :等待线程的数量<br>CyclicBarrier(int num, Runnable action) :等待线程的数量以及所有线程到达后的操作<br>await() : 到达临界点后暂停线程</p>
<p>（4）交换器(Exchanger)同步器</p>
<p>（5）Phaser同步器</p>
<h3 id="75、Java-中的线程池是如何实现的"><a href="#75、Java-中的线程池是如何实现的" class="headerlink" title="75、Java 中的线程池是如何实现的"></a>75、Java 中的线程池是如何实现的</h3><p>创建一个阻塞队列来容纳任务，在第一次执行任务时创建足够多的线程，并处理任务，之后每个工作线程自动从任务队列中获取线程，直到任务队列中任务为0为止，此时线程处于等待状态，一旦有工作任务加入任务队列中，即刻唤醒工作线程进行处理，实现线程的可复用性。</p>
<p>线程池一般包括四个基本组成部分：</p>
<p>（1）线程池管理器</p>
<p>用于创建线程池，销毁线程池，添加新任务。</p>
<p>（2）工作线程</p>
<p>线程池中线程，可循环执行任务，在没有任务时处于等待状态。</p>
<p>（3）任务队列</p>
<p>用于存放没有处理的任务，一种缓存机制。</p>
<p>（4）任务接口</p>
<p>每个任务必须实现的接口，供工作线程调度任务的执行，主要规定了任务的开始和收尾工作，和任务的状态。</p>
<h3 id="76、创建线程池的几个核心构造参数"><a href="#76、创建线程池的几个核心构造参数" class="headerlink" title="76、创建线程池的几个核心构造参数"></a>76、创建线程池的几个核心构造参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java线程池的完整构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">int</span> corePoolSize, // 线程池长期维持的最小线程数，即使线程处于Idle状态，也不会回收。</span></span><br><span class="line"><span class="params">  <span class="type">int</span> maximumPoolSize, // 线程数的上限</span></span><br><span class="line"><span class="params">  <span class="type">long</span> keepAliveTime, // 线程最大生命周期。</span></span><br><span class="line"><span class="params">  TimeUnit unit, //时间单位                                 </span></span><br><span class="line"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue, //任务队列。当线程池中的线程都处于运行状态，而此时任务数量继续增加，则需要一个容器来容纳这些任务，这就是任务队列。</span></span><br><span class="line"><span class="params">  ThreadFactory threadFactory, // 线程工厂。定义如何启动一个线程，可以设置线程名称，并且可以确认是否是后台线程等。</span></span><br><span class="line"><span class="params">  RejectedExecutionHandler handler // 拒绝任务处理器。由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<h3 id="77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？"><a href="#77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？" class="headerlink" title="77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？"></a>77、线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？</h3><p>线程池中的线程是在第一次提交任务submit时创建的</p>
<p>创建线程的方式有继承Thread和实现Runnable，重写run方法，start开始执行，wait等待，sleep休眠，shutdown停止。</p>
<p>（1）newSingleThreadExecutor：单线程池。</p>
<p>顾名思义就是一个池中只有一个线程在运行，该线程永不超时，而且由于是一个线程，当有多个任务需要处理时，会将它们放置到一个无界阻塞队列中逐个处理，它的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的使用方法也很简单，下面是简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建单线程执行器</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="comment">// 执行一个任务</span></span><br><span class="line">    Future&lt;String&gt; future = es.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 获得任务执行后的返回值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;返回值：&quot;</span> + future.get());</span><br><span class="line">    <span class="comment">// 关闭执行器</span></span><br><span class="line">    es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>（2）newCachedThreadPool：缓冲功能的线程。</p>
<p>建立了一个线程池，而且线程数量是没有限制的(当然，不能超过Integer的最大值)，新增一个任务即有一个线程处理，或者复用之前空闲的线程，或者重亲启动一个线程，但是一旦一个线程在60秒内一直处于等待状态时（也就是一分钟无事可做），则会被终止，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里需要说明的是，任务队列使用了同步阻塞队列，这意味着向队列中加入一个元素，即可唤醒一个线程(新创建的线程或复用空闲线程来处理)，这种队列已经没有队列深度的概念了。</p>
<p>（3）newFixedThreadPool：固定线程数量的线程池。</p>
<p>在初始化时已经决定了线程的最大数量，若任务添加的能力超出了线程的处理能力，则建立阻塞队列容纳多余的任务，其源码如下：　</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面返回的是一个ThreadPoolExecutor，它的corePoolSize和maximumPoolSize是相等的，也就是说，最大线程数量为nThreads。如果任务增长的速度非常快，超过了LinkedBlockingQuene的最大容量(Integer的最大值)，那此时会如何处理呢？会按照ThreadPoolExecutor默认的拒绝策略(默认是DiscardPolicy，直接丢弃)来处理。</p>
<p>以上三种线程池执行器都是ThreadPoolExecutor的简化版，目的是帮助开发人员屏蔽过得线程细节，简化多线程开发。当需要运行异步任务时，可以直接通过Executors获得一个线程池，然后运行任务，不需要关注ThreadPoolExecutor的一系列参数时什么含义。当然，有时候这三个线程不能满足要求，此时则可以直接操作ThreadPoolExecutor来实现复杂的多线程计算。</p>
<p>newSingleThreadExecutor、newCachedThreadPool、newFixedThreadPool是线程池的简化版，而ThreadPoolExecutor则是旗舰版___简化版容易操作，需要了解的知识相对少些，方便使用，而旗舰版功能齐全，适用面广，难以驾驭。</p>
<h3 id="78、volatile-关键字的作用"><a href="#78、volatile-关键字的作用" class="headerlink" title="78、volatile 关键字的作用"></a>78、volatile 关键字的作用</h3><p>对于可见性，Java 提供了 volatile 关键字来保证可见性和禁止指令重排。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>从实践角度而言，volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参见 java.util.concurrent.atomic 包下的类，比如 AtomicInteger。</p>
<p>volatile 常用于多线程环境下的单次操作(单次读或者单次写)。</p>
<h3 id="79、既然-volatile-能够保证线程间的变量可见性，是不是就意味着基于-volatile-变量的运算就是并发安全的？"><a href="#79、既然-volatile-能够保证线程间的变量可见性，是不是就意味着基于-volatile-变量的运算就是并发安全的？" class="headerlink" title="79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？"></a>79、既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？</h3><p>volatile修饰的变量在各个线程的工作内存中不存在一致性的问题（在各个线程工作的内存中，volatile修饰的变量也会存在不一致的情况，但是由于每次使用之前都会先刷新主存中的数据到工作内存，执行引擎看不到不一致的情况，因此可以认为不存在不一致的问题），但是java的运算并非原子性的操作，导致volatile在并发下并非是线程安全的。</p>
<h3 id="80、ThreadLocal-是什么？有哪些使用场景？"><a href="#80、ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="80、ThreadLocal 是什么？有哪些使用场景？"></a>80、ThreadLocal 是什么？有哪些使用场景？</h3><p>ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象，简单说 ThreadLocal 就是一种以空间换时间的做法，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，避免资源在多线程间共享。</p>
<p>原理：线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>
<p>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。</p>
<h3 id="81、请谈谈-ThreadLocal-是怎么解决并发安全的？"><a href="#81、请谈谈-ThreadLocal-是怎么解决并发安全的？" class="headerlink" title="81、请谈谈 ThreadLocal 是怎么解决并发安全的？"></a>81、请谈谈 ThreadLocal 是怎么解决并发安全的？</h3><p>在java程序中，常用的有两种机制来解决多线程并发问题，一种是sychronized方式，通过锁机制，一个线程执行时，让另一个线程等待，是以时间换空间的方式来让多线程串行执行。而另外一种方式就是ThreadLocal方式，通过创建线程局部变量，以空间换时间的方式来让多线程并行执行。两种方式各有优劣，适用于不同的场景，要根据不同的业务场景来进行选择。</p>
<p>在spring的源码中，就使用了ThreadLocal来管理连接，在很多开源项目中，都经常使用ThreadLocal来控制多线程并发问题，因为它足够的简单，我们不需要关心是否有线程安全问题，因为变量是每个线程所特有的。</p>
<h3 id="82、很多人都说要慎用-ThreadLocal，谈谈你的理解，使用-ThreadLocal-需要注意些什么？"><a href="#82、很多人都说要慎用-ThreadLocal，谈谈你的理解，使用-ThreadLocal-需要注意些什么？" class="headerlink" title="82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？"></a>82、很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？</h3><p>ThreadLocal 变量解决了多线程环境下单个线程中变量的共享问题，使用名为ThreadLocalMap的哈希表进行维护（key为ThreadLocal变量名，value为ThreadLocal变量的值）；</p>
<p>使用时需要注意以下几点：</p>
<ul>
<li>线程之间的threadLocal变量是互不影响的，</li>
<li>使用private final static进行修饰，防止多实例时内存的泄露问题</li>
<li>线程池环境下使用后将threadLocal变量remove掉或设置成一个初始值</li>
</ul>
<h3 id="83、为什么代码会重排序？"><a href="#83、为什么代码会重排序？" class="headerlink" title="83、为什么代码会重排序？"></a>83、为什么代码会重排序？</h3><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>
<ul>
<li>在单线程环境下不能改变程序运行的结果；</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
<p>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p>
<h3 id="84、什么是自旋"><a href="#84、什么是自旋" class="headerlink" title="84、什么是自旋"></a>84、什么是自旋</h3><p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>
<h3 id="85、多线程中-synchronized-锁升级的原理是什么？"><a href="#85、多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="85、多线程中 synchronized 锁升级的原理是什么？"></a>85、多线程中 synchronized 锁升级的原理是什么？</h3><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h3 id="86、synchronized-和-ReentrantLock-区别是什么？"><a href="#86、synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="86、synchronized 和 ReentrantLock 区别是什么？"></a>86、synchronized 和 ReentrantLock 区别是什么？</h3><p>synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量</p>
<p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p>
<p>相同点：两者都是可重入锁</p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p>主要区别如下：</p>
<ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</li>
<li>二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法</li>
<li>加锁，synchronized 操作的应该是对象头中 mark word</li>
</ul>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的class对象</li>
<li>同步方法块，锁是括号里面的对象</li>
</ul>
<h3 id="87、Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#87、Java-Concurrency-API-中的-Lock-接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？"></a>87、Java Concurrency API 中的 Lock 接口(Lock interface)是什么？对比同步它有什么优势？</h3><p>Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p>
<p>它的优势有：</p>
<p>（1）可以使锁更公平</p>
<p>（2）可以使线程在等待锁的时候响应中断</p>
<p>（3）可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>（4）可以在不同的范围，以不同的顺序获取和释放锁</p>
<p>整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的(tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p>
<h3 id="88、jsp-和-servlet-有什么区别？"><a href="#88、jsp-和-servlet-有什么区别？" class="headerlink" title="88、jsp 和 servlet 有什么区别？"></a>88、jsp 和 servlet 有什么区别？</h3><p>（1）servlet是服务器端的Java程序，它担当客户端和服务端的中间层。</p>
<p>（2）jsp全名为Java server pages，中文名叫Java服务器页面，其本质是一个简化的servlet设计。JSP是一种动态页面设计，它的主要目的是将表示逻辑从servlet中分离出来。</p>
<p>（3）JVM只能识别Java代码，不能识别JSP，JSP编译后变成了servlet，web容器将JSP的代码编译成JVM能够识别的Java类（servlet）。</p>
<p>（4）JSP有内置对象、servlet没有内置对象。</p>
<h3 id="89、jsp-有哪些内置对象？作用分别是什么？"><a href="#89、jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="89、jsp 有哪些内置对象？作用分别是什么？"></a>89、jsp 有哪些内置对象？作用分别是什么？</h3><p>JSP九大内置对象：</p>
<ol>
<li>pageContext，页面上下文对象，相当于页面中所有功能的集合，通过它可以获取JSP页面的out、request、response、session、application对象。</li>
<li>request</li>
<li>response</li>
<li>session</li>
<li>application，应用程序对象，application实现了用户间数据的共享，可存放全局变量，它开始于服务器启动，知道服务器关闭。</li>
<li>page，就是JSP本身。</li>
<li>exception</li>
<li>out，out用于在web浏览器内输出信息，并且管理应用服务器上的输出缓冲区，作用域page。</li>
<li>config，取得服务器的配置信息。</li>
</ol>
<h3 id="90、forward-和-redirect-的区别？"><a href="#90、forward-和-redirect-的区别？" class="headerlink" title="90、forward 和 redirect 的区别？"></a>90、forward 和 redirect 的区别？</h3><ol>
<li>forward是直接请求转发；redirect是间接请求转发，又叫重定向。</li>
<li>forward，客户端和浏览器执行一次请求；redirect，客户端和浏览器执行两次请求。</li>
<li>forward，经典的MVC模式就是forward；redirect，用于避免用户的非正常访问。（例如用户非正常访问，servlet就可以将HTTP请求重定向到登录页面）。</li>
<li>forward，地址不变；redirect，地址改变。</li>
<li>forward常用方法：RequestDispatcher类的forward()方法；redirect常用方法：HttpServletRequest类的sendRedirect()方法。</li>
</ol>
<h3 id="91、说一下-jsp-的-4-种作用域？"><a href="#91、说一下-jsp-的-4-种作用域？" class="headerlink" title="91、说一下 jsp 的 4 种作用域？"></a>91、说一下 jsp 的 4 种作用域？</h3><p>application、session、request、page</p>
<h3 id="92、session-和-cookie-有什么区别？"><a href="#92、session-和-cookie-有什么区别？" class="headerlink" title="92、session 和 cookie 有什么区别？"></a>92、session 和 cookie 有什么区别？</h3><p>（1）存储位置不同</p>
<ul>
<li>cookie在客户端浏览器；</li>
<li>session在服务器；</li>
</ul>
<p>（2）存储容量不同</p>
<ul>
<li>cookie&lt;&#x3D;4K，一个站点最多保留20个cookie；</li>
<li>session没有上线，出于对服务器的保护，session内不可存过多东西，并且要设置session删除机制；</li>
</ul>
<p>（3）存储方式不同</p>
<ul>
<li>cookie只能保存ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据；</li>
<li>session中能存储任何类型的数据，包括并不局限于String、integer、list、map等；</li>
</ul>
<p>（4）隐私策略不同</p>
<ul>
<li>cookie对客户端是可见的，不安全；</li>
<li>session存储在服务器上，安全；</li>
</ul>
<p>（5）有效期不同</p>
<ul>
<li>开发可以通过设置cookie的属性，达到使cookie长期有效的效果；</li>
<li>session依赖于名为JESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session达不到长期有效的效果；</li>
</ul>
<p>（6）跨域支持上不同</p>
<ul>
<li>cookie支持跨域；</li>
<li>session不支持跨域；</li>
</ul>
<h3 id="93、如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#93、如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="93、如果客户端禁止 cookie 能实现 session 还能用吗？"></a>93、如果客户端禁止 cookie 能实现 session 还能用吗？</h3><p>一般默认情况下，在会话中，服务器存储 session 的 sessionid 是通过 cookie 存到浏览器里。</p>
<p>如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，session失效。</p>
<p>但是可以通过其他方法在禁用 cookie 的情况下，可以继续使用session：</p>
<ol>
<li>通过url重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中携带 sessionid 参数。</li>
<li>服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。</li>
<li>通过 Http 协议其他 header 字段，服务器每次返回时设置该 header 字段信息，浏览器中 js 读取该 header 字段，请求服务器时，js设置携带该 header 字段。</li>
</ol>
<h3 id="94、什么是上下文切换？"><a href="#94、什么是上下文切换？" class="headerlink" title="94、什么是上下文切换？"></a>94、什么是上下文切换？</h3><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h3 id="95、cookie、session、token"><a href="#95、cookie、session、token" class="headerlink" title="95、cookie、session、token"></a>95、cookie、session、token</h3><p>1、session机制</p>
<p><a href="https://imgtu.com/i/jVoY7T"><img src="https://s1.ax1x.com/2022/06/27/jVoY7T.jpg" alt="jVoY7T.jpg"></a></p>
<p>session是服务端存储的一个对象，主要用来存储所有访问过该服务端的客户端的用户信息（也可以存储其他信息），从而实现保持用户会话状态。但是服务器重启时，内存会被销毁，存储的用户信息也就消失了。</p>
<p>不同的用户访问服务端的时候会在session对象中存储键值对，“键”用来存储开启这个用户信息的“钥匙”，在登录成功后，“钥匙”通过cookie返回给客户端，客户端存储为sessionId记录在cookie中。当客户端再次访问时，会默认携带cookie中的sessionId来实现会话机制。</p>
<p>（1）session是基于cookie的。</p>
<ul>
<li>cookie的数据4k左右；</li>
<li>cookie存储数据的格式：字符串key&#x3D;value</li>
<li>cookie存储有效期：可以自行通过expires进行具体的日期设置，如果没设置，默认是关闭浏览器时失效。</li>
<li>cookie有效范围：当前域名下有效。所以session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上（前后端项目协议、域名、端口号都一致，即在一个项目下）</li>
</ul>
<p>（2）session持久化</p>
<p>用于解决重启服务器后session消失的问题。在数据库中存储session，而不是存储在内存中。通过包：express-mysql-session。</p>
<p>当客户端存储的cookie失效后，服务端的session不会立即销毁，会有一个延时，服务端会定期清理无效session，不会造成无效数据占用存储空间的问题。</p>
<p>2、token机制</p>
<p><a href="https://imgtu.com/i/jVITkF"><img src="https://s1.ax1x.com/2022/06/27/jVITkF.jpg" alt="jVITkF.jpg"></a></p>
<p>适用于前后端分离的项目（前后端代码运行在不同的服务器下）</p>
<p>请求登录时，token和sessionid原理相同，是对key和key对应的用户信息进行加密后的加密字符，登录成功后，会在响应主体中将{token：“字符串”}返回给客户端。</p>
<p>客户端通过cookie都可以进行存储。再次请求时不会默认携带，需要在请求拦截器位置给请求头中添加认证字段Authorization携带token信息，服务器就可以通过token信息查找用户登录状态。</p>
<h3 id="96、说一下-session-的工作原理？"><a href="#96、说一下-session-的工作原理？" class="headerlink" title="96、说一下 session 的工作原理？"></a>96、说一下 session 的工作原理？</h3><p>当客户端登录完成后，会在服务端产生一个session，此时服务端会将sessionid返回给客户端浏览器。客户端将sessionid储存在浏览器的cookie中，当用户再次登录时，会获得对应的sessionid，然后将sessionid发送到服务端请求登录，服务端在内存中找到对应的sessionid，完成登录，如果找不到，返回登录页面。</p>
<h3 id="97、http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#97、http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="97、http 响应码 301 和 302 代表的是什么？有什么区别？"></a>97、http 响应码 301 和 302 代表的是什么？有什么区别？</h3><ol>
<li>301和302状态码都表示重定向，当浏览器拿到服务器返回的这个状态码后悔自动跳转到一个新的URL地址。</li>
<li>301代表永久性重定向，旧地址被永久移除，客户端向新地址发送请求。</li>
<li>302代表暂时性重定向，旧地址还在，客户端继续向旧地址发送请求。</li>
<li>303代表暂时性重定向，重定向到新地址时，必须使用GET方法请求新地址。</li>
<li>307代表暂时性重定向，与302的区别在于307不允许从POST改为GET。</li>
<li>307代表永久性重定向，与301的区别在于308不允许从POST改为GET。</li>
</ol>
<h3 id="98、简述-tcp-和-udp的区别？"><a href="#98、简述-tcp-和-udp的区别？" class="headerlink" title="98、简述 tcp 和 udp的区别？"></a>98、简述 tcp 和 udp的区别？</h3><ol>
<li>TCP是传输控制协议，UDP是用户数据表协议；</li>
<li>TCP长连接，UDP无连接；</li>
<li>UDP程序结构较简单，只需发送，无须接收；</li>
<li>TCP可靠，保证数据正确性、顺序性；UDP不可靠，可能丢数据；</li>
<li>TCP适用于少量数据，UDP适用于大量数据传输；</li>
<li>TCP速度慢，UDP速度快；</li>
</ol>
<h3 id="99、tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#99、tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="99、tcp 为什么要三次握手，两次不行吗？为什么？"></a>99、tcp 为什么要三次握手，两次不行吗？为什么？</h3><p>因为客户端和服务端都要确认连接，①客户端请求连接服务端；②针对客户端的请求确认应答，并请求建立连接；③针对服务端的请求确认应答，建立连接；</p>
<p>两次无法确保A能收到B的数据；</p>
<h3 id="100、OSI-的七层模型都有哪些？"><a href="#100、OSI-的七层模型都有哪些？" class="headerlink" title="100、OSI 的七层模型都有哪些？"></a>100、OSI 的七层模型都有哪些？</h3><p><a href="https://imgtu.com/i/jVo5jI"><img src="https://s1.ax1x.com/2022/06/27/jVo5jI.jpg" alt="jVo5jI.jpg"></a></p>
<h3 id="101、get-和-post-请求有哪些区别？"><a href="#101、get-和-post-请求有哪些区别？" class="headerlink" title="101、get 和 post 请求有哪些区别？"></a>101、get 和 post 请求有哪些区别？</h3><ol>
<li>get请求参数是连接在url后面的,而post请求参数是存放在requestbody内的；</li>
<li>get请求因为浏览器对url长度有限制，所以参数个数有限制，而post请求参数个数没有限制；</li>
<li>因为get请求参数暴露在url上,所以安全方面post比get更加安全；</li>
<li>get请求只能进行url编码,而post请求可以支持多种编码方式；</li>
<li>get请求参数会保存在浏览器历史记录内,post请求并不会；</li>
<li>get请求浏览器会主动cache,post并不会,除非主动设置；</li>
<li>get请求产生1个tcp数据包,post请求产生2个tcp数据包；</li>
<li>在浏览器进行回退操作时,get请求是无害的,而post请求则会重新请求一次；</li>
<li>浏览器在发送get请求时会将header和data一起发送给服务器,服务器返回200状态码,而在发送post请求时,会先将header发送给服务器,服务器返回100,之后再将data发送给服务器,服务器返回200 OK；</li>
</ol>
<h3 id="102、什么是-XSS-攻击，如何避免？"><a href="#102、什么是-XSS-攻击，如何避免？" class="headerlink" title="102、什么是 XSS 攻击，如何避免？"></a>102、什么是 XSS 攻击，如何避免？</h3><p>xss(Cross Site Scripting)，即跨站脚本攻击，是一种常见于web应用程序中的计算机安全漏洞。指的是在用户浏览器上，在渲染DOM树的时候，执行了不可预期的JS脚本，从而发生了安全问题。</p>
<p>XSS就是通过在用户端注入恶意的可运行脚本，若服务端对用户的输入不进行处理，直接将用户的输入输出到浏览器，然后浏览器将会执行用户注入的脚本。 所以XSS攻击的核心就是浏览器渲染DOM的时候将文本信息解析成JS脚本从而引发JS脚本注入，那么XSS攻击的防御手段就是基于浏览器渲染这一步去做防御。只要我们使用HTML编码将浏览器需要渲染的信息编码后，浏览器在渲染DOM元素的时候，会自动解码需要渲染的信息，将上述信息解析成字符串而不是JS脚本，这就是我们防御XSS攻击的核心想法。</p>
<p>预防：</p>
<p>1、获取用户的输入，不用innerHtml,用innerText.<br>2、对用户的输入进行过滤，如对&amp; &lt; &gt; “ ‘ &#x2F;等进行转义；</p>
<h3 id="103、什么是-CSRF-攻击，如何避免？"><a href="#103、什么是-CSRF-攻击，如何避免？" class="headerlink" title="103、什么是 CSRF 攻击，如何避免？"></a>103、什么是 CSRF 攻击，如何避免？</h3><p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<p>1、攻击细节</p>
<p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
<p>例子</p>
<p>假如一家银行用以运行转账操作的URL地址如下：<a href="http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</a></p>
<p>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman"></p>
<p>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。</p>
<p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成信息的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p>
<p>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义运行操作。</p>
<p>2、防御措施</p>
<p>检查Referer字段</p>
<p>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于<a href="http://www.examplebank.com之下.而如果是csrf攻击传来的请求,referer字段会是包含恶意网址的地址,不会位于www.examplebank.com之下,这时候服务器就能识别出恶意的访问./">www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。</a></p>
<p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p>
<p>3、添加校验token</p>
<p>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p>
<h3 id="104、如何实现跨域？说一下-JSONP-实现原理？"><a href="#104、如何实现跨域？说一下-JSONP-实现原理？" class="headerlink" title="104、如何实现跨域？说一下 JSONP 实现原理？"></a>104、如何实现跨域？说一下 JSONP 实现原理？</h3><p>1、<a href="https://blog.csdn.net/guorui_java/article/details/107345499">jsonp原理详解——终于搞清楚jsonp是啥了</a></p>
<p>2、最流行的跨域方案cors</p>
<p>cors是目前主流的跨域解决方案，跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>
<p>3、最方便的跨域方案Nginx</p>
<p>nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</p>
<p>现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</p>
<p>反向代理的原理很简单，即所有客户端的请求都必须先经过nginx的处理，nginx作为代理服务器再讲请求转发给node或者java服务，这样就规避了同源策略。</p>
<h3 id="105、websocket应用的是哪个协议"><a href="#105、websocket应用的是哪个协议" class="headerlink" title="105、websocket应用的是哪个协议"></a>105、websocket应用的是哪个协议</h3><p>WebSocket是一个允许Web应用程序(通常指浏览器)与服务器进行双向通信的协议。HTML5的WebSocket API主要是为浏览器端提供了一个基于TCP协议实现全双工通信的方法。</p>
<p>WebSocket优势： 浏览器和服务器只需要要做一个握手的动作，在建立连接之后，双方可以在任意时刻，相互推送信息。同时，服务器与客户端之间交换的头信息很小。</p>
<h3 id="106、说一下-tcp-粘包是怎么产生的？"><a href="#106、说一下-tcp-粘包是怎么产生的？" class="headerlink" title="106、说一下 tcp 粘包是怎么产生的？"></a>106、说一下 tcp 粘包是怎么产生的？</h3><p>发送方需要等缓冲区满才能发送出去，造成粘包；<br>接收方不及时接收缓冲区的包，造成粘包；</p>
<h3 id="107、请列举出在-JDK-中几个常用的设计模式？"><a href="#107、请列举出在-JDK-中几个常用的设计模式？" class="headerlink" title="107、请列举出在 JDK 中几个常用的设计模式？"></a>107、请列举出在 JDK 中几个常用的设计模式？</h3><h4 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h4><p>作用：保证类只有一个实例。</p>
<p>JDK中体现：Runtime类。</p>
<h4 id="2、静态工厂模式"><a href="#2、静态工厂模式" class="headerlink" title="2、静态工厂模式"></a>2、静态工厂模式</h4><p>作用：代替构造函数创建对象，方法名比构造函数清晰。</p>
<p>JDK中体现：Integer.valueOf、Class.forName</p>
<h4 id="3、抽象工厂"><a href="#3、抽象工厂" class="headerlink" title="3、抽象工厂"></a>3、抽象工厂</h4><p>作用：创建某一种类的对象。</p>
<p>JDK中体现：Java.sql包。</p>
<h4 id="4、原型模式"><a href="#4、原型模式" class="headerlink" title="4、原型模式"></a>4、原型模式</h4><p>clone()；</p>
<p>原型模式的本质是拷贝原型来创建新的对象，拷贝是比new更快的创建对象的方法，当需要大批量创建新对象而且都是同一个类的对象的时候考虑使用原型模式。</p>
<p>一般的克隆只是浅拷贝（对象的hash值不一样，但是对象里面的成员变量的hash值是一样的）。</p>
<p>有些场景需要深拷贝，这时我们就要重写clone方法，以ArrayList为例：</p>
<h4 id="5、适配器模式"><a href="#5、适配器模式" class="headerlink" title="5、适配器模式"></a>5、适配器模式</h4><p>作用：使不兼容的接口相容。</p>
<p>JDK中体现：InputStream、OutputStream。</p>
<h4 id="6、装饰器模式"><a href="#6、装饰器模式" class="headerlink" title="6、装饰器模式"></a>6、装饰器模式</h4><p>作用：为类添加新的功能，防止类继承带来的类爆炸。</p>
<p>JDK中体现：io类、Collections、List。</p>
<h4 id="7、外观模式"><a href="#7、外观模式" class="headerlink" title="7、外观模式"></a>7、外观模式</h4><p>作用：封装一组交互类，一直对外提供接口。</p>
<p>JDK中体现：logging包。</p>
<h4 id="8、享元模式"><a href="#8、享元模式" class="headerlink" title="8、享元模式"></a>8、享元模式</h4><p>作用：共享对象、节省内存。</p>
<p>JDK中体现：Integer.valueOf、String常量池。</p>
<h4 id="9、代理模式"><a href="#9、代理模式" class="headerlink" title="9、代理模式"></a>9、代理模式</h4><p>作用：</p>
<p>（1）透明调用被代理对象，无须知道复杂实现细节；</p>
<p>（2）增加被代理类的功能；</p>
<p>JDK中体现：动态代理。</p>
<h4 id="10、迭代器模式"><a href="#10、迭代器模式" class="headerlink" title="10、迭代器模式"></a>10、迭代器模式</h4><p>作用：将集合的迭代和集合本身分离。</p>
<p>JDK中体现：Iterator</p>
<h4 id="11、命令模式"><a href="#11、命令模式" class="headerlink" title="11、命令模式"></a>11、命令模式</h4><p>作用：封装操作，使接口一致。</p>
<p>JDK中体现：Runable、Callable、ThreadPoolExecutor。</p>
<h3 id="108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？"><a href="#108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？" class="headerlink" title="108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？"></a>108、什么是设计模式？你是否在你的代码里面使用过任何设计模式？</h3><h4 id="1、什么是设计模式？"><a href="#1、什么是设计模式？" class="headerlink" title="1、什么是设计模式？"></a>1、什么是设计模式？</h4><p>设计模式是解决软件开发某些特定问题而提出的一些解决方案，也可以理解为解决问题的一些固定思路。</p>
<p>通过设计模式可以帮助我们增强代码的可复用性、可扩展性、灵活性。</p>
<p>我们使用设计模式的最终目的是实现代码的高内聚、低耦合。</p>
<h4 id="2、设计模式的七大原则"><a href="#2、设计模式的七大原则" class="headerlink" title="2、设计模式的七大原则"></a>2、设计模式的七大原则</h4><p>单一职责原则<br>接口隔离原则<br>依赖倒转原则<br>里式替换原则<br>开闭原则<br>迪米特法则<br>合成复用原则</p>
<h4 id="3、你是否在你的代码里面使用过任何设计模式？"><a href="#3、你是否在你的代码里面使用过任何设计模式？" class="headerlink" title="3、你是否在你的代码里面使用过任何设计模式？"></a>3、你是否在你的代码里面使用过任何设计模式？</h4><p>（1）单例模式</p>
<p>JDK种的runtime，Spring种的singeton。</p>
<p>（2）简单工厂模式</p>
<p>Spring的BeanFactory，根据传入一个唯一标识来获得bean对象。</p>
<p>（3）原型模式</p>
<p>clone()</p>
<p>（4）代理模式</p>
<p>Spring的AOP中，Spring实现AOP功能的原理就是代理模式，①JDK动态代理。②CGLIB动态代理，使用Advice（通知）对类进行方法级别的切面增强。</p>
<p>（5）装饰器模式</p>
<p>为类添加新的功能，防止类爆炸；</p>
<p>IO流、数据源包装，Spring中用到的装饰器模式表现在Wrapper。</p>
<h3 id="109、Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式"><a href="#109、Java-中什么叫单例设计模式？请用-Java-写出线程安全的单例模式" class="headerlink" title="109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式"></a>109、Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式</h3><ol>
<li>保证程序只有一个对象的实例，叫做单例模式；</li>
<li>内部类的方式实现单例模式，是线程安全的；</li>
<li>双重验证方式实现单例模式也是线程安全的；</li>
</ol>
<h3 id="110、在-Java-中，什么叫观察者设计模式（observer-design-pattern）？"><a href="#110、在-Java-中，什么叫观察者设计模式（observer-design-pattern）？" class="headerlink" title="110、在 Java 中，什么叫观察者设计模式（observer design pattern）？"></a>110、在 Java 中，什么叫观察者设计模式（observer design pattern）？</h3><p>1、观察者模式是一种一对多的依赖关系，让多个观察者同时监听某一主题对象。当这个主题对象发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<p>2、JAVA提供的对观察者模式的支持</p>
<p>在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。</p>
<p>（1）Observer接口</p>
<p>这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>（2）Observable类</p>
<p>被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。</p>
<h3 id="111、使用工厂模式最主要的好处是什么？在哪里使用？"><a href="#111、使用工厂模式最主要的好处是什么？在哪里使用？" class="headerlink" title="111、使用工厂模式最主要的好处是什么？在哪里使用？"></a>111、使用工厂模式最主要的好处是什么？在哪里使用？</h3><p>1、工厂模式好处</p>
<ul>
<li>良好的封装性、代码结构清晰；</li>
<li>扩展性好，如果想增加一个产品，只需扩展一个工厂类即可；</li>
<li>典型的解耦框架；</li>
</ul>
<p>2、在哪里使用？</p>
<ul>
<li>需要生成对象的地方；</li>
<li>不同数据库的访问；</li>
</ul>
<p>112、请解释自动装配模式的区别？<br>有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。</p>
<p>1、no</p>
<p>默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。第 402 页 共 485 页</p>
<p>2、byName</p>
<p>通过参数名 自动装配，Spring 容器在配置文件中发现 bean</p>
<p>的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属</p>
<p>性具有相同名字的 bean。</p>
<p>3、byType:</p>
<p>通过参数类型自动装配，Spring 容器在配置文件中发现 bean</p>
<p>的 autowire 属性被设置成 byType，之后容器试图匹配、装配和该 bean 的属</p>
<p>性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。</p>
<p>4、constructor</p>
<p>这个方式类似于 byType， 但是要提供给构造器参数，如</p>
<p>果没有确定的带参数的构造器参数类型，将会抛出异常。</p>
<p>5、autodetect</p>
<p>首先尝试使用 constructor 来自动装配，如果无法工作，</p>
<p>则使用 byType 方式。</p>
<h3 id="113、举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？"><a href="#113、举一个用-Java-实现的装饰模式-decorator-design-pattern-？它是作用于对象层次还是类层次？" class="headerlink" title="113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？"></a>113、举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</h3><p>在Java IO中运用了装饰器模式，inputStream作为抽象类，其下有几个实现类，表示从不同的数据源输入：</p>
<ol>
<li>byteArrayInputStream</li>
<li>fileInputStream</li>
<li>StringBufferInputStream</li>
<li>PipedInputStream，从管道产生输入；</li>
<li>SequenceInputStream，可将其他流收集合并到一个流内；</li>
</ol>
<p>FilterInputStream作为装饰器在JDK中是一个普通类，其下面有多个具体装饰器比如BufferedInputStream、DataInputStream等。</p>
<p>FilterInputStream内部封装了基础构件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br></pre></td></tr></table></figure>


<p>而BufferedInputStream在调用其read()读取数据时会委托基础构件来进行更底层的操作，而它自己所起的装饰作用就是缓冲，在源码中可以很清楚的看到这一切。</p>
<h3 id="114、什么是-Spring-框架？Spring-框架有哪些主要模块？"><a href="#114、什么是-Spring-框架？Spring-框架有哪些主要模块？" class="headerlink" title="114、什么是 Spring 框架？Spring 框架有哪些主要模块？"></a>114、什么是 Spring 框架？Spring 框架有哪些主要模块？</h3><p>Spring是一个控制反转和面向切面的容器框架。</p>
<p>Spring有七大功能模块：</p>
<p>1、Core</p>
<p>Core模块是Spring的核心类库，Core实现了IOC功能。</p>
<p>2、AOP</p>
<p>Apring AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常见的拦截器，供用户自定义和配置。</p>
<p>3、orm</p>
<p>提供对常用ORM框架的管理和支持，hibernate、mybatis等。</p>
<p>4、Dao</p>
<p>Spring提供对JDBC的支持，对JDBC进行封装。</p>
<p>5、Web</p>
<p>对Struts2的支持。</p>
<p>6、Context</p>
<p>Context模块提供框架式的Bean的访问方式，其它程序可以通过Context访问Spring的Bean资源，相当于资源注入。</p>
<p>7、MVC</p>
<p>MVC模块为spring提供了一套轻量级的MVC实现，即Spring MVC。</p>
<h3 id="115、使用-Spring-框架能带来哪些好处？"><a href="#115、使用-Spring-框架能带来哪些好处？" class="headerlink" title="115、使用 Spring 框架能带来哪些好处？"></a>115、使用 Spring 框架能带来哪些好处？</h3><p>1、轻量级框架、容器</p>
<p>Spring是一个容器，管理对象的生命周期和配置。基于一个可配置原型prototype，你的bean可以使单利的，也可以每次需要时都生成一个新的实例。</p>
<p>2、控制反转IOC</p>
<p>Spring通过控制反转实现松耦合。</p>
<p>3、支持AOP</p>
<p>Spring提供对AOP的支持，它允许将一些通用任务，如安全、事务、日志等进行集中式处理，从而提高了程序的复用性。</p>
<p>4、轻量级框架</p>
<p>5、方便测试</p>
<p>Spring提供Junit4的支持，可以通过注解方便测试spring程序。</p>
<p>6、对Java中很多API进行了封装</p>
<p>7、方便集成各种优秀框架</p>
<p>如Struts、hibernate、mybstis。</p>
<p>8、支持声明式事务处理</p>
<p>只需通过配置就可以完成对事务的管理，而无须手动编程。</p>
<h3 id="116、Spring-IOC、AOP举例说明"><a href="#116、Spring-IOC、AOP举例说明" class="headerlink" title="116、Spring IOC、AOP举例说明"></a>116、Spring IOC、AOP举例说明</h3><h4 id="1、IOC理论的背景"><a href="#1、IOC理论的背景" class="headerlink" title="1、IOC理论的背景"></a>1、IOC理论的背景</h4><p>我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。</p>
<p>如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。<br>齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。</p>
<p>耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品Spring。</p>
<h4 id="2、什么是控制反转"><a href="#2、什么是控制反转" class="headerlink" title="2、什么是控制反转"></a>2、什么是控制反转</h4><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。<br>1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦，如下图：</p>
<p><a href="https://imgtu.com/i/jVTJxA"><img src="https://s1.ax1x.com/2022/06/27/jVTJxA.jpg" alt="jVTJxA.jpg"></a></p>
<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。<br>我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统（拿掉IoC容器后的系统）：</p>
<p><a href="https://imgtu.com/i/jVTDPg"><img src="https://s1.ax1x.com/2022/06/27/jVTDPg.jpg" alt="jVTDPg.jpg"></a></p>
<p>我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！<br>我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：<br>软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。<br>软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。<br>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p>
<h4 id="3、IOC的别名：依赖注入（DI）"><a href="#3、IOC的别名：依赖注入（DI）" class="headerlink" title="3、IOC的别名：依赖注入（DI）"></a>3、IOC的别名：依赖注入（DI）</h4><p>2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。<br>我们举一个生活中的例子，来帮助理解依赖注入的过程。大家对USB接口和USB设备应该都很熟悉吧，USB为我们使用电脑提供了很大的方便，现在有很多的外部设备都支持USB接口。</p>
<p><a href="https://imgtu.com/i/jVTrGQ"><img src="https://s1.ax1x.com/2022/06/27/jVTrGQ.jpg" alt="jVTrGQ.jpg"></a></p>
<p>现在，我们利用电脑主机和USB接口来实现一个任务：从外部USB设备读取一个文件。<br>电脑主机读取文件的时候，它一点也不会关心USB接口上连接的是什么外部设备，而且它确实也无须知道。它的任务就是读取USB接口，挂接的外部设备只要符合USB接口标准即可。所以，如果我给电脑主机连接上一个U盘，那么主机就从U盘上读取文件；如果我给电脑主机连接上一个外置硬盘，那么电脑主机就从外置硬盘上读取文件。挂接外部设备的权力由我作主，即控制权归我，至于USB接口挂接的是什么设备，电脑主机是决定不了，它只能被动的接受。电脑主机需要外部设备的时候，根本不用它告诉我，我就会主动帮它挂上它想要的外部设备，你看我的服务是多么的到位。这就是我们生活中常见的一个依赖注入的例子。在这个过程中，我就起到了IOC容器的作用。<br>通过这个例子,依赖注入的思路已经非常清楚：当电脑主机读取文件的时候，我就把它所要依赖的外部设备，帮他挂接上。整个外部设备注入的过程和一个被依赖的对象在系统运行时被注入另外一个对象内部的过程完全一样。<br>我们把依赖注入应用到软件系统中，再来描述一下这个过程：<br>对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。<br>在传统的实现中，由程序内部代码来控制组件之间的关系。我们经常使用new关键字来实现两个组件之间关系的组合，这种实现方式会造成组件之间耦合。IOC很好地解决了该问题，它将实现组件间关系从程序内部提到外部容器，也就是说由容器在运行期将组件间的某种依赖关系动态注入组件中。</p>
<h4 id="4、IOC为我们带来了什么好处"><a href="#4、IOC为我们带来了什么好处" class="headerlink" title="4、IOC为我们带来了什么好处"></a>4、IOC为我们带来了什么好处</h4><p>我们还是从USB的例子说起，使用USB外部设备比使用内置硬盘，到底带来什么好处？<br>第一、USB设备作为电脑主机的外部设备，在插入主机之前，与电脑主机没有任何的关系，只有被我们连接在一起之后，两者才发生联系，具有相关性。所以，无论两者中的任何一方出现什么的问题，都不会影响另一方的运行。这种特性体现在软件工程中，就是可维护性比较好，非常便于进行单元测试，便于调试程序和诊断故障。代码中的每一个Class都可以单独测试，彼此之间互不影响，只要保证自身的功能无误即可，这就是组件之间低耦合或者无耦合带来的好处。<br>第二、USB设备和电脑主机的之间无关性，还带来了另外一个好处，生产USB设备的厂商和生产电脑主机的厂商完全可以是互不相干的人，各干各事，他们之间唯一需要遵守的就是USB接口标准。这种特性体现在软件开发过程中，好处可是太大了。每个开发团队的成员都只需要关心实现自身的业务逻辑，完全不用去关心其它的人工作进展，因为你的任务跟别人没有任何关系，你的任务可以单独测试，你的任务也不用依赖于别人的组件，再也不用扯不清责任了。所以，在一个大中型项目中，团队成员分工明确、责任明晰，很容易将一个大的任务划分为细小的任务，开发效率和产品质量必将得到大幅度的提高。<br>第三、同一个USB外部设备可以插接到任何支持USB的设备，可以插接到电脑主机，也可以插接到DV机，USB外部设备可以被反复利用。在软件工程中，这种特性就是可复用性好，我们可以把具有普遍性的常用组件独立出来，反复利用到项目中的其它部分，或者是其它项目，当然这也是面向对象的基本特征。显然，IOC不仅更好地贯彻了这个原则，提高了模块的可复用性。符合接口标准的实现，都可以插接到支持此标准的模块中。<br>第四、同USB外部设备一样，模块具有热插拔特性。IOC生成对象的方式转为外置方式，也就是把对象生成放在配置文件里进行定义，这样，当我们更换一个实现子类将会变得很简单，只要修改配置文件就可以了，完全具有热插拨的特性。<br>以上几点好处，难道还不足以打动我们，让我们在项目开发过程中使用IOC框架吗？</p>
<h4 id="5、IOC容器的技术剖析"><a href="#5、IOC容器的技术剖析" class="headerlink" title="5、IOC容器的技术剖析"></a>5、IOC容器的技术剖析</h4><p>IOC中最基本的技术就是“反射(Reflection)”编程，目前.Net C#、Java和PHP5等语言均支持，其中PHP5的技术书籍中，有时候也被翻译成“映射”。有关反射的概念和用法，大家应该都很清楚，通俗来讲就是根据给出的类名（字符串方式）来动态地生成对象。这种编程方式可以让对象在生成时才决定到底是哪一种对象。反射的应用是很广泛的，很多的成熟的框架，比如象Java中的Hibernate、Spring框架，.Net中 NHibernate、Spring.Net框架都是把“反射”做为最基本的技术手段。<br>反射技术其实很早就出现了，但一直被忽略，没有被进一步的利用。当时的反射编程方式相对于正常的对象生成方式要慢至少得10倍。现在的反射技术经过改良优化，已经非常成熟，反射方式生成对象和通常对象生成方式，速度已经相差不大了，大约为1-2倍的差距。<br>我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<h4 id="6、IOC容器的一些产品"><a href="#6、IOC容器的一些产品" class="headerlink" title="6、IOC容器的一些产品"></a>6、IOC容器的一些产品</h4><p>Sun ONE技术体系下的IOC容器有：轻量级的有Spring、Guice、Pico Container、Avalon、HiveMind；重量级的有EJB；不轻不重的有JBoss，Jdon等等。Spring框架作为Java开发中SSH(Struts、Spring、Hibernate)三剑客之一，大中小项目中都有使用，非常成熟，应用广泛，EJB在关键性的工业级项目中也被使用，比如某些电信业务。<br>.Net技术体系下的IOC容器有：Spring.Net、Castle等等。Spring.Net是从Java的Spring移植过来的IOC容器，Castle的IOC容器就是Windsor部分。它们均是轻量级的框架，比较成熟，其中Spring.Net已经被逐渐应用于各种项目中。</p>
<h4 id="7、使用IOC框架应该注意什么"><a href="#7、使用IOC框架应该注意什么" class="headerlink" title="7、使用IOC框架应该注意什么"></a>7、使用IOC框架应该注意什么</h4><p>使用IOC框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入IOC框架的缺点，做到心中有数，杜绝滥用框架。</p>
<p>（1）软件系统中由于引入了第三方IOC容器，生成对象的步骤变得有些复杂，本来是两者之间的事情，又凭空多出一道手续，所以，我们在刚开始使用IOC框架的时候，会感觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系。</p>
<p>（2）由于IOC容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求运行效率的话，就必须对此进行权衡。</p>
<p>（3）、具体到IOC框架产品(比如：Spring)来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本。</p>
<p>（4）IOC框架产品本身的成熟度需要进行评估，如果引入一个不成熟的IOC框架产品，那么会影响到整个项目，所以这也是一个隐性的风险。<br>我们大体可以得出这样的结论：一些工作量不大的项目或者产品，不太适合使用IOC框架产品。另外，如果团队成员的知识能力欠缺，对于IOC框架产品缺乏深入的理解，也不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入IOC框架产品，象WEB2.0网站就是这种情况。</p>
<h3 id="117、什么是控制反转-IOC-？什么是依赖注入？"><a href="#117、什么是控制反转-IOC-？什么是依赖注入？" class="headerlink" title="117、什么是控制反转(IOC)？什么是依赖注入？"></a>117、什么是控制反转(IOC)？什么是依赖注入？</h3><p>借助Spring实现具有依赖关系的对象之间的解耦。</p>
<p>对象A运行需要对象B，由主动创建变为IOC容器注入，这便是控制反转。</p>
<p>获得依赖对象的过程被反转了，获取依赖对象的过程由自身创建变为由IOC容器注入，这便是依赖注入。</p>
<h3 id="118、BeanFactory-和-ApplicationContext-有什么区别？"><a href="#118、BeanFactory-和-ApplicationContext-有什么区别？" class="headerlink" title="118、BeanFactory 和 ApplicationContext 有什么区别？"></a>118、BeanFactory 和 ApplicationContext 有什么区别？</h3><p>1、BeanFactory是Spring的最底层接口，包含bean的定义，管理bean的加载，实例化，控制bean的生命周期，特点是每次获取对象时才会创建对象。</p>
<p>ApplicationContext是BeanFactory的子接口，拥有BeanFactory的全部功能，并且扩展了很多高级特性，每次容器启动时就会创建所有的对象。</p>
<ol>
<li>ApplicationContext的额外功能：</li>
<li>继承MessageSource，支持国际化；</li>
<li>统一的资源文件访问方式；</li>
<li>提供在监听器中注册bean；</li>
<li>同时加载过个配置文件；</li>
<li>载入多个（有继承关系）上下文，使得每个上下文都专注于一个特定的层次，比如应用的web层；</li>
</ol>
<p>2、BeanFactory通常以编程的方式被创建，ApplicationContext可以以声明的方式创建，如使用ContextLoader。</p>
<p>3、BeanFactory 和 ApplicationContext都支持BeanPostProcessor，BeanFactoryPostProcessor，但BeanFactory需要手动注册，ApplicationContext则是自动注册。</p>
<h3 id="119、什么是-JavaConfig？"><a href="#119、什么是-JavaConfig？" class="headerlink" title="119、什么是 JavaConfig？"></a>119、什么是 JavaConfig？</h3><p>JavaConfig是Spring3.0新增的概念，就是以注解的形式取代Spring中繁琐的xml文件。</p>
<p>JavaConfig结合了xml的解耦和java编译时检查的优点。</p>
<ol>
<li>@Configuration，表示这个类是配置类；</li>
<li>@ComponentScan，相当于xml的&lt;context:componentScan basepackage&#x3D;&gt;；</li>
<li>@Bean，相当于xml的<bean id="student" class="com.guor.entity">；</li>
<li>@EnableWebMvc，相当于xml的<a href="mvc:annotation-driven">mvc:annotation-driven</a>；</li>
<li>@ImportResource，相当于xml的<import resource="application-context-cache.xml">；</li>
<li>@PropertySource，用于读取properties配置文件；</li>
<li>@Profile，一般用于多环境配置，激活时可用@ActiveProfile(“dev”)注解；</li>
</ol>
<h3 id="120、什么是-ORM-框架？"><a href="#120、什么是-ORM-框架？" class="headerlink" title="120、什么是 ORM 框架？"></a>120、什么是 ORM 框架？</h3><p>ORM（Object-relational mapping），对象关系映射。</p>
<p>是为了解决面向对象与关系型数据库存在的不匹配问题。</p>
<p>ORM框架的优点：</p>
<ol>
<li>开发效率更高</li>
<li>数据访问更抽象、轻便</li>
<li>支持面向对象封装</li>
</ol>
<h3 id="121、Spring-有几种配置方式？"><a href="#121、Spring-有几种配置方式？" class="headerlink" title="121、Spring 有几种配置方式？"></a>121、Spring 有几种配置方式？</h3><p>1、xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jackma&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tyq.dto.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jackma&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;55&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jm&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jm&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tyq.dto.Dog&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jack&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;breed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;金毛&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、基于注解的方式</p>
<p>项目越来越大，基于xml配置太麻烦，Spring 2.x时代提供了声明bean的注解。</p>
<p>（1）Bean的定义</p>
<p>@Component、@Controller、@Service、@Repository。</p>
<p>（2）Bean的注入</p>
<p>@Autowire</p>
<p>3、基于Java的方式</p>
<p>Spring 3.x以后，可以通过Java代码装配Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">zs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>  <span class="comment">//两个狗</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">haqi</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;zs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//get，set方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 原来就是配置类啊，通过@Bean、@Component、getBean方式进行Bean的注册和发现。</p>
<p>122、请解释 Spring Bean 的生命周期？</p>
<ol>
<li>通过构造器或工厂方法创建bean实例；</li>
<li>为bean的属性赋值；</li>
<li>调用bean的初始化方法；</li>
<li>使用bean；</li>
<li>当容器关闭时，调用bean的销毁方法；</li>
</ol>
<h3 id="123、Spring-Bean-的作用域之间有什么区别？"><a href="#123、Spring-Bean-的作用域之间有什么区别？" class="headerlink" title="123、Spring Bean 的作用域之间有什么区别？"></a>123、Spring Bean 的作用域之间有什么区别？</h3><h4 id="Spring容器中的bean可以分为5个范围："><a href="#Spring容器中的bean可以分为5个范围：" class="headerlink" title="Spring容器中的bean可以分为5个范围："></a>Spring容器中的bean可以分为5个范围：</h4><ol>
<li>singleton：这种bean范围是默认的，这种范围确保不管接受多少请求，每个容器中只哟一个bean的实例，单例模式；</li>
<li>prototype：为每一个bean提供一个实例；</li>
<li>request：在请求bean范围内为每一个来自客户端的网络请求创建一个实例，在请求完毕后，bean会失效并被垃圾回收器回收；</li>
<li>session：为每个session创建一个实例，session过期后，bean会随之消失；</li>
<li>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet公用全局的存储变量的话，那么全局变量需要存储在global-session中。</li>
</ol>
<h3 id="124、如何在-Spring-Boot-中禁用-Actuator-端点安全性？"><a href="#124、如何在-Spring-Boot-中禁用-Actuator-端点安全性？" class="headerlink" title="124、如何在 Spring Boot 中禁用 Actuator 端点安全性？"></a>124、如何在 Spring Boot 中禁用 Actuator 端点安全性？</h3><p>默认情况下，所有敏感的HTTP端点都是安全的，只有具有Actuator角色的用户才能访问它们。安全性是使用标准的HTTPServletRequest.isUserInRole方法实施的。我们可以使用management.security.enable &#x3D; false来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p>
<h3 id="125、什么是-Spring-inner-beans？"><a href="#125、什么是-Spring-inner-beans？" class="headerlink" title="125、什么是 Spring inner beans？"></a>125、什么是 Spring inner beans？</h3><p>在Spring框架中，无论何时bean被使用时，当仅被调用一个属性。可以将这个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们要做的是创建一个Person实例，然后再Customer内部使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;CustomerBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.Customer&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.person&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">1</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;素小暖&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">18</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="126、Spring-框架中的单例-Beans-是线程安全的么？"><a href="#126、Spring-框架中的单例-Beans-是线程安全的么？" class="headerlink" title="126、Spring 框架中的单例 Beans 是线程安全的么？"></a>126、Spring 框架中的单例 Beans 是线程安全的么？</h3><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态，所以在某种程度上说Spring的单例bean时线程安全的。如果你的bean有多种状态的话，比如view model，就需要自行保证线程安全啦。</p>
<p>最浅显的解决办法就是将多态bean的作用域由singleton变更为prototype。</p>
<h3 id="127、请解释-Spring-Bean-的自动装配？"><a href="#127、请解释-Spring-Bean-的自动装配？" class="headerlink" title="127、请解释 Spring Bean 的自动装配？"></a>127、请解释 Spring Bean 的自动装配？</h3><p>Spring支持IOC，自动装配不用类实例化，直接从bean容器中取。</p>
<p>1、配置在xml中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employeeDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.guor.EmployeeDAOImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、@Autowired自动装配</p>
<h3 id="128、如何开启基于注解的自动装配？"><a href="#128、如何开启基于注解的自动装配？" class="headerlink" title="128、如何开启基于注解的自动装配？"></a>128、如何开启基于注解的自动装配？</h3><p>要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：</p>
<p>引入配置文件中的<bean>下引入 <a href="context:annotation-config">context:annotation-config</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;context:annotation-config /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在bean配置文件中直接引入AutowiredAnnotationBeanPostProcessor</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="129、什么是-Spring-Batch？"><a href="#129、什么是-Spring-Batch？" class="headerlink" title="129、什么是 Spring Batch？"></a>129、什么是 Spring Batch？</h3><p>1、什么是spring batch?</p>
<p>spring batch是一个轻量级的、完善的批处理框架，它主要的目的在于帮助企业建立健壮、高效的批处理应用。</p>
<p>spring batch是Spring的一个子项目，它使用java语言并基于spring框架作为基础开发，使得已经使用Spring框架的开发者或者是企业可以更加容易访问和利用企业服务。</p>
<p>spring batch提供了大量可重用的组件,包括了日志、追踪、事务、任务作业统计、任务重启、跳过、重复、资源管理。</p>
<p>对大数据量和高性能的批处理任务，spring batch同样提供了高级功能和特性来支持。</p>
<p>例如：分区功能、远程功能。</p>
<p>总的来说，spring batch可以支持简单的、复杂的和大数据量的批处理作业。</p>
<p>2、spring batch业务场景</p>
<p>周期性的提交批处理</p>
<p>把一个任务并行处理</p>
<p>消息驱动应用分级处理</p>
<p>大规模并行批处理</p>
<p>手工或调度使任务失败之后重新启动</p>
<p>有依赖步骤的顺序执行(使用工作流驱动扩展)</p>
<p>处理时跳过部分记录</p>
<p>成批事务：为小批量的或有的存储过程&#x2F;脚本的场景使用</p>
<h3 id="130、spring-mvc-和-struts-的区别是什么？"><a href="#130、spring-mvc-和-struts-的区别是什么？" class="headerlink" title="130、spring mvc 和 struts 的区别是什么？"></a>130、spring mvc 和 struts 的区别是什么？</h3><p>1、拦截机制的不同</p>
<p>Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。</p>
<p>SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。</p>
<p>Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。</p>
<p>2、底层框架的不同</p>
<p>Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。</p>
<p>3、性能方面</p>
<p>Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。</p>
<p>4、配置方面</p>
<p>spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。</p>
<h3 id="131、请举例解释-Required-注解？"><a href="#131、请举例解释-Required-注解？" class="headerlink" title="131、请举例解释@Required 注解？"></a>131、请举例解释@Required 注解？</h3><p>@Required注解应用于bean属性的setter方法，它表明影响的bean属性在配置时必须放在XML配置文件中。</p>
<p>十九、请举例说明@Qualifier 注解？<br>如果在xml中定义了一种类型的多个bean，同时在java注解中又想把其中一个bean对象作为属性，那么此时可以使用@Qualifier加@Autowired来达到这一目的，若不加@Qualifier这个注解，在运行时会出现“ No qualifying bean of type [com.tutorialspoint.Student] is defined: expected single matching bean but found 2: student1,student2”这个异常。</p>
<h3 id="132、Spring常用注解"><a href="#132、Spring常用注解" class="headerlink" title="132、Spring常用注解"></a>132、Spring常用注解</h3><p><a href="https://blog.csdn.net/guorui_java/article/details/107347754">Spring常用注解（绝对经典）</a></p>
<h3 id="133、项目中是如何实现权限验证的，权限验证需要几张表"><a href="#133、项目中是如何实现权限验证的，权限验证需要几张表" class="headerlink" title="133、项目中是如何实现权限验证的，权限验证需要几张表"></a>133、项目中是如何实现权限验证的，权限验证需要几张表</h3><p>通过了解，现在最普遍的权限管理模型就是RBAC（Role-Based Access Control）。</p>
<p>1、权限控制分类</p>
<p>菜单功能<br>url控制（控制访问不同的控制器）<br>2、RBAC的优缺点</p>
<p>（1）优点</p>
<p>简化了用户和权限的关系<br>易扩展、易维护</p>
<p>（2）缺点</p>
<p>RBAC模型没有提供操作顺序的控制机制，这一缺陷使得RBAC模型很难适应哪些对操作次序有严格要求的系统。</p>
<p>3、RBAC支持的安全原则</p>
<p>（1）最小权限原则</p>
<p>RBAC可以将角色配置成其完成任务所需的最小权限集合。</p>
<p>（2）责任分离原则</p>
<p>可以通过调用相互独立互斥的角色来共同完成敏感的任务，例如要求一个记账员和财务管理员共同参与统一过账操作。</p>
<p>（3）数据抽象原则</p>
<p>可以通过权限的抽象来体现，例如财务操作用借款、存款等抽象权限，而不是使用典型的读写权限。</p>
<p>4、远古时代的权限控制</p>
<p>当时还没有RBAC，也没有这个概念，就是一堆程序员在那鼓捣，觉得登录这块该做点什么。</p>
<p><a href="https://imgtu.com/i/jV7rTK"><img src="https://s1.ax1x.com/2022/06/27/jV7rTK.jpg" alt="jV7rTK.jpg"></a></p>
<blockquote>
<p>1、新建一个用户，对这个用户进行赋予权限。</p>
<p>2、但是一旦用户多了，权限复杂了，这工作量也是蛮大的。</p>
</blockquote>
<p>5、RBAC</p>
<p>RBAC 1.0</p>
<p><a href="https://imgtu.com/i/jV76YD"><img src="https://s1.ax1x.com/2022/06/27/jV76YD.jpg" alt="jV76YD.jpg"></a></p>
<p><a href="https://imgtu.com/i/jV7cfe"><img src="https://s1.ax1x.com/2022/06/27/jV7cfe.jpg" alt="jV7cfe.jpg"></a></p>
<p>直接上图，一目了然，当程序不是很复杂的时候，RBAC就是这样设计的，我们公司的权限验证模块就是这样设计的。</p>
<p>简简单单，五张表，解</p>
<p>RBAC 2.0</p>
<p>基于RBAC 1.0模型的基础上，进行了角色的访问控制</p>
<p><a href="https://imgtu.com/i/jV7yFO"><img src="https://s1.ax1x.com/2022/06/27/jV7yFO.jpg" alt="jV7yFO.jpg"></a></p>
<p>RBAC2中的一个基本限制是互斥角色的限制，互斥角色是指各自权限可以互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。</p>
<p>该模型有以下几种约束</p>
<ul>
<li>互斥角色 ：同一用户只能分配到一组互斥角色集合中至多一个角色，支持责任分离的原则。互斥角色是指各自权限互相制约的两个角色。对于这类角色一个用户在某一次活动中只能被分配其中的一个角色，不能同时获得两个角色的使用权。常举的例子：在审计活动中，一个角色不能同时被指派给会计角色和审计员角色。</li>
<li>基数约束 ：一个角色被分配的用户数量受限；一个用户可拥有的角色数目受限；同样一个角色对应的访问权限数目也应受限，以控制高级权限在系统中的分配。</li>
<li>先决条件角色 ：可以分配角色给用户仅当该用户已经是另一角色的成员；对应的可以分配访问权限给角色，仅当该角色已经拥有另一种访问权限。指要想获得较高的权限，要首先拥有低一级的权限。</li>
<li>运行时互斥 ：例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。</li>
</ul>
<p>6、rbac的实现理论分析</p>
<p>进入登录页面；<br>拿到通过post传过来的用户名和密码；<br>使用orm进行过滤查找；<br>如果能找到值，则说明登录成功：登录成功后调用rbac初始化函数，初始化函数的主要功能是获取用户的权限和菜单保存到session中，并跳转客户列表页面；如果失败，页面进行友好提示；</p>
<p>7、url权限控制关键代码</p>
<p><a href="https://imgtu.com/i/jV7Dw6"><img src="https://s1.ax1x.com/2022/06/27/jV7Dw6.jpg" alt="jV7Dw6.jpg"></a></p>
<h3 id="134、谈谈controller，接口调用的路径问题"><a href="#134、谈谈controller，接口调用的路径问题" class="headerlink" title="134、谈谈controller，接口调用的路径问题"></a>134、谈谈controller，接口调用的路径问题</h3><p>1、Spring MVC如何匹配请求路径</p>
<p>@RequestMapping是用来映射请求的，比如get请求、post请求、或者REST风格与非REST风格的。该注解可以用在类上或方法上，如果用在类上，表示是该类中所有方法的父路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/springmvc&quot;)</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCTest</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testRequestMapping&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在类上还添加了一个@Controller注解，该注解在SpringMVC中负责处理由DispatcherServlet分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个model，然后再把该model返回给对应的view进行展示。</p>
<p>我们可以通过“springmvc&#x2F;testRequestMapping”这个路径来定位到testRequestMapping这个方法，然后执行方法内的方法体。</p>
<p>RequestMapping可以实现模糊匹配路径，比如：</p>
<ol>
<li>？表示一个字符；</li>
<li>*表示任意字符；</li>
<li>** 匹配多层路径；</li>
</ol>
<p>&#x2F;springmvc&#x2F;**&#x2F;testRequestMapping 就可以匹配&#x2F;springmvc&#x2F;stu&#x2F;getStudentInfo&#x2F;testRequestMapping 这样的路径了。</p>
<p>2、SpringMVC如何获取请求的参数</p>
<p>（1）@PathVariable</p>
<p>该注解用来映射请求URL中绑定的占位符。通过@PathVariable可以将URL中占位符的参数绑定到controller处理方法的入参中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testPathVariable/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPathVariable</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testPathVariable:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在index.jsp中我们添加一条连接，用来触发一个请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/testPathVariable/1&quot;</span>&gt;</span>testPathVariable<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>（2） @RequestParam</p>
<p>该注解也是用来获取请求参数的，那么该注解和@PathVariable有什么不同呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRequestParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestParam</span><span class="params">(<span class="meta">@RequestParam(value=&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(value=&quot;age&quot;, required=false, defaultValue=&quot;0&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;testRequestParam&quot;</span> + <span class="string">&quot; username:&quot;</span> + username + <span class="string">&quot; age:&quot;</span> +age);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在index.jsp添加超链接标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;springmvc/testRequestParam?username=jackie&amp;age=12&quot;</span>&gt;</span>testRequestParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>3、REST风格的请求</p>
<p>在SpringMVC中业务最多的应该是CRUD了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest/&#123;id&#125;&quot;, method=RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRestPut</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test put:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest/&#123;id&#125;&quot;, method=RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRestDelete</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test delete:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test post&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/testRest/&#123;id&#125;&quot;, method=RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">(<span class="meta">@PathVariable(value=&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;test get:&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="135、如何防止表单重复提交"><a href="#135、如何防止表单重复提交" class="headerlink" title="135、如何防止表单重复提交"></a>135、如何防止表单重复提交</h3><p>1、通过JavaScript屏蔽提交按钮（不推荐）</p>
<p>2、给数据库增加唯一键约束（简单粗暴）</p>
<p>3、利用Session防止表单重复提交（推荐）</p>
<p>4、使用AOP自定义切入实现</p>
<h3 id="136、Spring中都应用了哪些设计模式"><a href="#136、Spring中都应用了哪些设计模式" class="headerlink" title="136、Spring中都应用了哪些设计模式"></a>136、Spring中都应用了哪些设计模式</h3><h4 id="1、简单工厂模式"><a href="#1、简单工厂模式" class="headerlink" title="1、简单工厂模式"></a>1、简单工厂模式</h4><p>简单工厂模式的本质就是一个工厂类根据传入的参数，动态的决定实例化哪个类。</p>
<p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象。</p>
<h4 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h4><p>应用程序将对象的创建及初始化职责交给工厂对象，工厂Bean。</p>
<p>定义工厂方法，然后通过config.xml配置文件，将其纳入Spring容器来管理，需要通过factory-method指定静态方法名称。</p>
<h4 id="3、单例模式"><a href="#3、单例模式" class="headerlink" title="3、单例模式"></a>3、单例模式</h4><p>Spring用的是双重判断加锁的单例模式，通过getSingleton方法从singletonObjects中获取bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Checks already instantiated singletons and also allows for an early</span></span><br><span class="line"><span class="comment"> * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、代理模式"><a href="#4、代理模式" class="headerlink" title="4、代理模式"></a>4、代理模式</h4><p>Spring的AOP中，使用的Advice（通知）来增强被代理类的功能。Spring实现AOP功能的原理就是代理模式（① JDK动态代理，② CGLIB字节码生成技术代理。）对类进行方法级别的切面增强。</p>
<h4 id="5、装饰器模式"><a href="#5、装饰器模式" class="headerlink" title="5、装饰器模式"></a>5、装饰器模式</h4><p>装饰器模式：动态的给一个对象添加一些额外的功能。</p>
<p>Spring的ApplicationContext中配置所有的DataSource。这些DataSource可能是不同的数据库，然后SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的。</p>
<p>在Spring中有两种表现：</p>
<p>一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<h4 id="6、观察者模式"><a href="#6、观察者模式" class="headerlink" title="6、观察者模式"></a>6、观察者模式</h4><p>定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</p>
<p>Spring中观察者模式一般用在listener的实现。</p>
<h4 id="7、策略模式"><a href="#7、策略模式" class="headerlink" title="7、策略模式"></a>7、策略模式</h4><p>策略模式是行为性模式，调用不同的方法，适应行为的变化 ，强调父类的调用子类的特性 。</p>
<p>getHandler是HandlerMapping接口中的唯一方法，用于根据请求找到匹配的处理器。</p>
<h4 id="8、模板方法模式"><a href="#8、模板方法模式" class="headerlink" title="8、模板方法模式"></a>8、模板方法模式</h4><p>Spring JdbcTemplate的query方法总体结构是一个模板方法+回调函数，query方法中调用的execute()是一个模板方法，而预期的回调doInStatement(Statement state)方法也是一个模板方法。</p>
<h3 id="137、请举例说明如何在-Spring-中注入一个-Java-Collection？"><a href="#137、请举例说明如何在-Spring-中注入一个-Java-Collection？" class="headerlink" title="137、请举例说明如何在 Spring 中注入一个 Java Collection？"></a>137、请举例说明如何在 Spring 中注入一个 Java Collection？</h3><p>Spring注入有四种方式:</p>
<ol>
<li>set注入；</li>
<li>构造器注入；</li>
<li>基于注解的注入；</li>
<li>xml配置文件注入；</li>
</ol>
<p>想要注入java collection，就是注入集合类：</p>
<ol>
<li>list</li>
<li>set</li>
<li>map</li>
<li>props：该标签支持注入键和值都是字符串类型的键值对。</li>
</ol>
<p>list和set都使用value标签；map使用entry标签；props使用prop标签；</p>
<h3 id="138、mybatis-中-和-的区别是什么？"><a href="#138、mybatis-中-和-的区别是什么？" class="headerlink" title="138、mybatis 中 #{}和 ${}的区别是什么？"></a>138、mybatis 中 #{}和 ${}的区别是什么？</h3><ol>
<li>#{}带引号，${}不带引号；</li>
<li>#{}可以防止SQL注入；</li>
<li>${}常用于数据库表名、order by子句；</li>
<li>一般能用#{}就不要使用${}；</li>
</ol>
<h3 id="139、mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#139、mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="139、mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>139、mybatis 是否支持延迟加载？延迟加载的原理是什么？</h3><h4 id="1、mybatis-是否支持延迟加载？"><a href="#1、mybatis-是否支持延迟加载？" class="headerlink" title="1、mybatis 是否支持延迟加载？"></a>1、mybatis 是否支持延迟加载？</h4><p>延迟加载其实就是讲数据加载时机推迟，比如推迟嵌套查询的时机。</p>
<p>延迟加载可以实现先查询主表，按需实时做关联查询，返回关联表结果集，一定程度上提高了效率。</p>
<p>mybatis仅支持关联对象association和关联集合对象collection的延迟加载，association是一对一，collection是一对多查询，在mybatis配置文件中可以配置lazyloadingEnable&#x3D;true&#x2F;false。</p>
<h4 id="2、延迟加载的原理是什么？"><a href="#2、延迟加载的原理是什么？" class="headerlink" title="2、延迟加载的原理是什么？"></a>2、延迟加载的原理是什么？</h4><p>使用CGLIB为目标对象建立代理对象，当调用目标对象的方法时进入拦截器方法。</p>
<p>比如调用a.getB().getName()，拦截器方法invoke()发现a.getB()为null，会单独发送事先准备好的查询关联B对象的sql语句，把B查询出来然后调用a.setB(b)，也是a的对象的属性b就有值了，然后调用getName()，这就是延迟加载的原理。</p>
<h3 id="140、说一下-mybatis-的一级缓存和二级缓存？"><a href="#140、说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="140、说一下 mybatis 的一级缓存和二级缓存？"></a>140、说一下 mybatis 的一级缓存和二级缓存？</h3><p>一级缓存是session级别的缓存，默认开启，当查询一次数据库时，对查询结果进行缓存，如果之后的查询在一级缓存中存在，则无需再访问数据库；</p>
<p>二级缓存是sessionFactory级别的缓存，需要配置才会开启。当进行sql语句查询时，先查看二级缓存，如果不存在，访问一级缓存，降低数据库访问压力。</p>
<h3 id="141、mybatis-有哪些执行器（Executor）？"><a href="#141、mybatis-有哪些执行器（Executor）？" class="headerlink" title="141、mybatis 有哪些执行器（Executor）？"></a>141、mybatis 有哪些执行器（Executor）？</h3><p>1、mybatis有三种基本的Executor执行器：</p>
<p>（1）、SimpleExecutor</p>
<p>每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p>（2）、PauseExecutor</p>
<p>执行update或select，以sql做为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而且放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p>（3）、BatchExecutor</p>
<p>执行update，将所有sql通过addBatch()都添加到批处理中，等待统一执行executeBatch()，它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p>2、作用范围：</p>
<p>Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<p>3、Mybatis中如何指定使用哪一种Executor执行器？</p>
<p>在mybatis的配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>
<h3 id="142、mybatis-和-hibernate-的区别有哪些？"><a href="#142、mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="142、mybatis 和 hibernate 的区别有哪些？"></a>142、mybatis 和 hibernate 的区别有哪些？</h3><p>1、两者最大的区别</p>
<p>针对简单逻辑，都有对应的代码生成工具，可以生成简单基本的dao层方法；</p>
<p>针对高级查询，mybatis要手动编写sql语句和resultMap，而hibernate有良好的映射机制；</p>
<p>2、开发难度对比</p>
<p>hibernate &gt; mybatis </p>
<p>3、日志统计</p>
<p>hibernate有自己的日志统计功能，而mybatis需要借助log4j来记录日志。</p>
<p>4、数据库扩展比较</p>
<p>hibernate &gt; mybatis </p>
<p>5、缓存机制比较</p>
<p>因为hibernate对查询对象有良好的管理机制，用户无需关心sql，所以使用二级缓存如果出现脏数据，系统会报错。</p>
<p>而mybatis，如果不能获取最新数据，应该避免缓存的使用，脏数据的出现会给系统的正常运行带来很大的隐患。</p>
<p>6、如何选择</p>
<p>mybatis需要编写sql和映射规则，工作量大于hibernate；<br>mybatis支持的工具也有限，不能像hibernate那样有许多插件可以帮助生成映射代码和关联关系；<br>对于性能要求不太苛刻的系统，比如管理系统、ERP等推荐hibernate；<br>对于性能要求高、响应快、灵活的系统，比如电商系统，推荐使用mybatis；</p>
<h3 id="143、myBatis查询多个id、myBatis常用属性"><a href="#143、myBatis查询多个id、myBatis常用属性" class="headerlink" title="143、myBatis查询多个id、myBatis常用属性"></a>143、myBatis查询多个id、myBatis常用属性</h3><p>myBatis查询多个id（我居然回答用对象来传递…）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Page&lt;UserPoJo&gt;  <span class="title function_">getUserListByIds</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> List&lt;Integer&gt; ids)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--根据id列表批量查询user--&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;getUserListByIds&quot;</span> resultType=<span class="string">&quot;com.guor.UserPoJo&quot;</span>&gt;</span><br><span class="line">    select * from student</span><br><span class="line">    where id in</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;ids&quot;</span> item=<span class="string">&quot;userid&quot;</span> open=<span class="string">&quot;(&quot;</span> close=<span class="string">&quot;)&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">        #&#123;userid&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>



<h3 id="144、mybatis一级缓存、二级缓存"><a href="#144、mybatis一级缓存、二级缓存" class="headerlink" title="144、mybatis一级缓存、二级缓存"></a>144、mybatis一级缓存、二级缓存</h3><p>1、一级缓存：指的是mybatis中sqlSession对象的缓存，当我们执行查询以后，查询的结果会同时存入sqlSession中，再次查询的时候，先去sqlSession中查询，有的话直接拿出，当sqlSession消失时，mybatis的一级缓存也就消失了，当调用sqlSession的修改、添加、删除、commit()、close()等方法时，会清空一级缓存。</p>
<p>2、二级缓存：指的是mybatis中的sqlSessionFactory对象的缓存，由同一个sqlSessionFactory对象创建的sqlSession共享其缓存，但是其中缓存的是数据而不是对象。当命中二级缓存时，通过存储的数据构造成对象返回。查询数据的时候，查询的流程是二级缓存 &gt; 一级缓存 &gt; 数据库。</p>
<p>3、如果开启了二级缓存，sqlSession进行close()后，才会把sqlSession一级缓存中的数据添加到二级缓存中，为了将缓存数据取出执行反序列化，还需要将要缓存的pojo实现Serializable接口，因为二级缓存数据存储介质多种多样，不一定只存在内存中，也可能存在硬盘中。</p>
<p>4、mybatis框架主要是围绕sqlSessionFactory进行的，具体的步骤：</p>
<ol>
<li>定义一个configuration对象，其中包含数据源、事务、mapper文件资源以及影响数据库行为属性设置settings。</li>
<li>通过配置对象，则可以创建一个sqlSessionFactoryBuilder对象。</li>
<li>通过sqlSessionFactoryBuilder获得sqlSessionFactory实例。</li>
<li>通过sqlSessionFactory实例创建qlSession实例，通过sqlSession对数据库进行操作。</li>
</ol>
<p>5、代码实例</p>
<p>mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!-- 加载类路径下的属性文件 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 设置类型别名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;cn.itcast.javaee.mybatis.app04.Student&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;student&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span>  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">&lt;!-- 设置一个默认的连接环境信息 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_developer&quot;</span>&gt;</span>  </span><br><span class="line">     </span><br><span class="line">        <span class="comment">&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_developer&quot;</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用jdbc事务管理方式 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;jdbc&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用连接池方式来获取连接 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;pooled&quot;</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 配置与数据库交互的4个必要属性 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.driver&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.url&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.username&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;mysql.password&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line">     </span><br><span class="line">        <span class="comment">&lt;!-- 连接环境信息，取一个任意唯一的名字 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;oracle_developer&quot;</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用jdbc事务管理方式 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;jdbc&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- mybatis使用连接池方式来获取连接 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;pooled&quot;</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 配置与数据库交互的4个必要属性 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.driver&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.url&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.username&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;oracle.password&#125;&quot;</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">&lt;!-- 加载映射文件--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;cn/itcast/javaee/mybatis/app14/StudentMapper.xml&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取mybatis-config.xml文件</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">            <span class="comment">//初始化mybatis,创建SqlSessionFactory类的实例</span></span><br><span class="line">            <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">            <span class="comment">//创建session实例</span></span><br><span class="line">            <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 接下来在这里做很多事情,到目前为止,目的已经达到得到了SqlSession对象.通过调用SqlSession里面的方法,</span></span><br><span class="line"><span class="comment">             * 可以测试MyBatis和Dao层接口方法之间的正确性,当然也可以做别的很多事情,在这里就不列举了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//插入数据</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setC_password(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            user.setC_username(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            user.setC_salt(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            <span class="comment">//第一个参数为方法的完全限定名:位置信息+映射文件当中的id</span></span><br><span class="line">            session.insert(<span class="string">&quot;com.cn.dao.UserMapping.insertUserInformation&quot;</span>, user);</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            session.commit();</span><br><span class="line">            <span class="comment">//关闭session</span></span><br><span class="line">            session.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="145、mybatis如何防止sql注入"><a href="#145、mybatis如何防止sql注入" class="headerlink" title="145、mybatis如何防止sql注入"></a>145、mybatis如何防止sql注入</h3><p>注意：但凡是sql注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成sql语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的【外部数据不可信任】的原则，纵观web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的，所以自然能想到，就是变量的检测、过滤、验证下手，确保变量是开发者所预想的。</p>
<p>1、检查变量数据类型和格式</p>
<p>数据类型检查，sql执行前，要进行数据类型检查，如果是邮箱，参数就必须是邮箱的格式，如果是日期，就必须是日期格式；</p>
<p>只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度上可以避免SQL注入攻击。</p>
<p>如果上述例子中id是int型的，效果会怎样呢？无法注入，因为输入注入参数会失败。比如上述中的name字段，我们应该在用户注册的时候，就确定一个用户名规则，比如5-20个字符，只能由大小写字母、数字以及汉字组成，不包含特殊字符。此时我们应该有一个函数来完成统一的用户名检查。不过，仍然有很多场景并不能用到这个方法，比如写博客，评论系统，弹幕系统，必须允许用户可以提交任意形式的字符才行，否则用户体验感太差了。</p>
<p>2、过滤特殊符号</p>
<p>3、绑定变量，使用预编译语句</p>
<h3 id="146、为什么要使用-hibernate？"><a href="#146、为什么要使用-hibernate？" class="headerlink" title="146、为什么要使用 hibernate？"></a>146、为什么要使用 hibernate？</h3><ol>
<li>hibernate对jdbc进行了封装，简化了JDBC的重复性代码；</li>
<li>hibernate对dao有一个封装类hibernateTemplate，可以继承它，实现简单的CRUD接口。</li>
<li>hibernate使用注解和配置文件，可以对实体类和映射文件进行映射；</li>
<li>hibernate有事务管理机制，保证了数据的安全性；</li>
<li>hibernate有一级缓存和二级缓存；</li>
</ol>
<h3 id="146、hibernate-中如何在控制台查看打印的-sql-语句？"><a href="#146、hibernate-中如何在控制台查看打印的-sql-语句？" class="headerlink" title="146、hibernate 中如何在控制台查看打印的 sql 语句？"></a>146、hibernate 中如何在控制台查看打印的 sql 语句？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.show_sql=<span class="literal">true</span></span><br><span class="line">spring.jpa.properties.hibernate.format_sql=<span class="literal">true</span></span><br><span class="line">spring.jpa.properties.hibernate.use_sql_comments=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="147、hibernate-有几种查询方式？"><a href="#147、hibernate-有几种查询方式？" class="headerlink" title="147、hibernate 有几种查询方式？"></a>147、hibernate 有几种查询方式？</h3><p>1、导航对象图查询：根据已加载的对象，导航到其他对象。</p>
<p>例如，对于已经加载的Customer对象，调用它的getOrders().iterator()方法就可以导航到所有关联的Order对象，假如在关联级别使用了延迟加载检索策略，那么首次执行此方法时，hibernate会从数据库中加载关联的Order对象，否则就从缓存中获得Order对象。</p>
<p>2、OID方式：按照对象的OID来检索对象</p>
<p>Session的get()和load()方法提供了这种功能，如果在应用程序中先知道了OID，就可以使用这种方式检索对象。</p>
<p>get()和load()的用法完全一样，都需要两个参数，一个是持久化对象类名class，一个是行号OID，返回固定的某一行的数据，但是需要注意的是，当输入的OID不存在时，get()会返回一个空对象，load()则直接报错。</p>
<p>3、HQL检索方式：（hibernate query language）</p>
<p>使用面向对象的HQL查询语言，session的find()方法用于执行HQL查询语句。此外，hibernate还提供了query接口，它是hibernate提供的专门的HQL查询接口，能够执行各种复杂的HQL查询语句。</p>
<p>它具备以下功能：</p>
<ol>
<li>在查询语句中设定各种查询条件；</li>
<li>支持投影查询，即仅检索出对象的部分属性；</li>
<li>支持分页查询；</li>
<li>支持连接查询；</li>
<li>支持分组查询；</li>
<li>提供内置函数；</li>
<li>能够调用用户自定义的SQL函数；</li>
<li>支持子查询；</li>
<li>支持动态绑定参数；</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> session.createQuery(“from UserPo”）；</span><br></pre></td></tr></table></figure>


<p>获得一个query对象，注意参数字符串中不是一个SQL语句，from后面的是持久化对象名称；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> query.list();</span><br></pre></td></tr></table></figure>


<p>就可以获取数据库中对应表的数据集合。</p>
<p>4、QBC检索方式：Query By Criteria的API来检索对象</p>
<p>这种API封装了基于字符串形式的查询语句，提供了更加面向对象的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例：<span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> session.createCriteria(UserPo.class);</span><br></pre></td></tr></table></figure>


<p>创建一个Criteria对象，参数是所关联的持久化对象，criteria.add(Restrictions.ge(“id”,2));将查询条件加入对象中，后面的操作就和Query对象一样了。</p>
<p>5、本地SQL</p>
<p>使用本地数据库的SQL查询语句，hibernate会负责把检索到的JDBC ResultSet结果映射为持久化对象图。</p>
<h3 id="148、hibernate-实体类可以被定义为-final-吗？"><a href="#148、hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="148、hibernate 实体类可以被定义为 final 吗？"></a>148、hibernate 实体类可以被定义为 final 吗？</h3><p>可以将hibernate的实体类定义为final，但这种做法不好。</p>
<p>因为hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为Java不允许对final类进行扩展，所以hibernate就无法再使用代理了，如此一来就限制了使用可以提升性能的手段。</p>
<p>不过，如果你的持久化类实现了一个接口，而且在该接口中声明了所有定义于实体类中的所有public的方法的话，就能避免出现前面所说的不利后果。</p>
<h3 id="149、在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#149、在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>149、在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h3><p>hibernate是面向对象的ORM，所以一般定义成封装类型，要看数据库中的定义，如果数据库中有对应字段存在null值，就要定义Integer。也可以定义基本类型，在配置文件中写清楚即可。</p>
<h3 id="150、什么是-Spring-Boot？Spring-Boot-有哪些优点？"><a href="#150、什么是-Spring-Boot？Spring-Boot-有哪些优点？" class="headerlink" title="150、什么是 Spring Boot？Spring Boot 有哪些优点？"></a>150、什么是 Spring Boot？Spring Boot 有哪些优点？</h3><h4 id="1、Spring-Boot简介"><a href="#1、Spring-Boot简介" class="headerlink" title="1、Spring Boot简介"></a>1、Spring Boot简介</h4><p>基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突、引用的不稳定性得到了解决。</p>
<h4 id="2、Spring-Boot-有哪些优点？"><a href="#2、Spring-Boot-有哪些优点？" class="headerlink" title="2、Spring Boot 有哪些优点？"></a>2、Spring Boot 有哪些优点？</h4><ol>
<li>快速构建项目，可以选一些必要的组件；</li>
<li>对主流框架的无配置集成；</li>
<li>内嵌Tomcat容器，项目可独立运行；</li>
<li>删除了繁琐的xml配置文件；</li>
<li>极大地提高了开发和部署效率；</li>
<li>提供starter，简化maven配置；</li>
</ol>
<h3 id="3、SpringBoot有哪些缺点？"><a href="#3、SpringBoot有哪些缺点？" class="headerlink" title="3、SpringBoot有哪些缺点？"></a>3、SpringBoot有哪些缺点？</h3><ol>
<li>版本迭代速度快，一些模块改动很大；</li>
<li>由于无须配置，报错时很难定位；</li>
</ol>
<h3 id="151、Spring-Boot-中的监视器是什么？"><a href="#151、Spring-Boot-中的监视器是什么？" class="headerlink" title="151、Spring Boot 中的监视器是什么？"></a>151、Spring Boot 中的监视器是什么？</h3><p>监听器也叫listener，是servlet的监听器，可以用于监听web应用程序中某些对象的创建、销毁、增加、修改、删除等动作的发生，然后做出相应的响应处理。当范围对象的状态发生变化时，服务器自动调用监听器对象中的方法，常用于系统加载时进行信息初始化，统计在线人数和在线用户，统计网站的访问量。</p>
<p>配置监听器的方法：</p>
<p>通过@Component把监听器加入Spring容器中管理；<br>在application.properties中添加context.listener.classes配置；<br>在方法上加@EventListener注解；</p>
<h3 id="152、什么是-YAML？"><a href="#152、什么是-YAML？" class="headerlink" title="152、什么是 YAML？"></a>152、什么是 YAML？</h3><p>YAML是JSON的一个超集，可以非常方便地将外部配置以层次结构形式存储起来。YAML可以作为properties配置文件的替代。</p>
<p>YAML使用的注意事项：</p>
<ol>
<li>在properties文件中是以”.”进行分割的，在yml中是用”.”进行分割的；</li>
<li>yml的数据格式和json的格式很像，都是K-V格式，并且通过”:”进行赋值；</li>
<li>每个冒号后面一定要加一个空格；</li>
</ol>
<h3 id="153、如何使用-Spring-Boot-实现分页和排序？"><a href="#153、如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="153、如何使用 Spring Boot 实现分页和排序？"></a>153、如何使用 Spring Boot 实现分页和排序？</h3><p>使用Spring Data Jpa可以实现将可分页的传递给存储库方法。</p>
<h3 id="154、如何使用-Spring-Boot-实现异常处理？"><a href="#154、如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="154、如何使用 Spring Boot 实现异常处理？"></a>154、如何使用 Spring Boot 实现异常处理？</h3><p>1、使用 @ExceptionHandler 注解处理局部异常(只能处理当前controller中的ArithmeticException和NullPointerException异常，缺点就是只能处理单个controller的异常)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionHandlerController</span> &#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/excep&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exceptionMethod</span><span class="params">(Model model)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	String a=<span class="literal">null</span>;</span><br><span class="line">	System.out.println(a.charAt(<span class="number">1</span>));</span><br><span class="line">	<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">	model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;没有抛出异常&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@ExceptionHandler(value = &#123;ArithmeticException.class,NullPointerException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">arithmeticExceptionHandle</span><span class="params">(Model model, Exception e)</span> &#123;</span><br><span class="line">	model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;@ExceptionHandler&quot;</span> + e.getMessage());</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>2、使用 @ControllerAdvice + @ExceptionHandler 注解处理全局异常(value后面可以填写数组)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerAdviceException</span> &#123;<span class="meta">@ExceptionHandler(value = &#123;NullPointerException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">NullPointerExceptionHandler</span><span class="params">(Model model, Exception e)</span> &#123;</span><br><span class="line">	model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;@ControllerAdvice + @ExceptionHandler :&quot;</span> + e.getMessage());</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">                                       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>3、配置 SimpleMappingExceptionResolver 类处理异常（配置类）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMappingException</span> &#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title function_">getSimpleMappingExceptionResolver</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">SimpleMappingExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">	<span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	<span class="comment">//第一个参数为异常全限定名，第二个为跳转视图名称</span></span><br><span class="line">	mappings.put(<span class="string">&quot;java.lang.NullPointerException&quot;</span>, <span class="string">&quot;index&quot;</span>);</span><br><span class="line">	mappings.put(<span class="string">&quot;java.lang.ArithmeticException&quot;</span>, <span class="string">&quot;index&quot;</span>);</span><br><span class="line">	<span class="comment">//设置异常与视图映射信息的</span></span><br><span class="line">	resolver.setExceptionMappings(mappings);</span><br><span class="line">	<span class="keyword">return</span> resolver;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、实现 HandlerExceptionResolver 接口处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerException</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">	<span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">	modelAndView.addObject(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;实现HandlerExceptionResolver接口&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//判断不同异常类型，做不同视图跳转</span></span><br><span class="line">	<span class="keyword">if</span>(ex <span class="keyword">instanceof</span> NullPointerException)&#123;</span><br><span class="line">		modelAndView.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ex <span class="keyword">instanceof</span> ArithmeticException)&#123;</span><br><span class="line">		modelAndView.setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="155、单点登录"><a href="#155、单点登录" class="headerlink" title="155、单点登录"></a>155、单点登录</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>单点登录SSO，说的是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。</p>
<h4 id="2、单点登录的要点"><a href="#2、单点登录的要点" class="headerlink" title="2、单点登录的要点"></a>2、单点登录的要点</h4><p>存储信任；<br>验证信任；</p>
<h4 id="3、实现单点登录的三种方式"><a href="#3、实现单点登录的三种方式" class="headerlink" title="3、实现单点登录的三种方式"></a>3、实现单点登录的三种方式</h4><p>（1）以cookie作为凭证</p>
<p>最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。</p>
<p>用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie进行校验，校验通过则登录当前用户。</p>
<p>缺点：</p>
<p>cookie不安全</p>
<p>通过加密可以保证安全性，但如果对方掌握了解密算法就完蛋了。</p>
<p>不能跨域实现免登</p>
<p>（2）通过JSONP实现</p>
<p>对于跨域问题，可以使用JSONP实现。用户在父应用中登录后，跟session匹配的cookie会存到客户端中，当用户需要登录子应用的时候，授权应用访问父应用提供的JSONP接口，并在请求中带上父应用域名下的cookie，父应用接收到请求，验证用户的登录状态，返回加密的信息，子应用通过解析返回来的加密信息来验证用户，如果通过验证则登录用户。</p>
<p>缺点：</p>
<p>这种方法虽然能解决跨域问题，但是治标不治本，没有解决cookie安全性的问题。</p>
<p>（3）通过页面重定向的方式</p>
<p>最后一种介绍的方式，是通过父应用和子应用来回重定向进行通信，实现信息的安全传递。</p>
<p>父应用提供一个GET方式的登录接口A（此时的父应用接口固定，攻击者无法去伪造），用户通过子应用重定向连接的方式访问这个接口，如果用户还没有登录，则返回一个登录页面，用户输入账号密码进行登录，如果用户已经登录了，则生成加密的token，并且重定向到子应用提供的验证token的接口B（此时的子应用接口固定，攻击者无法去伪造），通过解密和校验之后，子应用登录当前用户。</p>
<p>缺点：</p>
<p>这种方式较前面的两种方式，是解决了安全性和跨域的问题，但是并没有前面两种方式简单，安全与方便，本来就是矛盾的。</p>
<h4 id="4、使用独立登录系统"><a href="#4、使用独立登录系统" class="headerlink" title="4、使用独立登录系统"></a>4、使用独立登录系统</h4><p>一般来说，大型应用会把授权的逻辑和用户信息的相关逻辑独立成一个应用，称为用户中心。用户中心不处理业务逻辑，只是处理用户信息的管理以及授权给第三方应用。第三方应用需要登录的时候，则把用户的登录请求转发给用户中心进行处理，用户处理完毕后返回凭证，第三方应用验证凭证，通过后就登录用户。</p>
<h4 id="5、sso（单点登录）与OAuth2-0（授权）的区别？"><a href="#5、sso（单点登录）与OAuth2-0（授权）的区别？" class="headerlink" title="5、sso（单点登录）与OAuth2.0（授权）的区别？"></a>5、sso（单点登录）与OAuth2.0（授权）的区别？</h4><p>（1）sso（单点登录）</p>
<p>通常处理的是一个公司的不同应用间的访问登录问题，如企业应用有很多子系统，只需登录一个系统，就可以实现不同子系统间的跳转，而避免了登录操作；<br>通过cookie、jsonp、重定向来实现；</p>
<p>（2）OAuth2.0（授权）</p>
<p>解决的是服务提供方（如微信）给第三方应用授权的问题，简称微信登录；<br>是一种具体的协议，只是为用户资源的授权提供了一个安全的、开放的而又简易的标准，OAuth2.0（授权）为客户开发者开发web应用，桌面应用程序，移动应用及客厅设备提供特定的授权流程。</p>
<h3 id="156、Spring-Boot比Spring多哪些注解"><a href="#156、Spring-Boot比Spring多哪些注解" class="headerlink" title="156、Spring Boot比Spring多哪些注解"></a>156、Spring Boot比Spring多哪些注解</h3><p><a href="https://blog.csdn.net/guorui_java/article/details/107379648">Spring Boot常用注解（绝对经典）</a></p>
<h3 id="157、打包和部署"><a href="#157、打包和部署" class="headerlink" title="157、打包和部署"></a>157、打包和部署</h3><p>Spring和Spring Boot都支持maven和Gradle通用打包管理技术。</p>
<p>Spring Boot相对Spring的一些优点：</p>
<p>提供嵌入式容器支持；<br>使用命令java -jar独立运行jar；<br>部署时可以灵活指定配置文件；<br>最近项目是分布式的项目，都是通过分项目打包部署，然后部署在docker中运行。</p>
<h3 id="158、Spring-Boot如何访问不同的数据库"><a href="#158、Spring-Boot如何访问不同的数据库" class="headerlink" title="158、Spring Boot如何访问不同的数据库"></a>158、Spring Boot如何访问不同的数据库</h3><p>可以使用druidDataSource创建DataSource，然后通过jdbcTemplate执行sql。</p>
<h3 id="159、查询网站在线人数"><a href="#159、查询网站在线人数" class="headerlink" title="159、查询网站在线人数"></a>159、查询网站在线人数</h3><p>通过监听session对象的方式来实现在线人数的统计和在线人信息展示，并且让超时的自动销毁。</p>
<blockquote>
<p>对session对象实现监听，首先必须继承HttpSessionListener类，该程序的基本原理就是当浏览器访问页面的时候必定会产生一个session对象，当关闭该页面的时候必然会删除session对象。所以每当产生一个新的session对象就让在线人数+1，当删除一个session对象就让在线人数-1。</p>
<p>还要继承一个HttpSessionAttributeListener，来实现对其属性的监听。分别实现attributeAdded方法，attributeReplace方法以及attributeRemove方法。</p>
<p>sessionCreated&#x2F;&#x2F;新建一个会话的时候触发，也可以说是客户端第一次喝服务器交互时触发。</p>
<p>sessionDestroyed&#x2F;&#x2F;销毁会话的时候，一般来说只有某个按钮触发进行销毁，或者配置定时销毁。</p>
<p>HttpSessionAttributeListener有三个方法需要实现</p>
<p>attributeAdded&#x2F;&#x2F;在session中添加对象时触发此操作 笼统的说就是调用setAttribute这个方法时候会触发的<br>attributeRemoved&#x2F;&#x2F;修改、删除session中添加对象时触发此操作  笼统的说就是调用 removeAttribute这个方法时候会触发的<br>attributeReplaced&#x2F;&#x2F;在Session属性被重新设置时。</p>
</blockquote>
<h3 id="160、easyExcel如何实现"><a href="#160、easyExcel如何实现" class="headerlink" title="160、easyExcel如何实现"></a>160、easyExcel如何实现</h3><p>异步读取<br>新建一个  ExcelModelListener 监听类出来，并且 继承 AnalysisEventListener 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zh.oukele.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.zh.oukele.model.ExcelMode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 监听器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelModelListener</span> <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;ExcelMode&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      List&lt;ExcelMode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ExcelMode&gt;();</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(ExcelMode data, AnalysisContext context)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;解析到一条数据:&#123; &quot;</span>+ data.toString() +<span class="string">&quot; &#125;&quot;</span>);</span><br><span class="line">      list.add(data);</span><br><span class="line">      count ++;</span><br><span class="line">      <span class="keyword">if</span> (list.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">          saveData( count );</span><br><span class="line">          list.clear();</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> &#123;</span><br><span class="line">       saveData( count );</span><br><span class="line">       System.out.println(<span class="string">&quot;所有数据解析完成！&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot; count ：&quot;</span> + count);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 加上存储数据库</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveData</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;&#123; &quot;</span>+ count +<span class="string">&quot; &#125;条数据，开始存储数据库！&quot;</span> + list.size());</span><br><span class="line">      System.out.println(<span class="string">&quot;存储数据库成功！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="161、什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#161、什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="161、什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>161、什么是 Swagger？你用 Spring Boot 实现了它吗？</h3><p>Swagger是用于生成RestFul Web服务的可视化表示工具，它使文档和服务器可视化更新；</p>
<p>当定义好Swagger后，可以调用服务端接口，来查看接口的返回值，验证返回数据的正确性；</p>
<h3 id="162、数据库的三范式是什么？"><a href="#162、数据库的三范式是什么？" class="headerlink" title="162、数据库的三范式是什么？"></a>162、数据库的三范式是什么？</h3><p>1、列不可再分；</p>
<p>2、每一行数据只做一件事，只与一列相关，主键；</p>
<p>3、每个属性都与主键有直接关系，而不是间接关系；</p>
<p>三大范式只是设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情结，当然要特殊对待，数据库设计最重要的是看需求和性能，需求&gt;性能&gt;表结构。</p>
<p>所以不能一味的追求三范式建立数据库。</p>
<h3 id="163、一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？"><a href="#163、一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？"></a>163、一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？</h3><p>一般情况下，我们创建的表类型是InnoDB。</p>
<p>不重启MySQL，如果新增一条记录，id是8；<br>重启，ID是6；因为InnoDB表只把自增主键的最大ID记录在内存中，如果重启，已删除的最大ID会丢失。<br>如果表类型是MyISAM，重启之后，最大ID也不会丢失，ID是8；</p>
<p>InnoDB必须有主键（建议使用自增主键，不用UUID，自增主键索引查询效率高）、支持外键、支持事务、支持行级锁。</p>
<p>系统崩溃后，MyISAM很难恢复；</p>
<p>综合考虑，优先选择InnoDB，MySQL默认也是InnoDB。</p>
<h3 id="164、如何获取当前数据库版本？"><a href="#164、如何获取当前数据库版本？" class="headerlink" title="164、如何获取当前数据库版本？"></a>164、如何获取当前数据库版本？</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>MySQL,,mysql <span class="operator">-</span>v</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>Oracle </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$version;</span><br></pre></td></tr></table></figure>

<h3 id="165、说一下-ACID-是什么？"><a href="#165、说一下-ACID-是什么？" class="headerlink" title="165、说一下 ACID 是什么？"></a>165、说一下 ACID 是什么？</h3><p>ACID是数据库事务执行的四大基本要素，包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>
<p>1、原子性</p>
<p>整个事务中的所有操作，要么全部完成，要不全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被roolback回滚到事务开始前的状态，就像这个事务从未执行过一样。</p>
<p>2、一致性</p>
<p>事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。</p>
<p>3、隔离性</p>
<p>隔离状态执行事务，使他们好像是系统在给定时间内执行的唯一操作。</p>
<p>如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性确保每一个事务在系统中认为只有自己在使用系统。这种属性称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p>
<p>4、持久性</p>
<p>一个成功的事务将永久的改变系统的状态。</p>
<h3 id="166、char-和-varchar-的区别是什么？"><a href="#166、char-和-varchar-的区别是什么？" class="headerlink" title="166、char 和 varchar 的区别是什么？"></a>166、char 和 varchar 的区别是什么？</h3><ol>
<li>char的长度是固定的，varchar的长度的可变的；</li>
<li>char的效率比varchar的效率高；</li>
<li>char占用空间比varchar大，char在查询时需要使用trim；</li>
</ol>
<h3 id="167、float-和-double-的区别是什么？"><a href="#167、float-和-double-的区别是什么？" class="headerlink" title="167、float 和 double 的区别是什么？"></a>167、float 和 double 的区别是什么？</h3><p>1、float 和 double 的区别是什么？</p>
<p>（1）内存中占有的字节数不同</p>
<p>单精度浮点数在内存中占有4个字节；</p>
<p>双精度浮点数在内存中占有8个字节；</p>
<p>（2）有效数字位数不同</p>
<p>单精度浮点数有效数字8位；</p>
<p>双精度浮点数有效数字16位；</p>
<p>（3）数值取值范围不同</p>
<p>单精度浮点数的表示范围：-3.40E+38~3.40E+38</p>
<p>双精度浮点数的表示范围：-1.79E+308~-1.79E+308</p>
<p>（4）在程序中处理速度不同</p>
<p>一般来说，CPU处理单精度浮点数的速度比双精度浮点数的速度快</p>
<p>如果不声明，默认小数是double类型，如果想用float，要进行强转；</p>
<p>2、例如</p>
<p>float f &#x3D; 1.3；会编译报错，正确的写法是float f &#x3D; (float)1.3;或者float a &#x3D; 1.3f;（f或F都可以不区分大小写）</p>
<p>3、注意</p>
<p>float是八位有效数字，第七位会四舍五入；</p>
<p>4、面试题</p>
<p>（1）java中3*0.1&#x3D;&#x3D;0.3将会返回什么？true还是false？</p>
<p>答：返回false，因为浮点数不能完全精确的表示出来，一般会损失精度；</p>
<p>（2）java中float f &#x3D; 3.4;是否正确？</p>
<p>答：不正确。因为3.4是双精度浮点数，将双精度赋给单精度属于向下转型，会造成精度损失，因此需要强制类型转换float&#x3D;（float）3.4;或者写成float f &#x3D; 3.4f;</p>
<h3 id="168、Oracle分页sql"><a href="#168、Oracle分页sql" class="headerlink" title="168、Oracle分页sql"></a>168、Oracle分页sql</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#不带排序的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> ROWNUM <span class="keyword">AS</span> rowno, t.<span class="operator">*</span> <span class="keyword">FROM</span> worker t <span class="keyword">where</span> ROWNUM <span class="operator">&lt;=</span><span class="number">20</span>) table_alias </span><br><span class="line"><span class="keyword">WHERE</span> table_alias.rowno <span class="operator">&gt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#带排序的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> tt.<span class="operator">*</span>, ROWNUM <span class="keyword">AS</span> rowno <span class="keyword">FROM</span> (  </span><br><span class="line"><span class="keyword">SELECT</span> t.<span class="operator">*</span> <span class="keyword">FROM</span> worker t <span class="keyword">ORDER</span> <span class="keyword">BY</span> wkid <span class="keyword">aSC</span>) tt <span class="keyword">WHERE</span> ROWNUM <span class="operator">&lt;=</span> <span class="number">20</span>) table_alias </span><br><span class="line"><span class="keyword">WHERE</span> table_alias.rowno <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="169、数据库如何保证主键唯一性"><a href="#169、数据库如何保证主键唯一性" class="headerlink" title="169、数据库如何保证主键唯一性"></a>169、数据库如何保证主键唯一性</h3><p>1、主键约束</p>
<p>主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）；</p>
<p>2、唯一性约束</p>
<p>保证一个字段或者一组字段里的数据都与表中其它行的对应数据不同。和主键约束不同，唯一性约束允许为null，但是只能有一行；</p>
<p>3、唯一性索引</p>
<p>不允许具有索引值相同的行，从而禁止重复的索引和键值；</p>
<p>4、三者的区别</p>
<p>约束是用来检查数据的正确性；<br>索引是用来优化查询的；<br>创建唯一性约束会创建一个约束和一个唯一性索引；<br>创建唯一性索引只会创建一个唯一性索引；<br>主键约束和唯一性约束都会创建一个唯一性索引。</p>
<h3 id="170、如何设计数据库"><a href="#170、如何设计数据库" class="headerlink" title="170、如何设计数据库"></a>170、如何设计数据库</h3><p>1、数据库设计最起码要占用这个项目开发的40%以上的时间</p>
<p>2、数据库设计不仅仅停留在页面demo的表面</p>
<p>页面内容所需字段，在数据库设计中只是一部分，还有系统运转、模块交互、中转数据、表之间的联系等等所需要的字段，因此数据库设计绝对不是简单的基本数据存储，还有逻辑数据存储。</p>
<p>3、数据库设计完成后，项目80%的设计开发都要存在你的脑海中</p>
<p>每个字段的设计都要有他存在的意义，要清楚的知道程序中如何去运用这些字段，多张表的联系在程序中是如何体现的。</p>
<p>4、数据库设计时就要考虑效率和优化问题</p>
<p>数据量大的表示粗粒度的，会冗余一些必要字段，达到用最少的表，最弱的表关系去存储海量的数据。大数据的表要建立索引，方便查询。对于含有计算、数据交互、统计这类需求时，还有考虑是否有必要采用存储过程。</p>
<p>5、添加必要的冗余字段</p>
<p>像创建时间、修改时间、操作用户IP、备注这些字段，在每张表中最好都有，一些冗余的字段便于日后维护、分析、拓展而添加。</p>
<p>6、设计合理的表关联 </p>
<p>若两张表之间的关系复杂，建议采用第三张映射表来关联维护两张表之间的关系，以降低表之间的直接耦合度。</p>
<p>7、设计表时不加主外键等约束关联，系统编码阶段完成后再添加约束性关联</p>
<p>8、选择合适的主键生成策略</p>
<p>数据库的设计难度其实比单纯的技术实现难很多，他充分体现了一个人的全局设计能力和掌控能力，最后说一句，数据库设计，很重要，很复杂。</p>
<h3 id="171、性别是否适合做索引"><a href="#171、性别是否适合做索引" class="headerlink" title="171、性别是否适合做索引"></a>171、性别是否适合做索引</h3><p>区分度不高的字段不适合做索引，因为索引页是需要有开销的，需要存储的，不过这类字段可以做联合索引的一部分。</p>
<h3 id="172、如何查询重复的数据"><a href="#172、如何查询重复的数据" class="headerlink" title="172、如何查询重复的数据"></a>172、如何查询重复的数据</h3><p>1、查询重复的单个字段（group by）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 重复字段A, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表 <span class="keyword">group</span> <span class="keyword">by</span> 重复字段A <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>2、查询重复的多个字段（group by）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 重复字段A, 重复字段B, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> 表 <span class="keyword">group</span> <span class="keyword">by</span> 重复字段A, 重复字段B <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="173、数据库一般会采取什么样的优化方法？"><a href="#173、数据库一般会采取什么样的优化方法？" class="headerlink" title="173、数据库一般会采取什么样的优化方法？"></a>173、数据库一般会采取什么样的优化方法？</h3><p>1、选取适合的字段属性</p>
<ul>
<li>为了获取更好的性能，可以将表中的字段宽度设得尽可能小。</li>
<li>尽量把字段设置成not null</li>
<li>执行查询的时候，数据库不用去比较null值。</li>
<li>对某些省份或者性别字段，将他们定义为enum类型，enum类型被当做数值型数据来处理，而数值型数据被处理起来的速度要比文本类型块很多。</li>
</ul>
<p>2、使用join连接代替子查询</p>
<p>3、使用联合union来代替手动创建的临时表</p>
<p>注意：union用法中，两个select语句的字段类型要匹配，而且字段个数要相同。</p>
<p>4、事务</p>
<p>要么都成功，要么都失败。</p>
<p>可以保证数据库中数据的一致性和完整性。事务以begin开始，commit关键字结束。</p>
<p>如果出错，rollback命令可以将数据库恢复到begin开始之前的状态。</p>
<p>事务的另一个重要作用是当多个用户同时使用相同的数据源时，它可以利用锁定数据库的方式为用户提供一种安全的访问方式，这样就可以保证用户的操作不被其他的用户干扰。</p>
<p>5、锁定表</p>
<p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在大应用中。</p>
<p>由于在事务执行的过程中，数据库会被锁定，因此其它用户只能暂时等待直到事务结束。</p>
<p>有的时候可以用锁定表的方法来获得更好的性能，</p>
<p>共享锁：其它用户只能看，不能修改</p>
<p>lock table person in share mode；</p>
<p>对于通过lock table 命令主动添加的锁来说，如果要释放它们，只需发出rollback命令即可。</p>
<p>6、使用外键</p>
<p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性，这个时候可以使用外键。</p>
<p>7、使用索引</p>
<p>索引是提高数据库查询速度的常用方法，尤其是查询语句中包含max()、min()、order by这些命令的时候，性能提高更为显著。</p>
<p>一般来说索引应该建在常用于join、where、order by的字段上。尽量不要对数据库中含有大量重复的值得字段建立索引。</p>
<p>8、优化的查询语句</p>
<p>在索引的字段上尽量不要使用函数进行操作。</p>
<p>尽量不要使用like关键字和通配符，这样做法很简单，但却是以牺牲性能为代价的。</p>
<p>避免在查询中进行自动类型转换，因为类型转换也会使索引失效。</p>
<h3 id="174、索引怎么定义，分哪几种"><a href="#174、索引怎么定义，分哪几种" class="headerlink" title="174、索引怎么定义，分哪几种"></a>174、索引怎么定义，分哪几种</h3><ol>
<li>b-tree索引，如果不建立索引的情况下，oracle就自动给每一列都加一个B 树索引;</li>
<li>normal：普通索引</li>
<li>unique：唯一索引</li>
<li>bitmap：位图索引，位图索引特定于只有几个枚举值的情况，比如性别字段；</li>
<li>基于函数的索引</li>
</ol>
<h3 id="175、mysql-的内连接、左连接、右连接有什么区别？"><a href="#175、mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="175、mysql 的内连接、左连接、右连接有什么区别？"></a>175、mysql 的内连接、左连接、右连接有什么区别？</h3><ol>
<li>内连接,显示两个表中有联系的所有数据;</li>
<li>左链接,以左表为参照,显示所有数据,右表中没有则以null显示</li>
<li>右链接,以右表为参照显示数据，,左表中没有则以null显示</li>
</ol>
<h3 id="176、RabbitMQ的使用场景有哪些？"><a href="#176、RabbitMQ的使用场景有哪些？" class="headerlink" title="176、RabbitMQ的使用场景有哪些？"></a>176、RabbitMQ的使用场景有哪些？</h3><p>1、解决异步问题</p>
<p>例如用户注册，发送邮件和短信反馈注册成功，可以使用RabbitMQ消息队列，用户无需等待反馈。</p>
<p>2、服务间解耦</p>
<p>订单系统和库存系统，中间加入RabbitMQ消息队列，当库存系统出现问题时，订单系统依旧能正常使用，降低服务间耦合度。</p>
<p>3、秒杀系统</p>
<p>利用RabbitMQ的最大值，实现秒杀系统。</p>
<h3 id="177、RabbitMQ有哪些重要的角色？有哪些重要的组件？"><a href="#177、RabbitMQ有哪些重要的角色？有哪些重要的组件？" class="headerlink" title="177、RabbitMQ有哪些重要的角色？有哪些重要的组件？"></a>177、RabbitMQ有哪些重要的角色？有哪些重要的组件？</h3><p>1、RabbitMQ有哪些重要的角色？</p>
<p>客户端、RabbitMQ、服务端。</p>
<p>2、有哪些重要的组件？</p>
<p>（1）connectionFactory（连接管理器）</p>
<p>应用程序与RabbitMQ之间建立连接的管理器。</p>
<p>（2）Channel（信道）</p>
<p>消息推送使用的信道。</p>
<p>（3）RoutingKey（路由键）</p>
<p>用于把生产者的数据分配到交换机上。</p>
<p>（4）Exchange（交换机）</p>
<p>用于接受和分配消息。</p>
<p>（5）BindKey（绑定键）</p>
<p>用于把交换机的消息绑定到队列上</p>
<p>（6）Queue（队列）</p>
<p>用于存储生产者消息。</p>
<h3 id="178、RabbitMQ中-vhost-的作用是什么？"><a href="#178、RabbitMQ中-vhost-的作用是什么？" class="headerlink" title="178、RabbitMQ中 vhost 的作用是什么？"></a>178、RabbitMQ中 vhost 的作用是什么？</h3><p>vhost可以理解为mini版的RabbitMQ，其内部均含有独立的交换机、绑定、队列，最重要的是拥有独立的权限系统，可以做到vhost范围内的用户控制。从RabbitMQ全局考虑，不同的应用可以跑在不同的vhost上，作为不同权限隔离的手段。</p>
<h3 id="179、说一下-jvm-的主要组成部分？及其作用？"><a href="#179、说一下-jvm-的主要组成部分？及其作用？" class="headerlink" title="179、说一下 jvm 的主要组成部分？及其作用？"></a>179、说一下 jvm 的主要组成部分？及其作用？</h3><p>JVM包括类加载子系统、堆、方法区、栈、本地方法栈、程序计数器、直接内存、垃圾回收器、执行引擎。</p>
<p>1、类加载子系统</p>
<p>类加载子系统负责加载class信息，加载的类信息存放于方法区中。</p>
<p>2、直接内存</p>
<p>直接内存是在Java堆外的、直接向系统申请的内存空间。访问直接内存的速度会由于Java堆。出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。</p>
<p>3、垃圾回收器</p>
<p>垃圾回收器可以对堆、方法区、直接内存进行回收。</p>
<p>4、执行引擎</p>
<p>执行引擎负责执行虚拟机的字节码，虚拟机会使用即时编译技术将方法编译成机器码后再执行。</p>
<h3 id="180、说一下-jvm-运行时数据区？"><a href="#180、说一下-jvm-运行时数据区？" class="headerlink" title="180、说一下 jvm 运行时数据区？"></a>180、说一下 jvm 运行时数据区？</h3><p>运行时数据区包括堆、方法区、栈、本地方法栈、程序计数器。</p>
<p>1、堆</p>
<p>堆解决的是对象实例存储的问题，垃圾回收器管理的主要区域。</p>
<p>2、方法区</p>
<p>方法区可以认为是堆的一部分，用于存储已被虚拟机加载的信息，常量、静态变量、即时编译器编译后的代码。</p>
<p>3、栈</p>
<p>栈解决的是程序运行的问题，栈里面存的是栈帧，栈帧里面存的是局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>（1）栈帧</p>
<p>每个方法从调用到执行的过程就是一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>（2）局部变量表</p>
<p>用于保存函数的参数和局部变量。</p>
<p>（3）操作数栈</p>
<p>操作数栈又称操作栈，大多数指令都是从这里弹出数据，执行运算，然后把结果压回操作数栈。</p>
<p>4、本地方法栈</p>
<p>与栈功能相同，本地方法栈执行的是本地方法，一个Java调用非Java代码的接口。</p>
<p>5、程序计数器（PC寄存器）</p>
<p>程序计数器中存放的是当前线程所执行的字节码的行数。JVM工作时就是通过改变这个计数器的值来选取下一个需要执行的字节码指令。</p>
<h3 id="181、什么是类加载器，类加载器有哪些？"><a href="#181、什么是类加载器，类加载器有哪些？" class="headerlink" title="181、什么是类加载器，类加载器有哪些？"></a>181、什么是类加载器，类加载器有哪些？</h3><p><a href="https://imgtu.com/i/jVqiLR"><img src="https://s1.ax1x.com/2022/06/27/jVqiLR.jpg" alt="jVqiLR.jpg"></a></p>
<p>1、什么是类加载器？</p>
<p>类加载器负责加载所有的类，其为所有被载入内存的类生成一个java.lang.Class实例对象。</p>
<p>2、类加载器有哪些？</p>
<p>JVM有三种类加载器：</p>
<p>（1）启动类加载器</p>
<p>该类没有父加载器，用来加载Java的核心类，启动类加载器的实现依赖于底层操作系统，属于虚拟机实现的一部分，它并不继承自java.lang.classLoader。</p>
<p>（2）扩展类加载器</p>
<p>它的父类为启动类加载器，扩展类加载器是纯java类，是ClassLoader类的子类，负责加载JRE的扩展目录。</p>
<p>（3）应用程序类加载器</p>
<p>它的父类为扩展类加载器，它从环境变量classpath或者系统属性java.lang.path所指定的目录中加载类，它是自定义的类加载器的父加载器。</p>
<h3 id="182、说一下类加载的执行过程？"><a href="#182、说一下类加载的执行过程？" class="headerlink" title="182、说一下类加载的执行过程？"></a>182、说一下类加载的执行过程？</h3><p>当程序主动使用某个类时，如果该类还未被加载到内存中，JVM会通过加载、连接、初始化3个步骤对该类进行类加载。</p>
<p>1、加载</p>
<p>加载指的是将类的class文件读入到内存中，并为之创建一个java.lang.Class对象。</p>
<p>类的加载由类加载器完成，类加载器由JVM提供，开发者也可以通过继承ClassLoader基类来创建自己的类加载器。</p>
<p>通过使用不同的类加载器可以从不同来源加载类的二进制数据，通常有如下几种来源：</p>
<ol>
<li>从本地文件系统加载</li>
<li>从jar包加载</li>
<li>通过网络加载</li>
<li>把一个Java源文件动态编译，并执行加载</li>
</ol>
<p>2、连接</p>
<p>当类被加载之后，系统为之生成一个对应的Class对象，接着进入连接阶段，连接阶段负责将类的二进制数据合并到JRE中。</p>
<p>类连接又可分为三个阶段：</p>
<p>（1）验证</p>
<p>文件格式验证<br>元数据验证<br>字节码验证<br>符号引用验证</p>
<p>（2）准备</p>
<p>为类的静态变量分配内存，并设置默认初始值。</p>
<p>（3）解析</p>
<p>将类的二进制数据中的符号引用替换成直接引用。</p>
<p>3、初始化</p>
<p>为类的静态变量赋予初始值。</p>
<h3 id="183、JVM的类加载机制是什么？"><a href="#183、JVM的类加载机制是什么？" class="headerlink" title="183、JVM的类加载机制是什么？"></a>183、JVM的类加载机制是什么？</h3><p>JVM类加载机制主要有三种：</p>
<p>1、全盘负责</p>
<p>类加载器加载某个class时，该class所依赖的和引用其它的class也由该类加载器载入。</p>
<p>2、双亲委派</p>
<p>先让父加载器加载该class，父加载器无法加载时才考虑自己加载。</p>
<p>3、缓存机制</p>
<p>缓存机制保证所有加载过的class都会被缓存，当程序中需要某个class时，先从缓存区中搜索，如果不存在，才会读取该类对应的二进制数据，并将其转换成class对象，存入缓存区中。</p>
<p>这就是为什么修改了class后，必须重启JVM，程序所做的修改才会生效的原因。</p>
<h3 id="184、什么是双亲委派模型？"><a href="#184、什么是双亲委派模型？" class="headerlink" title="184、什么是双亲委派模型？"></a>184、什么是双亲委派模型？</h3><p>如果一个类收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器执行，如果父加载器还存在其父加载器，则进一步向上委托，依次递归，请求将最终到达顶层的启动类加载器，如果父类加载器可以完成父加载任务，就成功返回，如果父加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模型。</p>
<p>双亲委派模式的优势：</p>
<ol>
<li>避免重复加载；</li>
<li>考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委派模式传递到启动加载器，而启动加载器在核心Java API中发现同名的类，发现该类已经被加载，就不会重新加载网络传递的Integer类，而直接返回已加载过的Integer.class，这样可以防止核心API库被随意篡改。</li>
</ol>
<h3 id="185、怎么判断对象是否可以被回收？"><a href="#185、怎么判断对象是否可以被回收？" class="headerlink" title="185、怎么判断对象是否可以被回收？"></a>185、怎么判断对象是否可以被回收？</h3><p>1、引用计数算法</p>
<p>（1）判断对象的引用数量</p>
<p>通过判断对象的引用数量来决定对象是否可以被回收；<br>每个对象实例都有一个引用计数器，被引用+1，完成引用-1；<br>任何引用计数为0的对象实例可以被当做垃圾回收；</p>
<p>（2）优缺点</p>
<p>优点：执行效率高，程序受影响较小；<br>缺点：无法检测出循环引用的情况，导致内存泄漏；</p>
<p>2、可达性分析算法</p>
<p>通过判断对象的引用链是否可达来决定对象是否可以被回收。</p>
<p>如果程序无法再引用该对象，那么这个对象肯定可以被回收，这个状态称为不可达。</p>
<p>那么不可达状态如何判断呢？</p>
<p>答案是GC roots，也就是根对象，如果一个对象无法到达根对象的路径，或者说从根对象无法引用到该对象，该对象就是不可达的。</p>
<p>以下三种对象在JVM中被称为GC roots，来判断一个对象是否可以被回收。</p>
<p>（1）虚拟机栈的栈帧</p>
<p>每个方法在执行的时候，JVM都会创建一个相应的栈帧（操作数栈、局部变量表、运行时常量池的引用），当方法执行完，该栈帧就从栈中弹出，这样一来，方法中临时创建的独享就不存在了，或者说没有任何GC roots指向这些临时对象，这些对象在下一次GC的时候便会被回收。</p>
<p>（2）方法区中的静态属性</p>
<p>静态属性数据类属性，不属于任何实例，因此该属性自然会作为GC roots。这要这个class在，该引用指向的对象就一直存在，class也由被回收的时候。</p>
<p>class何时会被回收？</p>
<p>堆中不存在该类的任何实例<br>加载该类的classLoader已经被回收<br>该类的java.lang.class对象没有在任何地方被引用，也就是说无法通过反射访问该类的信息<br>（3）本地方法栈引用的对象</p>
<h3 id="186、说一下-jvm-有哪些垃圾回收算法？"><a href="#186、说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="186、说一下 jvm 有哪些垃圾回收算法？"></a>186、说一下 jvm 有哪些垃圾回收算法？</h3><p>1、对象是否已死算法</p>
<ul>
<li>引用计数器算法</li>
<li>可达性分析算法</li>
</ul>
<p>2、GC算法</p>
<p>（1）标记清除算法</p>
<p>如果对象被标记后进行清除，会带来一个新的问题–内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收。</p>
<p>（2）复制算法（Java堆中新生代的垃圾回收算法）</p>
<ol>
<li>先标记待回收内存和不用回收内存；</li>
<li>将不用回收的内存复制到新的内存区域；</li>
<li>就的内存区域就可以被全部回收了，而新的内存区域也是连续的；</li>
</ol>
<p>缺点是损失部分系统内存，因为腾出部分内存进行复制。</p>
<p>（3）标记压缩算法（Java堆中老年代的垃圾回收算法）</p>
<p>对于新生代，大部分对象都不会存活，所以复制算法较高效，但对于老年代，大部分对象可能要继续存活，如果此时使用复制算法，效率会降低。</p>
<p>标记压缩算法首先还是标记，将不用回收的内存对象压缩到内存一端，此时即可清除边界处的内存，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。</p>
<p>老年代的垃圾回收算法称为“Major GC”。</p>
<p>187、说一下 jvm 有哪些垃圾回收器？<br><a href="https://blog.csdn.net/guorui_java/article/details/108405844">说一下 jvm 有哪些垃圾回收器？</a></p>
<p>188、JVM栈堆概念，何时销毁对象</p>
<ol>
<li>类在程序运行的时候就会被加载，方法是在执行的时候才会被加载，如果没有任何引用了，Java自动垃圾回收，也可以用System.gc()开启回收器，但是回收器不一定会马上回收。</li>
<li>静态变量在类装载的时候进行创建，在整个程序结束时按序销毁；</li>
<li>实例变量在类实例化对象时创建，在对象销毁的时候销毁；</li>
<li>局部变量在局部范围内使用时创建，跳出局部范围时销毁；</li>
</ol>
<h3 id="189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>189、新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>新生代回收器一般采用的是复制算法，复制算法效率较高，但是浪费内存；</p>
<p>老生代回收器一般采用标记清楚算法，比如最常用的CMS；</p>
<h3 id="190、详细介绍一下-CMS-垃圾回收器？"><a href="#190、详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="190、详细介绍一下 CMS 垃圾回收器？"></a>190、详细介绍一下 CMS 垃圾回收器？</h3><p>CMS 垃圾回收器是Concurrent Mark Sweep，是一种同步的标记-清除，CMS分为四个阶段：</p>
<p>初始标记，标记一下GC Root能直接关联到的对象，会触发“Stop The World”；<br>并发标记，通过GC Roots Tracing判断对象是否在使用中；<br>重新标记，标记期间产生对象的再次判断，执行时间较短，会触发“Stop The World”；<br>并发清除，清除对象，可以和用户线程并发进行；</p>
<h3 id="191、简述分代垃圾回收器是怎么工作的？"><a href="#191、简述分代垃圾回收器是怎么工作的？" class="headerlink" title="191、简述分代垃圾回收器是怎么工作的？"></a>191、简述分代垃圾回收器是怎么工作的？</h3><p>分代回收器分为新生代和老年代，新生代大概占1&#x2F;3，老年代大概占2&#x2F;3；</p>
<p>新生代包括Eden、From Survivor、To Survivor；</p>
<p>Eden区和两个survivor区的 的空间比例 为8：1：1 ；</p>
<p>垃圾回收器的执行流程：</p>
<p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden + From Survivor 分区，From Survivor 和 To Survivor 分区交换；<br>每次交换后存活的对象年龄+1，到达15，升级为老年代，大对象会直接进入老年代；<br>老年代中当空间到达一定占比，会触发全局回收，老年代一般采取标记-清除算法；</p>
<h3 id="192、Redis是什么？"><a href="#192、Redis是什么？" class="headerlink" title="192、Redis是什么？"></a>192、Redis是什么？</h3><p>Redis是一个key-value存储系统，它支持存储的value类型相对更多，包括string、list、set、zset（sorted set –有序集合）和hash。这些数据结构都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中，Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。</p>
<h3 id="193、Redis都有哪些使用场景？"><a href="#193、Redis都有哪些使用场景？" class="headerlink" title="193、Redis都有哪些使用场景？"></a>193、Redis都有哪些使用场景？</h3><ol>
<li>Redis是基于内存的nosql数据库，可以通过新建线程的形式进行持久化，不影响Redis单线程的读写操作</li>
<li>通过list取最新的N条数据</li>
<li>模拟类似于token这种需要设置过期时间的场景</li>
<li>发布订阅消息系统</li>
<li>定时器、计数器</li>
</ol>
<p>194、Redis有哪些功能？<br>1、基于本机内存的缓存</p>
<p>当调用api访问数据库时，假如此过程需要2秒，如果每次请求都要访问数据库，那将对服务器造成巨大的压力，如果将此sql的查询结果存到Redis中，再次请求时，直接从Redis中取得，而不是访问数据库，效率将得到巨大的提升，Redis可以定时去更新数据（比如1分钟）。</p>
<p>2、如果电脑重启，写入内存的数据是不是就失效了呢，这时Redis还提供了持久化的功能。</p>
<p>3、哨兵（Sentinel）和复制</p>
<p>Sentinel可以管理多个Redis服务器，它提供了监控、提醒以及自动的故障转移功能；</p>
<p>复制则是让Redis服务器可以配备备份的服务器；</p>
<p>Redis也是通过这两个功能保证Redis的高可用；</p>
<p>4、集群（Cluster）</p>
<p>单台服务器资源总是有上限的，CPU和IO资源可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上，但是内存资源怎么办，主从模式只是数据的备份，并不能扩充内存；</p>
<p>现在我们可以横向扩展，让每台服务器只负责一部分任务，然后将这些服务器构成一个整体，对外界来说，这一组服务器就像是集群一样。</p>
<h3 id="195、Redis支持的数据类型有哪些？"><a href="#195、Redis支持的数据类型有哪些？" class="headerlink" title="195、Redis支持的数据类型有哪些？"></a>195、Redis支持的数据类型有哪些？</h3><ol>
<li>字符串</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>zset</li>
</ol>
<h3 id="196、Redis取值存值问题"><a href="#196、Redis取值存值问题" class="headerlink" title="196、Redis取值存值问题"></a>196、Redis取值存值问题</h3><p>1、先把Redis的连接池拿出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(<span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>(),<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource();</span><br></pre></td></tr></table></figure>

<p>2、存取值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">jedis.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">jedis.del(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">//给一个key叠加value</span></span><br><span class="line">jedis.append(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value2&quot;</span>);<span class="comment">//此时key的值就是value + value2;</span></span><br><span class="line"><span class="comment">//同时给多个key进行赋值：</span></span><br><span class="line">jedis.mset(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>3、对map进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; user = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">user.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">user.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line"><span class="comment">//存入</span></span><br><span class="line">jedis.hmset(<span class="string">&quot;user&quot;</span>,user);</span><br><span class="line"><span class="comment">//取出user中key1 </span></span><br><span class="line">List&lt;String&gt; nameMap = jedis.hmget(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"><span class="comment">//删除其中一个键值</span></span><br><span class="line">jedis.hdel(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;key2&quot;</span>);</span><br><span class="line"><span class="comment">//是否存在一个键</span></span><br><span class="line">jedis.exists(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="comment">//取出所有的Map中的值：</span></span><br><span class="line">Iterator&lt;String&gt; iter = jedis.hkeys(<span class="string">&quot;user&quot;</span>).iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.next())&#123;</span><br><span class="line">    jedis.hmget(<span class="string">&quot;user&quot;</span>,iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="197、Redis为什么是单线程的？"><a href="#197、Redis为什么是单线程的？" class="headerlink" title="197、Redis为什么是单线程的？"></a>197、Redis为什么是单线程的？</h3><ol>
<li>代码更清晰，处理逻辑更简单；</li>
<li>不用考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能问题；</li>
<li>不存在多线程切换而消耗CPU；</li>
<li>无法发挥多核CPU的优势，但可以采用多开几个Redis实例来完善；</li>
</ol>
<h3 id="198、Redis真的是单线程的吗？"><a href="#198、Redis真的是单线程的吗？" class="headerlink" title="198、Redis真的是单线程的吗？"></a>198、Redis真的是单线程的吗？</h3><p>Redis6.0之前是单线程的，Redis6.0之后开始支持多线程；<br>redis内部使用了基于<a href="https://baike.baidu.com/item/epoll/10738144?fr=aladdin">epoll</a>的多路服用，也可以多部署几个redis服务器解决单线程的问题；<br>redis主要的性能瓶颈是内存和网络；<br>内存好说，加内存条就行了，而网络才是大麻烦，所以redis6内存好说，加内存条就行了；<br>而网络才是大麻烦，所以redis6.0引入了多线程的概念，<br>redis6.0在网络IO处理方面引入了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。</p>
<h3 id="199、Redis持久化有几种方式？"><a href="#199、Redis持久化有几种方式？" class="headerlink" title="199、Redis持久化有几种方式？"></a>199、Redis持久化有几种方式？</h3><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p>
<p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</p>
<p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p>
<p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p>
<p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p>
<h3 id="200、Redis和-memecache-有什么区别？"><a href="#200、Redis和-memecache-有什么区别？" class="headerlink" title="200、Redis和 memecache 有什么区别？"></a>200、Redis和 memecache 有什么区别？</h3><p>1、Redis相比memecache，拥有更多的数据结构和支持更丰富的数据操作。</p>
<p>（1）Redis支持key-value，常用的数据类型主要有String、Hash、List、Set、Sorted Set。</p>
<p>（2）memecache只支持key-value。</p>
<p>2、内存使用率对比，Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于memecache。</p>
<p>3、性能对比：Redis只使用单核，memecache使用多核。</p>
<p>4、Redis支持磁盘持久化，memecache不支持。</p>
<p>Redis可以将一些很久没用到的value通过swap方法交换到磁盘。</p>
<p>5、Redis支持分布式集群，memecache不支持。</p>
<h3 id="201、Redis支持的-java-客户端都有哪些？"><a href="#201、Redis支持的-java-客户端都有哪些？" class="headerlink" title="201、Redis支持的 java 客户端都有哪些？"></a>201、Redis支持的 java 客户端都有哪些？</h3><p>Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。</p>
<h3 id="202、jedis-和-redisson-有哪些区别？"><a href="#202、jedis-和-redisson-有哪些区别？" class="headerlink" title="202、jedis 和 redisson 有哪些区别？"></a>202、jedis 和 redisson 有哪些区别？</h3><p>Jedis 和 Redisson 都是Java中对Redis操作的封装。Jedis 只是简单的封装了 Redis 的API库，可以看作是Redis客户端，它的方法和Redis 的命令很类似。Redisson 不仅封装了 redis ，还封装了对更多数据结构的支持，以及锁等功能，相比于Jedis 更加大。但Jedis相比于Redisson 更原生一些，更灵活。</p>
<h3 id="203、Redis中什么是缓存穿透？怎么解决？"><a href="#203、Redis中什么是缓存穿透？怎么解决？" class="headerlink" title="203、Redis中什么是缓存穿透？怎么解决？"></a>203、Redis中什么是缓存穿透？怎么解决？</h3><p>1、缓存穿透</p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对用的value，就应该去后端系统查找（比如DB数据库）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p>2、怎么解决？</p>
<p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。</p>
<p>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该Bitmap过滤。</p>
<h3 id="204、怎么保证缓存和数据库数据的一致性？"><a href="#204、怎么保证缓存和数据库数据的一致性？" class="headerlink" title="204、怎么保证缓存和数据库数据的一致性？"></a>204、怎么保证缓存和数据库数据的一致性？</h3><p>1、淘汰缓存</p>
<p>数据如果为较为复杂的数据时，进行缓存的更新操作就会变得异常复杂，因此一般推荐选择淘汰缓存，而不是更新缓存。</p>
<p>2、选择先淘汰缓存，再更新数据库</p>
<p>假如先更新数据库，再淘汰缓存，如果淘汰缓存失败，那么后面的请求都会得到脏数据，直至缓存过期。</p>
<p>假如先淘汰缓存再更新数据库，如果更新数据库失败，只会产生一次缓存穿透，相比较而言，后者对业务则没有本质上的影响。</p>
<p>3、延时双删策略</p>
<p>如下场景：同时有一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>次数便出现了数据不一致问题。采用延时双删策略得以解决:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String key,Object data)</span>&#123;</span><br><span class="line">    redisUtils.del(key);</span><br><span class="line">    db.update(data);</span><br><span class="line">    Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">    redisUtils.del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。这个时间设定可根据俄业务场景进行一个调节。</p>
<p>4、数据库读写分离的场景</p>
<p>两个请求，一个请求A进行更新操作，另一个请求B进行查询操作：</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求A将数据写入数据库了</li>
<li>请求B查询缓存发现，缓存没有值</li>
<li>请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</li>
<li>请求B将旧值写入缓存</li>
<li>数据库完成主从同步，从库变为新值</li>
</ol>
<p>依旧采用延时双删策略解决此问题。</p>
<h3 id="205、Redis中什么是缓存雪崩？怎么解决？"><a href="#205、Redis中什么是缓存雪崩？怎么解决？" class="headerlink" title="205、Redis中什么是缓存雪崩？怎么解决？"></a>205、Redis中什么是缓存雪崩？怎么解决？</h3><p>1、缓存雪崩</p>
<p>当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，会给后端系统带来很大的压力，导致系统崩溃。</p>
<p>2、如何解决？</p>
<ol>
<li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其它线程等待；</li>
<li>做二级缓存；</li>
<li>不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀；</li>
</ol>
<h3 id="206、Redis怎么实现分布式锁？"><a href="#206、Redis怎么实现分布式锁？" class="headerlink" title="206、Redis怎么实现分布式锁？"></a>206、Redis怎么实现分布式锁？</h3><p>使用Redis实现分布式锁</p>
<p>redis命令：set users 10 nx ex 12   原子性命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用uuid，解决锁释放的问题</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b_lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(b_lock)&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>,++num);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lockUUID</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(uuid.equals(lockUUID.toString()))&#123;</span><br><span class="line">            redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        testLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>备注：可以通过lua脚本，保证分布式锁的原子性。</p>
<h3 id="207、Redis分布式锁有什么缺陷？"><a href="#207、Redis分布式锁有什么缺陷？" class="headerlink" title="207、Redis分布式锁有什么缺陷？"></a>207、Redis分布式锁有什么缺陷？</h3><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<p>Redis容易产生的几个问题：</p>
<ol>
<li>锁未被释放</li>
<li>B锁被A锁释放了</li>
<li>数据库事务超时</li>
<li>锁过期了，业务还没执行完</li>
<li>Redis主从复制的问题</li>
</ol>
<h3 id="208、Redis如何做内存优化？"><a href="#208、Redis如何做内存优化？" class="headerlink" title="208、Redis如何做内存优化？"></a>208、Redis如何做内存优化？</h3><p>1、缩短键值的长度</p>
<ol>
<li>缩短值的长度才是关键，如果值是一个大的业务对象，可以将对象序列化成二进制数组；</li>
<li>首先应该在业务上进行精简，去掉不必要的属性，避免存储一些没用的数据；</li>
<li>其次是序列化的工具选择上，应该选择更高效的序列化工具来降低字节数组大小；</li>
<li>以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等</li>
</ol>
<p>2、共享对象池</p>
<p>对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。</p>
<p>3、字符串优化</p>
<p>4、编码优化</p>
<p>5、控制key的数量</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的持久化</title>
    <url>/2022/05/20/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h1><p>redis是内存数据库，如果数据不持久化，当程序关闭时将会丢失数据，所以Redis提供了持久化</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p><strong>什么是RDB？</strong></p>
<p><img src="https://s2.loli.net/2022/02/20/IeEx1JmZS82vk9s.png" alt="image-20220220232522977"></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。Redis会单独创建 ( fork )一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况不需要修改这个配置！</p>
<p>在生成环境我们将会对这个文件进行备份</p>
<p><strong>缺点：</strong></p>
<p>如果在最后一次宕机了，就没有办法去持久化了，需要一定的时间间隔</p>
<p>在创建frok进程的时候，会占用一定的空间</p>
<p><strong>优点：</strong></p>
<p>RDB比AOF更加的高效，适合大规模恢复数据</p>
<p>RDB保存的文件是dump.rdb   ，在配置文件中有讲，都是在配置文件中设置的</p>
<p><strong>持久化触发机制：</strong></p>
<p>注意：kill的情况下不会触发</p>
<p>1,save的规则满足的情况下会触发rdb规则</p>
<p>2,执行flushall命令也会触发rdb规则</p>
<p>3,当退出redis时也会触发rdb规则   </p>
<p>会生成一个dump.rdb文件，redis在重启时会读取文件，恢复数据，如果删除，关闭后就不会有之前的数据了</p>
<p><strong>如恢复rdb文件：</strong></p>
<p>只需要将rdb文件放置redis启动目录下，</p>
<p>dump.rdb放在redis-server同级目录</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>它会将我们所有的命令记录下来，history，恢复的时候就会把这个文件全部执行一遍！</p>
<p><strong>在redis4.0以后支持混合模式，rdb与aof同时开启会优先aof</strong></p>
<p><img src="https://s2.loli.net/2022/02/20/r1N7HEity9OXqdA.png" alt="image-20220220233046582"></p>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来(读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<p><strong>默认不开AOF，需要去配置文件中手动开启</strong></p>
<p><strong>Aof保存的是appendonly.aof 文件</strong></p>
<p>文件同样可以在配置文件中修改:</p>
<p>&#x2F;&#x2F;The name of the append only file (default: “appendonly.aof”)</p>
<p>​	appendfilename “appendonly.aof”</p>
<p><strong>当我们开启时输入了命令后就会生成aod文件：</strong></p>
<p><img src="https://s2.loli.net/2022/02/21/lDiAuKGo345PORI.png" alt="image-20220221100633418"></p>
<p><strong>文件的内容为：</strong></p>
<p><img src="https://s2.loli.net/2022/02/22/DGtZmALfOyTziFh.png" alt="image-20220222225551886"></p>
<p>这个文件是能破坏的，破坏后启动redis会报错 ，但是系统会生成一个备用文件，我们可以使用它来修改appendonly.aof</p>
<p>破坏后登录：</p>
<p><img src="https://s2.loli.net/2022/02/21/JuwqZhENCfp9LIn.png" alt="image-20220221102935481"></p>
<p>破坏后是可以使用这个文件进行恢复的</p>
<p><img src="https://s2.loli.net/2022/02/21/X4TEjb1n5VfL2Fk.png" alt="image-20220221103321224"></p>
<p>使用命令：redis-check-aof –fix appendonly.aof  进行恢复，恢复后 就能正常登录了</p>
<p>注意：要在appendonly.aof文件位置使用该命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# redis-check-aof --fix appendonly.aof</span><br><span class="line">Cannot open file: appendonly.aof</span><br><span class="line">[root@VM-4-12-centos ~]# cd /usr/local/bin</span><br><span class="line">[root@VM-4-12-centos bin]# redis-check-aof --fix appendonly.aof</span><br><span class="line">0x              3c: Expected \r\n, got: 7765</span><br><span class="line">AOF analyzed: size=143, ok_up_to=52, diff=91</span><br><span class="line">This will shrink the AOF from 143 bytes, with 91 bytes, to 52 bytes</span><br><span class="line">Continue? [y/N]: y</span><br><span class="line">Successfully truncated AOF</span><br><span class="line">[root@VM-4-12-centos bin]# </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>博客技术总结</title>
    <url>/2022/05/14/%E5%8D%9A%E5%AE%A2%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1-技术介绍"><a href="#1-技术介绍" class="headerlink" title="1.技术介绍"></a>1.技术介绍</h1><p>前端：vue + vuex + vue-router + axios + vuetify + element + echarts</p>
<p>后端：SpringBoot + nginx + SpringSecurity + Swagger2 + MyBatisPlus + Mysql + Redis + elasticsearch + rabbitMQ + MaxWell</p>
<h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2.运行环境"></a>2.运行环境</h1><p>开发工具：IDEA</p>
<p>服务器：阿里云1核2G CentOS8.0以上</p>
<p>对象存储：阿里云OSS</p>
<p>全站cdn加速</p>
<p>cos对象储存</p>
<p>全站https</p>
<h1 id="3-项目总结"><a href="#3-项目总结" class="headerlink" title="3.项目总结"></a>3.项目总结</h1><p>此次对博客进行了全方位的升级，前端技术点和后端技术点相比第一，二版提升了不少。</p>
<p>加入了许多动画过渡效果，并考虑到了一些用户细节（深色模式，图片预览，等），评论加入了表情和分页，提升了用户体验，。后台文章编辑器换为MarkDown，语法更加简洁，新增了草稿箱和自动保存文章等功能。</p>
]]></content>
  </entry>
  <entry>
    <title>redis集群（主从复制）</title>
    <url>/2022/05/21/redis%E9%9B%86%E7%BE%A4%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Redis主从复制："><a href="#Redis主从复制：" class="headerlink" title="Redis主从复制："></a>Redis主从复制：</h1><h2 id="Redis主从复制概念"><a href="#Redis主从复制概念" class="headerlink" title="Redis主从复制概念"></a>Redis主从复制概念</h2><p>主从复制,是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower);数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p>
<p>默认情况下，每台Redis服务器都是主节点;且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。主从复制的作用主要包括:</p>
<p>1、数据冗余:主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。</p>
<p>2、故障恢复:当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复;实际上是一种服务的冗余。</p>
<p>3、负载均衡:在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连教主节点，读Redis数据时应用连接从节点)，分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<p>4、高可用(集群)基石:除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础.<br>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下:</p>
<p>​	1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大;<br>​	</p>
<p>​	2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用	内存不应该超过20G。</p>
<p>​	电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。对于这种场景，我们可以使如下这种架构:</p>
<p>​	这是一主三从</p>
<p><img src="https://s2.loli.net/2022/02/21/UTkJjV2ZfAeiNrE.png" alt="image-20220221153646023"></p>
<p>​	 3、负载均衡:在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连教主节点，读Redis数据时应用连	接 从节点)，分担服务器负载;尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</p>
<h2 id="一主二从："><a href="#一主二从：" class="headerlink" title="一主二从："></a>一主二从：</h2><p>由于没有多个服务器，就在本机上多开几个redis，当端口什么都不一样，如果在一台服务器是测试：</p>
<p>在一个主机上测试需要多个配置文件，并且配置文件需要修改</p>
<p>port     端口</p>
<p>pidfile   名字</p>
<p>log   log文件名字</p>
<p>dump.rdb   名字</p>
<p>如果开了aof还需要修改aof的配置</p>
<p>开启三个服务</p>
<p><strong>查看当前redis</strong></p>
<p><img src="https://s2.loli.net/2022/02/21/g2UXIiE6lrMvcG5.png" alt="image-20220221235035363"></p>
<p><strong>默认情况下，每台redis服务器都是主节点</strong>；一般情况下我们只需要配置从机就可以了！</p>
<p><strong>设置从机:</strong></p>
<p>注意，认主需要在从机是去认，而不是主机</p>
<p>我们需要在redis中去设置主机是谁，也就是认老大。假设  主为（6360），二从为（61，62）；</p>
<p>使用命令：SLAVEOF    IP   端口   ；这就是找谁当老大，这里只演示连接一个，另一个自己去连</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6362&gt; SLAVEOF 127.0.0.1 6360</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6362&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave      #角色从 master  变成了 slave</span><br><span class="line">master_host:127.0.0.1    #主机IP</span><br><span class="line">master_port:6360		#主机端口</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:6</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:28</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:7f946868186fe88c13209f6a40cb8a41349df88c</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:28</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:28</span><br><span class="line">127.0.0.1:6362&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>查看下主机的身份信息:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6360&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master    #角色</span><br><span class="line">connected_slaves:2   #从机数量</span><br><span class="line">slave0:ip=127.0.0.1,port=6362,state=online,offset=630,lag=0   #从机基本信息</span><br><span class="line">slave1:ip=127.0.0.1,port=6361,state=online,offset=630,lag=1   #从机基本信息</span><br><span class="line">master_replid:7f946868186fe88c13209f6a40cb8a41349df88c</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:630</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:630</span><br><span class="line">127.0.0.1:6360&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>读写与特殊情况演示：</strong></p>
<p>主机复制些，而从机负责读，尽管主机宕机，从机依旧可以继续读到数据，</p>
<p><strong>使用主机写：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6360&gt; set key 1</span><br><span class="line">OK       #成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>使用从机读：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6362&gt; get key</span><br><span class="line">&quot;1&quot;    #成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>使用从机写：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6362&gt; set key1 v1</span><br><span class="line">(error) READONLY You can&#x27;t write against a read only replica.     #不能对只读从机写</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>关闭主机  从机是否还能进行读：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# ps -ef|grep redis     #现在么有主机6360了</span><br><span class="line">root      304584  304199  0 11:38 pts/1    00:00:00 redis-cli -p 6361</span><br><span class="line">root      304652  304153  0 11:38 pts/0    00:00:00 redis-cli -p 6362</span><br><span class="line">root      312884  304314  0 12:11 pts/2    00:00:00 grep --color=auto redis</span><br><span class="line">root     4193030       1  0 Feb21 ?        00:00:47 redis-server 0.0.0.0:6361</span><br><span class="line">root     4193050       1  0 Feb21 ?        00:00:47 redis-server 0.0.0.0:6362</span><br><span class="line">[root@VM-4-12-centos ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>关闭主机情况下进行读：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6362&gt; get key</span><br><span class="line">&quot;1&quot;   #依旧成功</span><br></pre></td></tr></table></figure>



<p><strong>主机关闭后的角色基本信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6362&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6360</span><br><span class="line">master_link_status:down</span><br><span class="line">master_last_io_seconds_ago:-1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:1396</span><br><span class="line">master_link_down_since_seconds:125</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:7f946868186fe88c13209f6a40cb8a41349df88c</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:1396</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:1396</span><br></pre></td></tr></table></figure>



<p><strong>主机重启后写的值是否还能被从机读取到</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#主机</span><br><span class="line">[root@VM-4-12-centos ~]# redis-server /usr/local/bin/StudyHardConfig/redis60.conf </span><br><span class="line">[root@VM-4-12-centos ~]# redis-cli -p 6360</span><br><span class="line">127.0.0.1:6360&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6360&gt; set key3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6360&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#从机  依旧可以读取到</span><br><span class="line">127.0.0.1:6362&gt; get key3</span><br><span class="line">&quot;v3&quot;       #成功</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>从机关机的情况下</strong></p>
<p>可看出从机必须连接主机后才能拿到数据，并且关机后会恢复成主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@VM-4-12-centos ~]# ps -ef|grep redis</span><br><span class="line">root      304652  304153  0 11:38 pts/0    00:00:00 redis-cli -p 6362</span><br><span class="line">root      313867       1  0 12:15 ?        00:00:01 redis-server 0.0.0.0:6360</span><br><span class="line">root      313941  304314  0 12:15 pts/2    00:00:00 redis-cli -p 6360</span><br><span class="line">root      318505  304199  0 12:33 pts/1    00:00:00 grep --color=auto redis</span><br><span class="line">root     4193050       1  0 Feb21 ?        00:00:48 redis-server 0.0.0.0:6362</span><br><span class="line">[root@VM-4-12-centos ~]# redis-server /usr/local/bin/StudyHardConfig/redis61.conf </span><br><span class="line">[root@VM-4-12-centos ~]# redis-cli -p 6361</span><br><span class="line">127.0.0.1:6361&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6361&gt; get key</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6361&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6361&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:f8962d2e0a43dc37e21770cc7a27e3b7664dbb72</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6361&gt; SLAVEOF 127.0.0.1 6360</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6361&gt; keys *</span><br><span class="line">1) &quot;key3&quot;</span><br><span class="line">127.0.0.1:6361&gt; get key3</span><br><span class="line">&quot;v3&quot;</span><br><span class="line">127.0.0.1:6361&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>







<p>注意：这种命令行的主从设置是一次性的，关机后就会恢复成主机，想要永久设置需要去配置文件中配置；</p>
<p>#replicaof <masterip> <masterport>      &#x2F;&#x2F;在配置文件中将该配置注释去掉，并填写上主机的ip 与端口</p>
<p>如果主机有密码：</p>
<p>#masterauth <master-password>        &#x2F;&#x2F;在配置文件中将该配置注释去掉，并填写主机密码</p>
<p><strong>主从复制原理</strong></p>
<p>Slave启动成功连接到master后会发送一个sync同步命令<br>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。<br>全量复制:而slave服务在接收到数据库文件数据后,将其存盘并加载到内存中。增量复制:Master继续将新的所有收集到的修改命令依次传给slave，完成同步<br>但是只要是重新连接master，一次完全同步(全量复制）将被自动执行!我们的数据一定可以在从机中看到!</p>
<p>还有一种主从方式，</p>
<p>a  – b  – c   这种连接方式，a宕机了我们可以手动将b选为老大，</p>
<p>命令：SLAVEOF no one   ； 这样将原来是从节点的redis改为主节点</p>
<p>这里都是手动的；而哨兵模式就是自动选取老大</p>
]]></content>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBootSecurity</title>
    <url>/2022/05/02/SpringBootSecurity/</url>
    <content><![CDATA[<h1 id="SpringBoot安全框架："><a href="#SpringBoot安全框架：" class="headerlink" title="SpringBoot安全框架："></a>SpringBoot安全框架：</h1><h2 id="HttpBasic认证模式："><a href="#HttpBasic认证模式：" class="headerlink" title="HttpBasic认证模式："></a>HttpBasic认证模式：</h2><p>这是种防君子不防小人的认证，也是最简单的一个认证模式</p>
<p>编写配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line">        http.httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//所有的请求</span></span><br><span class="line">                .authorizeHttpRequests()</span><br><span class="line">                <span class="comment">//匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>编写好配置文件后，启动会给出一个密码：</strong></p>
<p>我们使用该密码进行登录</p>
<p>Using generated security password: 8e0f5586-f414-454b-bd96-ffc82e919a6a</p>
<p><strong>我们自己指定用户名，密码修改配置文件application：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="comment">#配置httpBasic认证的用户名，密码</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">admin123</span></span><br></pre></td></tr></table></figure>



<p>启动后就不好给我们密码了，但这个密码是可以获取到的，如图：</p>
<p><img src="https://s2.loli.net/2022/03/09/Zvx8aDjWt9eLOY1.png" alt="image-20220302192907115"></p>
<p><strong>我们可以使用工具Postman获取到账户密码：</strong></p>
<p>​								登录：</p>
<p><img src="https://s2.loli.net/2022/03/09/Peuw2ZW7bDNgGcx.png" alt="image-20220303084206675"></p>
<p><strong>可以看到有给Authorization  这个是我们的账号密码使用ase64加密后的结果我们可以复制加密后的密码去解码就可以获取到账号密码了：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/zHSoTNCL1tjQf4U.png" alt="image-20220303084235403"></p>
<p><strong>解码结果：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/STXbo9kga8Ri5FH.png" alt="image-20220303091317694"></p>
<h2 id="passwrodEncoder加密"><a href="#passwrodEncoder加密" class="headerlink" title="passwrodEncoder加密"></a>passwrodEncoder加密</h2><p>passwrodEncoder加密是不可逆的</p>
<p><strong>passwrodEncoder接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PasswordEncoder</span> &#123;</span><br><span class="line">    String <span class="title function_">encode</span><span class="params">(CharSequence rawPassword)</span>;   <span class="comment">//用于加密密码</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span>;  <span class="comment">//验证输入的密码是否与加密的密码一致</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">upgradeEncoding</span><span class="params">(String encodedPassword)</span> &#123;   <span class="comment">//密码是否需要被更新，有需要可以重新该方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>推荐使用的实现类BCryptPasswordEncoder：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">bCryptPasswordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="comment">//密码加密</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> bCryptPasswordEncoder.encode(<span class="string">&quot;123hzr&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;一次加密:&quot;</span>+encode);</span><br><span class="line">    <span class="comment">//密码校验对比</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> bCryptPasswordEncoder.matches(<span class="string">&quot;123&quot;</span>, encode);</span><br><span class="line">    System.out.println(<span class="string">&quot;密码是否正确&quot;</span>+matches);</span><br><span class="line">    <span class="comment">//密码校验对比</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matches1</span> <span class="operator">=</span> bCryptPasswordEncoder.matches(<span class="string">&quot;123hzr&quot;</span>, encode);</span><br><span class="line">    System.out.println(<span class="string">&quot;密码是否正确&quot;</span>+matches1);</span><br><span class="line">    <span class="comment">//同样密码加密，结果和第一加密码不一样，所以说passwrodEncoder加密是不可逆的</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">encode2</span> <span class="operator">=</span> bCryptPasswordEncoder.encode(<span class="string">&quot;123hzr&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;二次加密:&quot;</span>+encode2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一次加密:$2a$10$6zuzvMqFVq89TerHtThXder6n2VqOMyJF6hpAn8ZBYjA7FaGOPzOy</span><br><span class="line">密码是否正确false</span><br><span class="line">密码是否正确true</span><br><span class="line">二次加密:$2a$10$rAznej1Fv0VGqXkXo7tKiu4c0nBwEYzVykbPfhGE9YSi25xpmTL7G</span><br></pre></td></tr></table></figure>



<p><strong>加密值解释：</strong></p>
<p>$2a  &#x2F;&#x2F;表示 BCrypt 算法版本</p>
<p>$10    &#x2F;&#x2F;表示算法强度</p>
<p>$rAznej1Fv0VGqXkXo7tK   &#x2F;&#x2F;随机生成的盐值</p>
<p>iu4c0nBwEYzVykbPfhGE9YSi25xpmTL7G  &#x2F;&#x2F;hash值</p>
<h2 id="formLogin登录认证"><a href="#formLogin登录认证" class="headerlink" title="formLogin登录认证"></a>formLogin登录认证</h2><h3 id="同样先编写配置类："><a href="#同样先编写配置类：" class="headerlink" title="同样先编写配置类："></a>同样先编写配置类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/&quot;</span>)   <span class="comment">//登录成功跳转的路径</span></span><br><span class="line">                .failureForwardUrl(<span class="string">&quot;/logins&quot;</span>)  <span class="comment">//登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/business1&quot;</span>,<span class="string">&quot;/business2&quot;</span>,<span class="string">&quot;/&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasAnyAuthority(<span class="string">&quot;ROLE_user&quot;</span>,<span class="string">&quot;ROLE_admin&quot;</span>)<span class="comment">//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/log&quot;</span>,<span class="string">&quot;/user&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)<span class="comment">//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//选择的匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                auth  <span class="comment">//授权</span></span><br><span class="line">                .inMemoryAuthentication()  <span class="comment">//将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>)  <span class="comment">//用户名</span></span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))  <span class="comment">//密码</span></span><br><span class="line">                .roles(<span class="string">&quot;user&quot;</span>)  <span class="comment">//设置使用该用户名登录赋予的角色，</span></span><br><span class="line">            .and()</span><br><span class="line">                 .withUser(<span class="string">&quot;admin&quot;</span>) <span class="comment">//用户名</span></span><br><span class="line">                 .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                   <span class="comment">//第一种授权方式</span></span><br><span class="line">                 .roles(<span class="string">&quot;admin&quot;</span>)  <span class="comment">//设置使用该账号登录赋予的角色</span></span><br><span class="line">                   <span class="comment">//第二种授权方式</span></span><br><span class="line">                 <span class="comment">//.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //为当前用户赋予角色</span></span><br><span class="line">            .and()</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*加密方式</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="controller类："><a href="#controller类：" class="headerlink" title="controller类："></a>controller类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">indexController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/logins&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/log&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">log</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;log&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/business1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">business1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;business1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/business2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">business2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;business2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="自定义登录验证处理："><a href="#自定义登录验证处理：" class="headerlink" title="自定义登录验证处理："></a><strong>自定义登录验证处理：</strong></h2><p>这里我们需要了解一下</p>
<p><img src="https://s2.loli.net/2022/03/09/DqCRLYV6WyMAa9Q.png" alt="image-20220304105306887"></p>
<p>这两类，第一个是登录成功后的处理方式，第二给是登录失败的处理方式，我们需要重新它</p>
<p><strong>AuthenticationFailureHandler  登录失败重写：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录失败后进行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationFailureHandler</span></span><br><span class="line">	<span class="comment">//SimpleUrlAuthenticationFailureHandle 是AuthenticationFailureHandler的一个实现类</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这个一定要使用el表达式，否则这个方法都不会进  ；这个是配置文件中自定义的参数，值为JSON</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.security.loginType&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String loginType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录失败后进行操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception  异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//判断要返回的类型</span></span><br><span class="line">        <span class="keyword">if</span> (loginType.equalsIgnoreCase(<span class="string">&quot;JSON&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//告诉浏览器，以json返回</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">//要返回的数据  这里的JsonResult只是单纯的一个返回json信息格式的类</span></span><br><span class="line">            response.getWriter().write(objectMapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;().InputError()));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//登录失败后进行的页面跳转，父类已经为我们实现了</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.onAuthenticationFailure(request, response, exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p> <strong>AuthenticationSuccessHandler 登录成功重新:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置登录成功后需要的操作</span></span><br><span class="line"><span class="comment"> * 实现AuthenticationSuccessHandler登录成功进行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAuthenticationSuccessHandler</span></span><br><span class="line">    <span class="comment">//SavedRequestAwareAuthenticationSuccessHandler 继承该类，该类实现了AuthenticationSuccessHandler登录成功进行的操作</span></span><br><span class="line">    <span class="comment">//这个类中有帮我们实现一些有用的方法，比如说记住用户上一次的操作，登录后跳转的页面就是用户上一次未能进入的页面，而不是首页</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">SavedRequestAwareAuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这个一定要使用el表达式，否则这个方法都不会进  ；这个是配置文件中自定义的参数，值为JSON</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.security.loginType&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String loginType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是登录成功后执行的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response  响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//判断要返回的类型</span></span><br><span class="line">        <span class="keyword">if</span> (loginType.equalsIgnoreCase(<span class="string">&quot;JSON&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//告诉浏览器，以json返回</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">//要返回的数据</span></span><br><span class="line">            response.getWriter().write(objectMapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">JsonResult</span>().success()));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//会帮助我们跳转到上一次请求的页面 ,这个方法也就是我们重新的这个方法</span></span><br><span class="line">            response.setContentType(<span class="string">&quot;application/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="built_in">super</span>.onAuthenticationSuccess(request,response,authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>Security配置类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/business1&quot;</span>,<span class="string">&quot;/business2&quot;</span>,<span class="string">&quot;/&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasAnyAuthority(<span class="string">&quot;ROLE_user&quot;</span>,<span class="string">&quot;ROLE_admin&quot;</span>)<span class="comment">//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/log&quot;</span>,<span class="string">&quot;/user&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)<span class="comment">//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//选择的匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                auth  <span class="comment">//授权</span></span><br><span class="line">                .inMemoryAuthentication()  <span class="comment">//将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>)  <span class="comment">//用户名</span></span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))  <span class="comment">//密码</span></span><br><span class="line">                .roles(<span class="string">&quot;user&quot;</span>)  <span class="comment">//设置使用该用户名登录赋予的角色，</span></span><br><span class="line">            .and()</span><br><span class="line">                 .withUser(<span class="string">&quot;admin&quot;</span>) <span class="comment">//用户名</span></span><br><span class="line">                 .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                   <span class="comment">//第一种授权方式</span></span><br><span class="line">                 .roles(<span class="string">&quot;admin&quot;</span>)  <span class="comment">//设置使用该账号登录赋予的角色</span></span><br><span class="line">                   <span class="comment">//第二种授权方式</span></span><br><span class="line">                 <span class="comment">//.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //为当前用户赋予角色</span></span><br><span class="line">            .and()</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>由于这里返回的是Json数据，注意，那么login就需要使用Ajax的方式请求数据：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;login()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> username=$(<span class="string">&quot;#username&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> password=$(<span class="string">&quot;#password&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;/login&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;user&quot;</span>: username,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;password&quot;</span>: password</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">json</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">if</span> (json.<span class="property">state</span> == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(json.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/logins&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="session会话的安全管理："><a href="#session会话的安全管理：" class="headerlink" title="session会话的安全管理："></a>session会话的安全管理：</h2><p><img src="https://s2.loli.net/2022/03/09/yDC5PVItQqJhvg2.png" alt="image-20220304121119473"></p>
<p><img src="https://s2.loli.net/2022/03/09/HZw4NyRuXetcvqo.png" alt="image-20220304121220680"></p>
<p>添加以上配置示例：</p>
<p><img src="https://s2.loli.net/2022/03/09/VdxHK6JY45FvpBl.png" alt="image-20220304121253830"></p>
<p><strong>session的安全保护：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/MEb92jfIm6XRuiA.png" alt="image-20220304121414386"></p>
<p><strong>cookie的安全：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/c874Wyzg2Rf93JD.png" alt="image-20220304121440993"></p>
<h2 id="同账号多登录踢下线："><a href="#同账号多登录踢下线：" class="headerlink" title="同账号多登录踢下线："></a>同账号多登录踢下线：</h2><p><strong>踢下线处理类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置当session被踢下线之后的操作，如：跳转页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomExpiredSessionStrategy</span></span><br><span class="line">    <span class="comment">//需要实现该接口</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">SessionInformationExpiredStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//页面跳转的处理类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedirectStrategy</span> <span class="variable">redirectStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultRedirectStrategy</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于将对象转换为json格式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当发现session踢下线就会调用该方法处理，前提需要再配置类中使用该类处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event  这个类中可以获取到requesty 与 respoense</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onExpiredSessionDetected</span><span class="params">(SessionInformationExpiredEvent event)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两种方式，前后端分离，JSON格式，与直接跳转页面的的方式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式二，json格式</span></span><br><span class="line">            <span class="comment">//这里使用map也行，对象也行，就是返回的信息</span></span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            map.put(<span class="string">&quot;stat&quot;</span>,<span class="string">&quot;200&quot;</span>);</span><br><span class="line">            map.put(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;请重新进行登录&quot;</span>+event.getSessionInformation().getLastRequest());  <span class="comment">//后面的登录时间</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> objectMapper.writeValueAsString(map);</span><br><span class="line">            event.getResponse().setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">            event.getResponse().getWriter().write(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            //方式一，直接跳转  这个方法是重定向到指定的页面</span></span><br><span class="line"><span class="comment">//            redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),&quot;/logins&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>在securty配置类中配置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/business1&quot;</span>,<span class="string">&quot;/business2&quot;</span>,<span class="string">&quot;/&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasAnyAuthority(<span class="string">&quot;ROLE_user&quot;</span>,<span class="string">&quot;ROLE_admin&quot;</span>)<span class="comment">//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/log&quot;</span>,<span class="string">&quot;/user&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)<span class="comment">//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line">                <span class="comment">//选择的匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated()</span><br><span class="line">                </span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                auth  <span class="comment">//授权</span></span><br><span class="line">                .inMemoryAuthentication()  <span class="comment">//将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line">                .withUser(<span class="string">&quot;user&quot;</span>)  <span class="comment">//用户名</span></span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))  <span class="comment">//密码</span></span><br><span class="line">                .roles(<span class="string">&quot;user&quot;</span>)  <span class="comment">//设置使用该用户名登录赋予的角色，</span></span><br><span class="line">            .and()</span><br><span class="line">                 .withUser(<span class="string">&quot;admin&quot;</span>) <span class="comment">//用户名</span></span><br><span class="line">                 .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                   <span class="comment">//第一种授权方式</span></span><br><span class="line">                 .roles(<span class="string">&quot;admin&quot;</span>)  <span class="comment">//设置使用该账号登录赋予的角色</span></span><br><span class="line">                   <span class="comment">//第二种授权方式</span></span><br><span class="line">                 <span class="comment">//.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //为当前用户赋予角色</span></span><br><span class="line">            .and()</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="RBAC权限管理控制模型"><a href="#RBAC权限管理控制模型" class="headerlink" title="RBAC权限管理控制模型"></a><strong>RBAC权限管理控制模型</strong></h2><p><img src="https://s2.loli.net/2022/03/09/tsqKGbhigTXQwOS.png" alt="image-20220307195430369"></p>
<p><img src="https://s2.loli.net/2022/03/09/eFplaSkOnAr2TCc.png" alt="image-20220307195418619"></p>
<h2 id="动态加载用户角色权限数据："><a href="#动态加载用户角色权限数据：" class="headerlink" title="动态加载用户角色权限数据："></a>动态加载用户角色权限数据：</h2><p>首先我们需要实现两个类，一个是UserDetails，还有个是UserDetailsService</p>
<p>UserDetails ：这个接口为的是存放用户详细信息，</p>
<p>UserDetailsService：为加载用户的信息填写到UserDetails 中并返回给Security使用</p>
<h3 id="UserDetails："><a href="#UserDetails：" class="headerlink" title="UserDetails："></a><strong>UserDetails：</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于获取用户详细信息，</span></span><br><span class="line"><span class="comment"> * 需要使用UserDetailsService为当前类绑定信息；</span></span><br><span class="line"><span class="comment"> * 还需要手动创建set方法赋值，已经创建对应的属性存值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetails</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities;  <span class="comment">//用户的权限集合</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthorities</span><span class="params">(Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountNonExpired</span><span class="params">(<span class="type">boolean</span> accountNonExpired)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNonExpired = accountNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccountNonLocked</span><span class="params">(<span class="type">boolean</span> accountNonLocked)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accountNonLocked = accountNonLocked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCredentialsNonExpired</span><span class="params">(<span class="type">boolean</span> credentialsNonExpired)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.credentialsNonExpired = credentialsNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> accountNonExpired; <span class="comment">//账号是否没过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> accountNonLocked; <span class="comment">//账号是否没被锁定</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> credentialsNonExpired;  <span class="comment">//用户凭证是否没过期    or 密码是否过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;  <span class="comment">//账户是否可用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户的权限集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账号是否没过期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  这里由于我数据库没加这个字段就默认为true了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账号是否没被锁定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  这里由于我数据库没加这个字段就默认为true了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码是否没过期</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  这里由于我数据库没加这个字段就默认为true了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户是否可用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MyUserDetails</span> <span class="variable">that</span> <span class="operator">=</span> (MyUserDetails) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">accountNonExpired</span> <span class="operator">=</span>= that.accountNonExpired &amp;&amp; accountNonLocked == that.accountNonLocked &amp;&amp; credentialsNonExpired 			== that.credentialsNonExpired &amp;&amp; enabled == that.enabled &amp;&amp; Objects.equals(authorities, that.authorities) &amp;&amp; 				   Objects.equals(password, that.password) &amp;&amp; Objects.equals(username, that.username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(authorities, password, username, accountNonExpired, accountNonLocked, credentialsNonExpired, 				enabled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="UserDetailsService："><a href="#UserDetailsService：" class="headerlink" title="UserDetailsService："></a>UserDetailsService：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于加载UserDetails中的详细信息</span></span><br><span class="line"><span class="comment"> * 为替换掉security配置类中的静态授权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里三个查询其实可以放一起的，毕竟都是查询用户权限的</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleMapper roleMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  使用传入的唯一标识（username） 查询用户信息，并组装成为UserDetails类返回，返回后security就会拿到哪些数据并进行验证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  动态添加security认证，鉴权，授权相关的基础信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username  用户输入的账户，也就是security配置类中的 .usernameParameter(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">MyUserDetails</span> <span class="variable">myUserDetails</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyUserDetails</span>();</span><br><span class="line">      <span class="comment">//获取用户基本信息</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.UserFiend(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        myUserDetails.setPassword(user.getPassword());</span><br><span class="line">        myUserDetails.setUsername(user.getUsername());</span><br><span class="line">        myUserDetails.setEnabled(user.isEnabled());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//查询用户角色,赋予用户角色，我们需要在角色前加上 ROLE_</span></span><br><span class="line">        List&lt;String&gt; list = roleMapper.listByUserId(user.getId());</span><br><span class="line">        <span class="type">Role</span> <span class="variable">role</span> <span class="operator">=</span> roleMapper.fiendByUserId(user.getId());</span><br><span class="line">        <span class="comment">//在每个元素前加上ROLE_，获取角色</span></span><br><span class="line">        list=list.stream().map(rc-&gt; <span class="string">&quot;ROLE_&quot;</span> +rc).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据角色获取解释对应的权限，这个是只获取要权限的页面</span></span><br><span class="line">        List&lt;String&gt; list1 = menuMapper.listByRoleId(role.getId());</span><br><span class="line">        <span class="comment">//将角色与要权限的页面绑定</span></span><br><span class="line">        list1.addAll(list);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//这一步就如同为角色赋予权限</span></span><br><span class="line">        myUserDetails.setAuthorities(</span><br><span class="line">                <span class="comment">//由于List不能直接赋值给Authorities 所有使用AuthorityUtils.commaSeparatedStringToAuthorityList()来解决</span></span><br><span class="line">                AuthorityUtils.commaSeparatedStringToAuthorityList(</span><br><span class="line">                        String.join(<span class="string">&quot;,&quot;</span>,list1)  <span class="comment">//将授权页面与角色用逗号分开</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回当前用户的登录授权信息，交给iSecurity</span></span><br><span class="line">        <span class="keyword">return</span> myUserDetails;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="修改Security配置类："><a href="#修改Security配置类：" class="headerlink" title="修改Security配置类："></a>修改Security配置类：</h3><p>注意：这里由于一些我也不知道的问题，这里的同账户登录多人不会被踢下线</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line"><span class="comment">//        http.httpBasic()</span></span><br><span class="line"><span class="comment">//                .and()</span></span><br><span class="line"><span class="comment">//                //所有的请求</span></span><br><span class="line"><span class="comment">//                .authorizeHttpRequests()</span></span><br><span class="line"><span class="comment">//                //匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//_______________________________________________________________________________________________________-</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/business1&quot;</span>,<span class="string">&quot;/business2&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasAnyAuthority(<span class="string">&quot;ROLE_user&quot;</span>,<span class="string">&quot;ROLE_admin&quot;</span>)<span class="comment">//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/log&quot;</span>,<span class="string">&quot;/user&quot;</span>)<span class="comment">//资源路径</span></span><br><span class="line">                .hasRole(<span class="string">&quot;admin&quot;</span>)<span class="comment">//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//选择的匹配规则</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                <span class="comment">//所有请求都需要登录认证才可以访问</span></span><br><span class="line">                .authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//____________________静态授权________________________</span></span><br><span class="line"><span class="comment">//                auth  //授权</span></span><br><span class="line"><span class="comment">//                .inMemoryAuthentication()  //将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line"><span class="comment">//                .withUser(&quot;user&quot;)  //用户名</span></span><br><span class="line"><span class="comment">//                .password(passwordEncoder().encode(&quot;123456&quot;))  //密码</span></span><br><span class="line"><span class="comment">//                .roles(&quot;user&quot;)  //设置使用该用户名登录赋予的角色，</span></span><br><span class="line"><span class="comment">//            .and()</span></span><br><span class="line"><span class="comment">//                 .withUser(&quot;admin&quot;) //用户名</span></span><br><span class="line"><span class="comment">//                 .password(passwordEncoder().encode(&quot;123456&quot;))</span></span><br><span class="line"><span class="comment">//                   //第一种授权方式</span></span><br><span class="line"><span class="comment">//                 .roles(&quot;admin&quot;)  //设置使用该账号登录赋予的角色</span></span><br><span class="line"><span class="comment">//                   //第二种授权方式</span></span><br><span class="line"><span class="comment">//                 //.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="动态鉴权规则："><a href="#动态鉴权规则：" class="headerlink" title="动态鉴权规则："></a><strong>动态鉴权规则：</strong></h2><p>用于代替静态的鉴权规则</p>
<h5 id="自定义鉴权规则："><a href="#自定义鉴权规则：" class="headerlink" title="自定义鉴权规则："></a>自定义鉴权规则：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态判断用户是否用于访问页面的权限，类名可以随便取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;MyRBACService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRBACService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于验证当前用户，是否能访问当前请求的资格与权限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication  通过认证的用户主体详细信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 有权限返回true ，没权限返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPermission</span><span class="params">(HttpServletRequest request, Authentication authentication)</span>&#123;</span><br><span class="line">        <span class="comment">//获取主体信息UserDetails</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">principal</span> <span class="operator">=</span> authentication.getPrincipal();</span><br><span class="line">        <span class="comment">//判断principal是否是UserDetails</span></span><br><span class="line">        <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails)&#123;</span><br><span class="line">            <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> (UserDetails) principal;</span><br><span class="line">            <span class="comment">//将获取到的这一次请求的资源路径转换为SimpleGrantedAuthority类型，</span></span><br><span class="line">            <span class="comment">// 因为UserDetails中Authorities存放用户权限的类型是SimpleGrantedAuthority类型</span></span><br><span class="line">            <span class="type">SimpleGrantedAuthority</span> <span class="variable">simpleGrantedAuthority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(request.getRequestURI());</span><br><span class="line">            <span class="comment">//判断当前用户的权限中是发拥有可以访问这个资源路径的权限</span></span><br><span class="line">            <span class="comment">// contains这个方法是用于判断当前集合是否有相同的</span></span><br><span class="line">            <span class="keyword">return</span> userDetails.getAuthorities().contains(simpleGrantedAuthority);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="Security配置类："><a href="#Security配置类：" class="headerlink" title="Security配置类："></a>Security配置类：</h5><p>这里使用动态鉴权规则后就不能使用静态授权，因为静态授权只是当前授权了角色，但角色的权限是没有配置的，我们可以看到动态鉴权是直接对当前当前用户角色可以访问的权限进行对比的，静态的只有单纯的角色，但角色是什么权限都没有的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line"><span class="comment">//        http.httpBasic()</span></span><br><span class="line"><span class="comment">//                .and()</span></span><br><span class="line"><span class="comment">//                //所有的请求</span></span><br><span class="line"><span class="comment">//                .authorizeHttpRequests()</span></span><br><span class="line"><span class="comment">//                //匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//_______________________________________________________________________________________________________-</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                <span class="comment">//____________________静态鉴权____________________________________</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/business1&quot;,&quot;/business2&quot;)//资源路径</span></span><br><span class="line"><span class="comment">//                .hasAnyAuthority(&quot;ROLE_user&quot;,&quot;ROLE_admin&quot;)//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    //访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;,&quot;/user&quot;)//资源路径</span></span><br><span class="line"><span class="comment">//                .hasRole(&quot;admin&quot;)//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    //访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">////                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">////                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line"><span class="comment">//                //选择的匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated()</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//______________________________动态图鉴权_____________________________________________</span></span><br><span class="line">                    <span class="comment">//所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span></span><br><span class="line">                    <span class="comment">//anyRequest  所有的请求</span></span><br><span class="line">                    <span class="comment">//access   访问权限</span></span><br><span class="line">                    /里面使用SpEL权限表达式</span><br><span class="line">                .anyRequest().access(<span class="string">&quot;@MyRBACService.hasPermission(request,authentication)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//____________________静态授权________________________</span></span><br><span class="line"><span class="comment">//                auth  //授权</span></span><br><span class="line"><span class="comment">//                .inMemoryAuthentication()  //将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line"><span class="comment">//                .withUser(&quot;user&quot;)  //用户名</span></span><br><span class="line"><span class="comment">//                .password(passwordEncoder().encode(&quot;123456&quot;))  //密码</span></span><br><span class="line"><span class="comment">//                .roles(&quot;user&quot;)  //设置使用该用户名登录赋予的角色，</span></span><br><span class="line"><span class="comment">//            .and()</span></span><br><span class="line"><span class="comment">//                 .withUser(&quot;admin&quot;) //用户名</span></span><br><span class="line"><span class="comment">//                 .password(passwordEncoder().encode(&quot;123456&quot;))</span></span><br><span class="line"><span class="comment">//                   //第一种授权方式</span></span><br><span class="line"><span class="comment">//                 .roles(&quot;admin&quot;)  //设置使用该账号登录赋予的角色</span></span><br><span class="line"><span class="comment">//                   //第二种授权方式</span></span><br><span class="line"><span class="comment">//                 //.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //</span></span><br><span class="line"><span class="comment">//                    .and().passwordEncoder(passwordEncoder()); //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="方法增强注解："><a href="#方法增强注解：" class="headerlink" title="方法增强注解："></a>方法增强注解：</h5><p><img src="https://s2.loli.net/2022/03/09/wSlBCNefJyq2sxP.png" alt="image-20220308200231990"></p>
<p><strong>@PreAuthorize(“SPEL”):  方法执行前判断用户调用权限</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/37T2DwRsaM96zSh.png" alt="image-20220308200604674"></p>
<p><strong>@PreFilter(“SPEL”):方法执行前过滤参数</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/QNLUZrw7TIMDj5P.png" alt="image-20220308200655277"></p>
<p><strong>@PostAuthorize(“SPEL”):方法执行后判断</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/IYaygrwcXiAqV7v.png" alt="image-20220308200824019"></p>
<p><strong>@PostFilter（”SPEL“） ： 方法执行完后过滤返回值</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/Hw7KEVztY8FCk52.png" alt="image-20220308200910568"></p>
<p><strong>在Security配置类中开启这个是个注解的使用：</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/iwQUNd5Rg3phnHk.png" alt="image-20220308200954913"></p>
<h2 id="记住我功能："><a href="#记住我功能：" class="headerlink" title="记住我功能："></a>记住我功能：</h2><p>这个配置使用十分的简单</p>
<p><img src="https://s2.loli.net/2022/03/21/I4d1MPALWe8Qumq.png" alt="image-20220309223842857"></p>
<h5 id="Security配置类"><a href="#Security配置类" class="headerlink" title="Security配置类:"></a>Security配置类:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line"><span class="comment">//        http.httpBasic()</span></span><br><span class="line"><span class="comment">//                .and()</span></span><br><span class="line"><span class="comment">//                //所有的请求</span></span><br><span class="line"><span class="comment">//                .authorizeHttpRequests()</span></span><br><span class="line"><span class="comment">//                //匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//_______________________________________________________________________________________________________-</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        http.rememberMe()<span class="comment">//开启记住我功能  ，前端也需要有记住我字段</span></span><br><span class="line">                .rememberMeCookieName(<span class="string">&quot;rememberMe-Cookie&quot;</span>)  <span class="comment">//存在浏览器中cookie的名称</span></span><br><span class="line">                .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>)  <span class="comment">//表单中 自动登录 勾选框的参数名</span></span><br><span class="line">                .tokenValiditySeconds(<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>) <span class="comment">//保存Cookie的有效期，默认2周</span></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//______________________________动态图鉴权_____________________________________________</span></span><br><span class="line">                    <span class="comment">//所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span></span><br><span class="line">                .anyRequest().access(<span class="string">&quot;@MyRBACService.hasPermission(request,authentication)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h5 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;login()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">     记住我<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remember-me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> username=$(<span class="string">&quot;#username&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> password=$(<span class="string">&quot;#password&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> remember=$(<span class="string">&quot;#remember-me&quot;</span>).<span class="title function_">prop</span>(<span class="string">&quot;checked&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(remember)</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;/login&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;user&quot;</span>: username,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;password&quot;</span>: password,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;remember-me&quot;</span>:remember</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">json</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">if</span> (json.<span class="property">state</span> == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(json.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/logins&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p>勾选记住我登录后会出现remember -me这个cookie</p>
<p><img src="https://s2.loli.net/2022/03/21/TPBXH6aGkDcMyuN.png" alt="image-20220309224317467"></p>
<p>其实它是有两层加密，最外层它是使用Base64加密的：</p>
<p>​						解码</p>
<p><img src="https://s2.loli.net/2022/03/21/tgj25RVxHfU8cXq.png" alt="image-20220309224554252"></p>
<p>密码还使用MD5加密:</p>
<p>TokenBasedRememberMeServices类源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">makeTokenSignature</span><span class="params">(<span class="type">long</span> tokenExpiryTime, String username, String password)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> username + <span class="string">&quot;:&quot;</span> + tokenExpiryTime + <span class="string">&quot;:&quot;</span> + password + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.getKey();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(Hex.encode(digest.digest(data.getBytes())));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No MD5 algorithm available!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这图进行解释</p>
<p><img src="https://s2.loli.net/2022/03/21/P15bc6jrSX9aMuU.png" alt="image-20220309224722249"></p>
<h5 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h5><p><img src="https://s2.loli.net/2022/03/21/GaHOPL49KkQlRyg.png" alt="image-20220309224647471"></p>
<h2 id="记住我功能将验证数据保存到数据库："><a href="#记住我功能将验证数据保存到数据库：" class="headerlink" title="记住我功能将验证数据保存到数据库："></a>记住我功能将验证数据保存到数据库：</h2><p>我们没使用数据库存储令牌校验，当我们关闭程序时，记住我功能则会失效，客户端有session也没有用，在内存中令牌校验的数据被清空了，</p>
<p>为了防止重启程序而导致记住我失效，我们将信息存储到数据库中，</p>
<p>注意：这个存储的不是你的session，你在浏览器删除session那么同样需要重新输入密码，存储到数据库中的是类似令牌校验的信息</p>
<p><strong>先创建数据库：</strong></p>
<p>这个表是固定的，不能修改，在提供的类中，有个方法也可以创建，我们这就手动创建了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `persistent_logins`(</span><br><span class="line">`username` varchar (64) NOT NULL,</span><br><span class="line">`series` varchar (64) NOT NULL,</span><br><span class="line">`token` varchar(64) NOT NULL,</span><br><span class="line">`last_used` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (series)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>





<p>在Security配置类中注入一个数据源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br></pre></td></tr></table></figure>



<p>再编辑一个bean 指定存储到数据库的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JdbcTokenRepositoryImpl 这个类是将数据保存到数据操作的类，里面有很多sql语句的，可以自己去看看</span></span><br><span class="line"><span class="comment"> * 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span></span><br><span class="line"><span class="comment"> * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span></span><br><span class="line"><span class="comment"> * 设置记住我存储到的数据源是哪个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PersistentTokenRepository <span class="title function_">tokenRepository</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">    jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然在告诉security指定使用这个bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.rememberMeCookieName(<span class="string">&quot;rememberMe-Cookie&quot;</span>)  <span class="comment">//存在浏览器中cookie的名称</span></span><br><span class="line">.rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>)  <span class="comment">//表单中 自动登录 勾选框的参数名</span></span><br><span class="line">.tokenValiditySeconds(<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>) <span class="comment">//保存Cookie的有效期，默认2周</span></span><br><span class="line">.tokenRepository(tokenRepository())  <span class="comment">//指定rememberMe存储到数据库规则方法</span></span><br></pre></td></tr></table></figure>





<p>完整配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        http.rememberMe()<span class="comment">//开启记住我功能  ，前端也需要有记住我字段</span></span><br><span class="line">                .rememberMeCookieName(<span class="string">&quot;rememberMe-Cookie&quot;</span>)  <span class="comment">//存在浏览器中cookie的名称</span></span><br><span class="line">                .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>)  <span class="comment">//表单中 自动登录 勾选框的参数名</span></span><br><span class="line">                .tokenValiditySeconds(<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>) <span class="comment">//保存Cookie的有效期，默认2周</span></span><br><span class="line">                .tokenRepository(tokenRepository())  <span class="comment">//指定rememberMe存储到数据库规则方法</span></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//______________________________动态图鉴权_____________________________________________</span></span><br><span class="line">                    <span class="comment">//所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span></span><br><span class="line">                .anyRequest().access(<span class="string">&quot;@MyRBACService.hasPermission(request,authentication)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span></span><br><span class="line"><span class="comment">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span></span><br><span class="line"><span class="comment">     * 设置记住我存储到的数据源是哪个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersistentTokenRepository <span class="title function_">tokenRepository</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>SPEL表达式：</p>
<p><img src="https://s2.loli.net/2022/03/21/nBC3wzYPX4Gocq9.png" alt="image-20220317231517131"></p>
<h2 id="退出登录："><a href="#退出登录：" class="headerlink" title="退出登录："></a>退出登录：</h2><h5 id="最简单的实现"><a href="#最简单的实现" class="headerlink" title="最简单的实现"></a><strong>最简单的实现</strong></h5><p>后端配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.logout()//开启退出登录</span><br></pre></td></tr></table></figure>



<p>前端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;/logout&quot;&gt;退出登录&lt;/a&gt;</span><br></pre></td></tr></table></figure>





<h5 id="Logout的默认行为"><a href="#Logout的默认行为" class="headerlink" title="Logout的默认行为"></a>Logout的默认行为</h5><p>1，当前session失效，即: logout的核心需求，session失效就是访问权限的回收</p>
<p>2，删除当前用户的remember-me“记住我”功能信息，数据库中的也会删除</p>
<p>3，clear清除当前的SecurityContext ，可以看做清除了也会的主体信息等</p>
<p>4，重定向到登录页面，loginPage配置项指定的页面</p>
<h5 id="个性化配置-1"><a href="#个性化配置-1" class="headerlink" title="个性化配置"></a>个性化配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.logoutSuccessUrl(<span class="string">&quot;/&quot;</span>) <span class="comment">//退出后跳转的页面  默认退出到login页面</span></span><br><span class="line">.deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>) <span class="comment">//退出后要删除的cookie 参数是cookie名称</span></span><br><span class="line">.logoutUrl(<span class="string">&quot;/logout&quot;</span>)  <span class="comment">//退出请求路径，也就是页面上退出登录的路径，别忘了前端页面也要改  默认logout</span></span><br></pre></td></tr></table></figure>





<h5 id="LogoutSuccessHandler-实现个性化规程功能"><a href="#LogoutSuccessHandler-实现个性化规程功能" class="headerlink" title="LogoutSuccessHandler:实现个性化规程功能"></a>LogoutSuccessHandler:实现个性化规程功能</h5><p>注意，不要与logoutSuccessUrl以前使用，否则会失效</p>
<p><strong>自定义类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义退出后需要进行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLogoutSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行重新方法失效个性化退出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response  响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication  主体信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;附加逻辑代码..........&quot;</span>);</span><br><span class="line"></span><br><span class="line">        response.sendRedirect(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Security配置类:</strong>	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//退出登录自定义策略</span><br><span class="line">@Autowired</span><br><span class="line">private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        //开启formLogin登录认证</span><br><span class="line">        http.</span><br><span class="line">                logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br></pre></td></tr></table></figure>



<p><strong>完整Security配置类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将我们自定义的这两个类使用IOC容器装配</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  <span class="comment">//登录成功处理</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;  <span class="comment">//登录失败处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//导入自定义动态授权</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出登录自定义策略</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//开启httpBasic认证</span></span><br><span class="line"><span class="comment">//        http.httpBasic()</span></span><br><span class="line"><span class="comment">//                .and()</span></span><br><span class="line"><span class="comment">//                //所有的请求</span></span><br><span class="line"><span class="comment">//                .authorizeHttpRequests()</span></span><br><span class="line"><span class="comment">//                //匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//_______________________________________________________________________________________________________-</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启formLogin登录认证</span></span><br><span class="line">        http.</span><br><span class="line">                logout()<span class="comment">//开启退出登录</span></span><br><span class="line"><span class="comment">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span></span><br><span class="line">                .deleteCookies(<span class="string">&quot;JSESSIONID&quot;</span>) <span class="comment">//指定退出后要删除的cookie</span></span><br><span class="line">                .logoutUrl(<span class="string">&quot;/logout&quot;</span>)  <span class="comment">//退出请求路径，也就是页面上退出登录访问的地址  默认logout</span></span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) <span class="comment">//使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()<span class="comment">//开启记住我功能  ，前端也需要有记住我字段</span></span><br><span class="line">                .rememberMeCookieName(<span class="string">&quot;rememberMe-Cookie&quot;</span>)  <span class="comment">//存在浏览器中cookie的名称</span></span><br><span class="line">                .rememberMeParameter(<span class="string">&quot;remember-me&quot;</span>)  <span class="comment">//表单中 自动登录 勾选框的参数名</span></span><br><span class="line">                .tokenValiditySeconds(<span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>) <span class="comment">//保存Cookie的有效期，默认2周</span></span><br><span class="line">                .tokenRepository(tokenRepository())  <span class="comment">//指定rememberMe存储到数据库规则方法</span></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  <span class="comment">//关闭防御csrf攻击</span></span><br><span class="line">                .formLogin()<span class="comment">//开启formLogin登录认证</span></span><br><span class="line">                .loginPage(<span class="string">&quot;/logins&quot;</span>)    <span class="comment">//用于选择登录页面，没认证时跳转的页面</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//选择需要认证的请求，也就是登录表单的提交地址</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;user&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是用户名</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)   <span class="comment">//选择登录请求的哪个参数是密码</span></span><br><span class="line">                <span class="comment">//使用自定义的登录失败成功处理方法</span></span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  <span class="comment">//登录成功</span></span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  <span class="comment">//登录失败</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span></span><br><span class="line"><span class="comment">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span></span><br><span class="line"><span class="comment">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span></span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() <span class="comment">//自定义过滤拦截请求</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/logins&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">//资源路径</span></span><br><span class="line">                .permitAll()  <span class="comment">//当前资源路径不需要认证就可以访问</span></span><br><span class="line">                <span class="comment">//____________________静态鉴权____________________________________</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/business1&quot;,&quot;/business2&quot;)//资源路径</span></span><br><span class="line"><span class="comment">//                .hasAnyAuthority(&quot;ROLE_user&quot;,&quot;ROLE_admin&quot;)//设置可以访问的角色,user角色和admin角色都可以访问</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    //访问角色控制方式1  与授权方法1一起使用</span></span><br><span class="line"><span class="comment">//                .antMatchers(&quot;/log&quot;,&quot;/user&quot;)//资源路径</span></span><br><span class="line"><span class="comment">//                .hasRole(&quot;admin&quot;)//设置可以访问的角色，和hasAnyAuthority作用相同，但hasAnyAuthority可以设置多个，并且需要加前缀ROLE_</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                    //访问角色控制方式2  与授权方法2一起使用  这里由于它不是admin角色了，所有访问业务1业务2访问不了但可以修改一下</span></span><br><span class="line"><span class="comment">////                .antMatchers(&quot;/user&quot;).hasAnyAuthority(&quot;sys:user&quot;)  // /user资源路径 必须拥有sys:user角色才可访问</span></span><br><span class="line"><span class="comment">////                .antMatchers(&quot;/log&quot;).hasAnyAuthority(&quot;sys:log&quot;) // /log资源路径 必须拥有sys:log角色才可访问</span></span><br><span class="line"><span class="comment">//                //选择的匹配规则</span></span><br><span class="line"><span class="comment">//                .anyRequest()</span></span><br><span class="line"><span class="comment">//                //所有请求都需要登录认证才可以访问</span></span><br><span class="line"><span class="comment">//                .authenticated()</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//______________________________动态图鉴权_____________________________________________</span></span><br><span class="line">                    <span class="comment">//所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span></span><br><span class="line">                .anyRequest().access(<span class="string">&quot;@MyRBACService.hasPermission(request,authentication)&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()<span class="comment">//启用session管理</span></span><br><span class="line">                .maximumSessions(<span class="number">1</span>)<span class="comment">//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span></span><br><span class="line">                .maxSessionsPreventsLogin(<span class="literal">false</span>)<span class="comment">//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span></span><br><span class="line">                .expiredSessionStrategy(<span class="keyword">new</span> <span class="title class_">CustomExpiredSessionStrategy</span>());  <span class="comment">//session超时，被踢下线的自定义操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//.authorizeHttpRequests()   这样方法表示选中的请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//____________________静态授权________________________</span></span><br><span class="line"><span class="comment">//                auth  //授权</span></span><br><span class="line"><span class="comment">//                .inMemoryAuthentication()  //将这种用户添加到内存中登录认证，   还有其他类型的授权登录认证方法，比如数据库的登录认证</span></span><br><span class="line"><span class="comment">//                .withUser(&quot;user&quot;)  //用户名</span></span><br><span class="line"><span class="comment">//                .password(passwordEncoder().encode(&quot;123456&quot;))  //密码</span></span><br><span class="line"><span class="comment">//                .roles(&quot;user&quot;)  //设置使用该用户名登录赋予的角色，</span></span><br><span class="line"><span class="comment">//            .and()</span></span><br><span class="line"><span class="comment">//                 .withUser(&quot;admin&quot;) //用户名</span></span><br><span class="line"><span class="comment">//                 .password(passwordEncoder().encode(&quot;123456&quot;))</span></span><br><span class="line"><span class="comment">//                   //第一种授权方式</span></span><br><span class="line"><span class="comment">//                 .roles(&quot;admin&quot;)  //设置使用该账号登录赋予的角色</span></span><br><span class="line"><span class="comment">//                   //第二种授权方式</span></span><br><span class="line"><span class="comment">//                 //.authorities(&quot;sys:log&quot;,&quot;sys:user&quot;) //</span></span><br><span class="line"><span class="comment">//                    .and().passwordEncoder(passwordEncoder()); //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">        <span class="comment">//________________ 动态授权，需要实现UserDetailsService____________________________</span></span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  <span class="comment">//配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径开放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> web</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>,<span class="string">&quot;/fonts/**&quot;</span>,<span class="string">&quot;/img/**&quot;</span>,<span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span></span><br><span class="line"><span class="comment">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span></span><br><span class="line"><span class="comment">     * 设置记住我存储到的数据源是哪个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersistentTokenRepository <span class="title function_">tokenRepository</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="Session方式实现图片验证码"><a href="#Session方式实现图片验证码" class="headerlink" title="Session方式实现图片验证码:"></a>Session方式实现图片验证码:</h2><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><p>我们需要先导入工具类库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--   验证码工具类库  这是Google提供的一个类库   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://s2.loli.net/2022/03/21/UtEnrpe3u1wLfqc.png" alt="image-20220312105200767"></p>
<p>如何我们需要这个类库配置一下参数，</p>
<p>有两种方式，第一种是使用application.properties 这种方式直接配置，第二种就是自己直接手动配置</p>
<h5 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a><strong>第一种方式：</strong></h5><p>直接将配置文件写入</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">kaptcha.border</span>=<span class="string">no</span></span><br><span class="line"><span class="attr">kaptcha.border.color</span>=<span class="string">105,179,90</span></span><br><span class="line"><span class="attr">kaptcha.image.width</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">kaptcha.image.height</span>=<span class="string">45</span></span><br><span class="line"><span class="attr">kaptcha.session.key</span>=<span class="string">code</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.color</span>=<span class="string">blue</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.size</span>=<span class="string">35</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.names</span>=<span class="string">宋体,楷体,微软雅黑</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.char.length</span>=<span class="string">4</span></span><br></pre></td></tr></table></figure>



<h5 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a><strong>第二种方式：</strong></h5><p>先创建一个properties的普通文件再将这些导入：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">kaptcha.border</span>=<span class="string">no</span></span><br><span class="line"><span class="attr">kaptcha.border.color</span>=<span class="string">105,179,90</span></span><br><span class="line"><span class="attr">kaptcha.image.width</span>=<span class="string">100</span></span><br><span class="line"><span class="attr">kaptcha.image.height</span>=<span class="string">45</span></span><br><span class="line"><span class="attr">kaptcha.session.key</span>=<span class="string">code</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.color</span>=<span class="string">blue</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.size</span>=<span class="string">35</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.font.names</span>=<span class="string">宋体,楷体,微软雅黑</span></span><br><span class="line"><span class="attr">kaptcha.textproducer.char.length</span>=<span class="string">4</span></span><br></pre></td></tr></table></figure>



<h5 id="再创建一个配置类："><a href="#再创建一个配置类：" class="headerlink" title="再创建一个配置类："></a><strong>再创建一个配置类：</strong></h5><p>这个是使用的第二种方式，所以我们这个需要使用@PropertySource()去导入一下我们的properties文件，如何使用2Value注入下 </p>
<p>其实两种方式都一样，只是一个需要使用@PropertySource() 去导入，一个可以直接使用@Value注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:kaptcha.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KaptChaConf</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.border&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String border;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.border.color&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String borderColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.textproducer.font.color&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fontColor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.image.width&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String imageWidth;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.image.height&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String imageHeight;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.session.key&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sessionKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.textproducer.char.length&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String charLength;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.textproducer.font.names&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fontNames;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;kaptcha.textproducer.font.size&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String fontSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;captchaProducer&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultKaptcha <span class="title function_">getKaptCha</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//拥有创建谜底和谜面的方法, createImage(String text)创建谜面图片，createText()创建谜底文字</span></span><br><span class="line">        <span class="type">DefaultKaptcha</span> <span class="variable">defaultKaptcha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultKaptcha</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border&quot;</span>,border);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.border.color&quot;</span>,borderColor);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.width&quot;</span>,imageWidth);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.image.height&quot;</span>,imageHeight);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.session.key&quot;</span>,sessionKey);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.color&quot;</span>,fontColor);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.size&quot;</span>,fontSize);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.font.names&quot;</span>,fontNames);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;kaptcha.textproducer.char.length&quot;</span>,charLength);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置Kaptcha的配置 ,</span></span><br><span class="line">        defaultKaptcha.setConfig(<span class="keyword">new</span> <span class="title class_">Config</span>(properties));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> defaultKaptcha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="实现图片验证码加载："><a href="#实现图片验证码加载：" class="headerlink" title="实现图片验证码加载："></a>实现图片验证码加载：</h3><h5 id="存储谜底与验证码过期时间类"><a href="#存储谜底与验证码过期时间类" class="headerlink" title="存储谜底与验证码过期时间类"></a>存储谜底与验证码过期时间类</h5><p>由于图片验证码有过期时间，我们需要先创建一个类了存储我们图片验证码的谜底与过期数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储谜底与验证码过期时间</span></span><br><span class="line"><span class="comment"> * 用于实现验证码过期，所有创建此类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptchaImageVo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String captchaCode; <span class="comment">//验证码谜底</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;  <span class="comment">//验证码过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> captchaCode  谜底</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireAfterSeconds  过期秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CaptchaImageVo</span><span class="params">(String captchaCode,<span class="type">int</span> expireAfterSeconds)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.captchaCode=captchaCode;</span><br><span class="line">        <span class="comment">//当前时间加上指定的秒数</span></span><br><span class="line">        <span class="built_in">this</span>.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断验证码是否过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpired</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断当前时间是否大于过期时间，大于则失效</span></span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().isAfter(expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取captchaCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCoed</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> captchaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="验证码图片Controller："><a href="#验证码图片Controller：" class="headerlink" title="验证码图片Controller："></a>验证码图片Controller：</h5><p>我们需要将验证码图片输出到页面，所以我们需要一个controller用来输出，图片我们需要使用流来输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CaptchaController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DefaultKaptcha defaultKaptcha;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/kaptcha&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kaptcha</span><span class="params">(HttpSession session, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        response.setDateHeader(<span class="string">&quot;Expires&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-store, no-cache, must-revalidate&quot;</span>);</span><br><span class="line">        response.addHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;post-check=0, pre-check=0&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Pragma&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        <span class="comment">//获取谜底</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> defaultKaptcha.createText();</span><br><span class="line">        <span class="comment">//将谜底与过期时间放到session中</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;captcha_key&quot;</span>,<span class="keyword">new</span> <span class="title class_">CaptchaImageVo</span>(text,<span class="number">2</span>*<span class="number">60</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个方式使用我们不用自己去关闭流，它自动关闭，这是jdk7的语法</span></span><br><span class="line">        <span class="keyword">try</span>(ServletOutputStream out=response.getOutputStream())&#123;</span><br><span class="line">            <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> defaultKaptcha.createImage(text);</span><br><span class="line">            <span class="comment">//将图片以Io输出， 参数： 图片的字节 ， 图片格式 ，输入流</span></span><br><span class="line">            ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>,out);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每当缓冲区数据进入满载状态时，会对数据进行一次写出。</span></span><br><span class="line">            <span class="comment">// 假如最后一次的数据量没有达到让缓冲区进入满载状态，这时候不主动调用flush()方法缓冲区数据将会丢失</span></span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="前端接收："><a href="#前端接收：" class="headerlink" title="前端接收："></a>前端接收：</h5><p>千万记着鉴权那开放访问权限</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    验证码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;captchaCoed&quot;</span> <span class="attr">name</span>=<span class="string">&quot;captchaCoed&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/kaptcha&quot;</span> <span class="attr">id</span>=<span class="string">&quot;kaptcha&quot;</span> <span class="attr">width</span>=<span class="string">&quot;110px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;40px&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;login()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line">     记住我<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember-me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;remember-me&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//用于点击刷新验证码图片</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#kaptcha&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#kaptcha&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;/kaptcha?&quot;</span>+<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">100</span>))</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> username=$(<span class="string">&quot;#username&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> password=$(<span class="string">&quot;#password&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> remember=$(<span class="string">&quot;#remember-me&quot;</span>).<span class="title function_">prop</span>(<span class="string">&quot;checked&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(remember)</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;/login&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;user&quot;</span>: username,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;password&quot;</span>: password,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;remember-me&quot;</span>:remember</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">json</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">if</span> (json.<span class="property">state</span> == <span class="number">200</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                  <span class="title function_">alert</span>(json.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">                  <span class="variable language_">console</span>.<span class="title function_">log</span>(json)</span></span><br><span class="line"><span class="language-javascript">                  location.<span class="property">href</span>=<span class="string">&quot;/logins&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="图片验证码验证："><a href="#图片验证码验证：" class="headerlink" title="图片验证码验证："></a>图片验证码验证：</h3><p><img src="https://s2.loli.net/2022/03/21/v839L1PAlIVgajO.png" alt="image-20220313101138743"></p>
<p>如图所示，我们需要创建一个验证码过滤器，并且在usernamepasswordAuthentionFilter之前执行</p>
<h5 id="在这其中要我们需要修改下原来的登录错误处理类："><a href="#在这其中要我们需要修改下原来的登录错误处理类：" class="headerlink" title="在这其中要我们需要修改下原来的登录错误处理类："></a><strong>在这其中要我们需要修改下原来的登录错误处理类：</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 登录失败后进行的操作</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class MyAuthenticationFailureHandler</span><br><span class="line">    extends SimpleUrlAuthenticationFailureHandler &#123;</span><br><span class="line"></span><br><span class="line">    //注意这个一定要使用el表达式，否则这个方法都不会进</span><br><span class="line">    @Value(&quot;$&#123;spring.security.loginType&#125;&quot;)</span><br><span class="line">    private String loginType;</span><br><span class="line"></span><br><span class="line">    //用于将对象转换为json格式</span><br><span class="line">    private static ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录失败后进行操作</span><br><span class="line">     * @param request 请求</span><br><span class="line">     * @param response 响应</span><br><span class="line">     * @param exception  异常</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws ServletException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        //错误信息</span><br><span class="line">        String errorMsg=&quot;登录失败,用户名或密码错误&quot;;</span><br><span class="line"></span><br><span class="line">        //判断异常是否是SessionAuthenticationException类型，这个类型是验证码校验那抛出的异常</span><br><span class="line">        if (exception instanceof SessionAuthenticationException)&#123;</span><br><span class="line">            //将错误信息赋给错误信息返回出去</span><br><span class="line">            errorMsg=exception.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断要返回的类型</span><br><span class="line">        if (loginType.equalsIgnoreCase(&quot;JSON&quot;))&#123;</span><br><span class="line">            //告诉浏览器，以json返回</span><br><span class="line">            response.setContentType(&quot;application/json;charset=UTF-8&quot;);</span><br><span class="line">            //要返回的数据</span><br><span class="line">            response.getWriter().write(objectMapper.writeValueAsString(new JsonResult&lt;&gt;().InputError(errorMsg)));</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //登录失败后进行的页面跳转，父类已经为我们实现了</span><br><span class="line">            response.setContentType(&quot;application/html;charset=UTF-8&quot;);</span><br><span class="line">            super.onAuthenticationFailure(request, response, exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="并且我们定义一个常量类，为了跟方便记住重复参数信息："><a href="#并且我们定义一个常量类，为了跟方便记住重复参数信息：" class="headerlink" title="并且我们定义一个常量类，为了跟方便记住重复参数信息："></a><strong>并且我们定义一个常量类，为了跟方便记住重复参数信息：</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CaptchaConstant &#123;</span><br><span class="line">    public static final String CAPTCHA_SESSION_KEY=&quot;captcha_key&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="创建过滤器："><a href="#创建过滤器：" class="headerlink" title="创建过滤器："></a>创建过滤器：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义过滤器 ，在登录身份校验前先进行检查，验证码是否正确</span><br><span class="line"> * 也可以使用Filter</span><br><span class="line"> * OncePerRequestFilter是Filter的实现类</span><br><span class="line"> * OncePerRequestFilter 每次登录都拦截一次，</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class CaptchaCodeFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是我们自定义登录失败的处理方式</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">                                    HttpServletResponse response,</span><br><span class="line">                                    FilterChain filterChain)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        //判断当前请求是否是向/login发送请求，并且是以post请求提交的</span><br><span class="line">        if (&quot;/login&quot;.equals(request.getRequestURI())</span><br><span class="line">                &amp;&amp; &quot;post&quot;.equalsIgnoreCase(request.getMethod()))&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                //验证码校验操作</span><br><span class="line">                captchaVerify(request);</span><br><span class="line">            &#125;catch (AuthenticationException e)&#123;</span><br><span class="line">                //SessionAuthenticationException这个异常是继承了AuthenticationException的</span><br><span class="line">                //我们自定义异常时同样也需继承AuthenticationException</span><br><span class="line">                //我们将错误处理交给登录实现处理类进行操作</span><br><span class="line">                myAuthenticationFailureHandler.onAuthenticationFailure(request,response,e);</span><br><span class="line">                //由于这里已经是发生了异常的，我们就不能让程序再进行往下走了</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果验证成功后不是登录操作就进行放行</span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证码验证操作</span><br><span class="line">     * 里面的异常是可以自定义的，不一定就要用系统提供的</span><br><span class="line">     */</span><br><span class="line">    private void captchaVerify(HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line">        //获取session，session中有用户的谜底与验证码过期时间</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">        //获取用户输入的验证码</span><br><span class="line">        String captchaCoed = request.getParameter(&quot;captchaCoed&quot;);</span><br><span class="line">        System.out.println(captchaCoed);</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否为空</span><br><span class="line">        if (captchaCoed.trim().isEmpty())&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取我们存入session中的CaptchaImageVo，也就是谜底与过期时间类</span><br><span class="line">        CaptchaImageVo captchaImageVo = (CaptchaImageVo)session.getAttribute(CaptchaConstant.CAPTCHA_SESSION_KEY);</span><br><span class="line">        System.out.println(captchaImageVo.getCoed());</span><br><span class="line">        //判断session中使用有谜底</span><br><span class="line">        if (Objects.isNull(captchaImageVo))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断验证码是否过期</span><br><span class="line">        if (captchaImageVo.isExpired())&#123;</span><br><span class="line">            //移出以前的CaptchaImageVo</span><br><span class="line">            session.removeAttribute(CaptchaConstant.CAPTCHA_SESSION_KEY);</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否与谜底一致，getCoed()这个方法就是单纯的获取captchaImageVo中的coed</span><br><span class="line">        if (!captchaCoed.trim().equalsIgnoreCase(captchaImageVo.getCoed()))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不匹配&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Security配置类：-1"><a href="#Security配置类：-1" class="headerlink" title="Security配置类："></a>Security配置类：</h5><p>在配置中配置在UsernamePasswordAuthenticationFilter之前插入我们创建的过滤器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将我们自定义的这两个类使用IOC容器装配</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  //登录成功处理</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;  //登录失败处理</span><br><span class="line"></span><br><span class="line">    //导入自定义动态授权</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    //退出登录自定义策略</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    //验证码过滤器</span><br><span class="line">    @Autowired</span><br><span class="line">    private CaptchaCodeFilter captchaCodeFilter;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //开启formLogin登录认证</span><br><span class="line">        http.</span><br><span class="line">                //将验证码过滤器放置在UsernamePasswordAuthenticationFilter过滤器之前执行，AOP思想</span><br><span class="line">                addFilterBefore(captchaCodeFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  //关闭防御csrf攻击</span><br><span class="line">                .formLogin()//开启formLogin登录认证</span><br><span class="line">                .loginPage(&quot;/logins&quot;)    //用于选择登录页面，没认证时跳转的页面</span><br><span class="line">                .loginProcessingUrl(&quot;/login&quot;)   //选择需要认证的请求，也就是登录表单的提交地址</span><br><span class="line">                .usernameParameter(&quot;user&quot;)   //选择登录请求的哪个参数是用户名</span><br><span class="line">                .passwordParameter(&quot;password&quot;)   //选择登录请求的哪个参数是密码</span><br><span class="line">                //使用自定义的登录失败成功处理方法</span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  //登录成功</span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  //登录失败</span><br><span class="line"></span><br><span class="line">                //这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span><br><span class="line">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span><br><span class="line">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span><br><span class="line">             .and()</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/logins&quot;,&quot;/login&quot;,&quot;/&quot;,&quot;/kaptcha&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line">                //______________________________动态图鉴权_____________________________________________</span><br><span class="line">                    //所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问</span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .maximumSessions(1)//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span><br><span class="line">                .maxSessionsPreventsLogin(false)//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span><br><span class="line">                .expiredSessionStrategy(new CustomExpiredSessionStrategy());  //session超时，被踢下线的自定义操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //________________ 动态授权，需要实现UserDetailsService____________________________</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="手机号验证码登录："><a href="#手机号验证码登录：" class="headerlink" title="手机号验证码登录："></a>手机号验证码登录：</h2><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><img src="https://s2.loli.net/2022/03/21/7jINUlQWAoY1edS.png" alt="image-20220316233213777"></p>
<p><strong>使用到的常量：</strong>public static final String PHONE_SESSION_KEY &#x3D; “phoneCaptcha”;</p>
<p>这是我们实现短信验证码登录需要实现发：SMS 在我这用Phone代替</p>
<p>我们需要先创建一个为我们提供发送的验证码的Controller，这个很好理解吧，点击获取验证码，如何发送短信验证码至手机号短信</p>
<h3 id="controller："><a href="#controller：" class="headerlink" title="controller："></a>controller：</h3><p>创建验证码并发送给用户手机号，还有放入session以便登录验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">public class phoneController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    //创建手机验证码</span><br><span class="line">    @GetMapping(&quot;/smscode&quot;)</span><br><span class="line">    public JsonResult sms(String phone , HttpSession session)&#123;</span><br><span class="line"></span><br><span class="line">        //判断当前号码用户是否存在</span><br><span class="line">        try &#123;</span><br><span class="line">            UserDetails userDetails = myUserDetailsService.loadUserByUsername(phone);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            return new JsonResult().InputError(&quot;当前号码还未注册&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //创建一个验证码信息类，存放验证码（验证码使用随机生成），过期时间，电话号码，</span><br><span class="line">        int captcha = new Random().nextInt(9999);  //随机生成验证码</span><br><span class="line">        PhoneCaptchaVo phoneCaptchaVo = new PhoneCaptchaVo(String.valueOf(captcha),60,phone);</span><br><span class="line"></span><br><span class="line">        ///TODO 调用短信服务提供商的接口发送短信</span><br><span class="line">        log.info(phoneCaptchaVo.getCode()+&quot;  &gt;&gt; 验证码已发送至 &quot;  +phone );</span><br><span class="line"></span><br><span class="line">        session.setAttribute(&quot;phoneCaptcha&quot;,phoneCaptchaVo);</span><br><span class="line"></span><br><span class="line">        return new JsonResult().success(&quot;验证码已发送&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们可以看到有给PhoneCaptchaVo 其实就和图片验证码一样，需要的类封装我们的验证基本信息，再放入session</p>
<h3 id="PhoneCaptchaVo"><a href="#PhoneCaptchaVo" class="headerlink" title="PhoneCaptchaVo :"></a>PhoneCaptchaVo :</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PhoneCaptchaVo &#123;</span><br><span class="line"></span><br><span class="line">    private String captchaCode; //验证码谜底</span><br><span class="line">    private LocalDateTime expireTime;  //验证码过期时间</span><br><span class="line">    private String phone;  //电话号码</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于初始化</span><br><span class="line">     * @param captchaCode  谜底</span><br><span class="line">     * @param expireAfterSeconds  过期秒数</span><br><span class="line">     */</span><br><span class="line">    public PhoneCaptchaVo(String captchaCode,int expireAfterSeconds,String phone)&#123;</span><br><span class="line">        this.captchaCode=captchaCode;</span><br><span class="line">        //当前时间加上指定的秒数</span><br><span class="line">        this.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds);</span><br><span class="line">        this.phone=phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断验证码是否过期</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public boolean isExpired()&#123;</span><br><span class="line">        //判断当前时间是否大于过期时间，大于则失效</span><br><span class="line">        return LocalDateTime.now().isAfter(expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取captchaCode</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String getCode()&#123;</span><br><span class="line">        return captchaCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回电话号码</span><br><span class="line">    public String getPhone()&#123;</span><br><span class="line">        return phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>这样我们的第一步就完成了，以创建并发送验证码，</p>
<h3 id="使用过滤器进行谜底验证："><a href="#使用过滤器进行谜底验证：" class="headerlink" title="使用过滤器进行谜底验证："></a>使用过滤器进行谜底验证：</h3><p>当我们登录时我们需要进行登录信息的确认，还有谜底对比</p>
<p>这样我们就完成了基本的验证，但这样我们是无法使用的，因为的短信登录请求&#x2F;PhoneLogin是无法向&#x2F;login一样被识别的</p>
<p>我们还需要创建PhoneAuthenticationFilter ，就像UsernamePasswordAuthenticationFilter一样，如果给login请求就进行登录的一系列操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 短信验证码登录验证的过滤器，与我们图片验证码的过滤器可以说是一模一样</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class PhoneCodeValidateFilter  extends OncePerRequestFilter &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 这是我们自定义登录失败的处理方式</span><br><span class="line">     */</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request,</span><br><span class="line">                                    HttpServletResponse response,</span><br><span class="line">                                    FilterChain filterChain)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        //判断当前请求是否是向/login发送请求，并且是以post请求提交的</span><br><span class="line">        if (&quot;/PhoneLogin&quot;.equals(request.getRequestURI())</span><br><span class="line">                &amp;&amp; &quot;post&quot;.equalsIgnoreCase(request.getMethod()))&#123;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                //验证码校验操作</span><br><span class="line">                captchaVerify(request);</span><br><span class="line">            &#125;catch (AuthenticationException e)&#123;</span><br><span class="line">                //SessionAuthenticationException这个异常是继承了AuthenticationException的</span><br><span class="line">                //我们自定义异常时同样也需继承AuthenticationException</span><br><span class="line">                //我们将错误处理交给登录实现处理类进行操作</span><br><span class="line">                myAuthenticationFailureHandler.onAuthenticationFailure(request,response,e);</span><br><span class="line">                //由于这里已经是发生了异常的，我们就不能让程序再进行往下走了</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果验证成功后不是登录操作就进行放行</span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证码验证操作</span><br><span class="line">     * 里面的异常是可以自定义的，不一定就要用系统提供的</span><br><span class="line">     */</span><br><span class="line">    private void captchaVerify(HttpServletRequest request)&#123;</span><br><span class="line"></span><br><span class="line">        //获取session，session中有用户的谜底与验证码过期时间</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">        //获取用户输入的验证码</span><br><span class="line">            String phone = request.getParameter(&quot;phone&quot;); //输入的手机号码</span><br><span class="line">            String phoneCode = request.getParameter(&quot;phoneCode&quot;); //输入的验证码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //判断用户输入的手机号是否为空</span><br><span class="line">        if (phone.trim().isEmpty())&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;手机号不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否为空</span><br><span class="line">        if (phoneCode.trim().isEmpty())&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取我们存入session中的CaptchaImageVo，也就是谜底与过期时间类</span><br><span class="line">        PhoneCaptchaVo phoneCaptchaVo = (PhoneCaptchaVo) session.getAttribute(CaptchaConstant.PHONE_SESSION_KEY);</span><br><span class="line"></span><br><span class="line">        //判断session中使用有谜底</span><br><span class="line">        if (Objects.isNull(phoneCaptchaVo))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断验证码是否过期</span><br><span class="line">        if (phoneCaptchaVo.isExpired())&#123;</span><br><span class="line">            //移出以前的CaptchaImageVo</span><br><span class="line">            session.removeAttribute(CaptchaConstant.PHONE_SESSION_KEY);</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否与谜底一致</span><br><span class="line">        if (!phoneCode.trim().equalsIgnoreCase(phoneCaptchaVo.getCode()))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;验证码不匹配&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //判断用户输入的验证码是否与谜底一致</span><br><span class="line">        if (!phone.trim().equalsIgnoreCase(phoneCaptchaVo.getPhone()))&#123;</span><br><span class="line">            throw new SessionAuthenticationException(&quot;手机号不匹配&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //验证完后删除验证码，不管成功还是失败</span><br><span class="line">        session.removeAttribute(CaptchaConstant.PHONE_SESSION_KEY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="短信鉴定登录过滤器："><a href="#短信鉴定登录过滤器：" class="headerlink" title="短信鉴定登录过滤器："></a>短信鉴定登录过滤器：</h3><p><img src="https://s2.loli.net/2022/03/21/XhP7JmLgucOi5sI.png" alt="image-20220316234227700"></p>
<p>如果所示，我们需要自定义我们的短信登录日志过滤器，当我们短信登录进来时绕过用户名密码登录过滤器。而是走我们自定义的过滤器</p>
<h4 id="实现图中第一个步骤"><a href="#实现图中第一个步骤" class="headerlink" title="实现图中第一个步骤:"></a>实现图中第一个步骤:</h4><p>创建自定义鉴定过滤器</p>
<h5 id="PhoneAuthenticationFilter："><a href="#PhoneAuthenticationFilter：" class="headerlink" title="PhoneAuthenticationFilter："></a>PhoneAuthenticationFilter：</h5><p>这个类就是图中的SmsCodeAuthenticationFilter</p>
<p>这个我们可以模仿UsernamePasswordAuthenticationFilter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 由于我们需要为手机号登录，</span><br><span class="line"> * 我们可以仿照UsernamePasswordAuthenticationFilter用户名密码登录创建一个手机号登录过滤器交给Security</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class PhoneAuthenticationFilter extends AbstractAuthenticationProcessingFilter &#123;</span><br><span class="line"></span><br><span class="line">    public static final String SPRING_SECURITY_FORM_PHONE_KEY = &quot;phone&quot;;</span><br><span class="line">    private static final AntPathRequestMatcher DEFAULT_ANT_PATH_REQUEST_MATCHER = new AntPathRequestMatcher(&quot;/PhoneLogin&quot;, &quot;POST&quot;);</span><br><span class="line">    private String phoneParameter = &quot;phone&quot;;</span><br><span class="line">    private boolean postOnly = true;</span><br><span class="line"></span><br><span class="line">    public PhoneAuthenticationFilter() &#123;</span><br><span class="line">        super(DEFAULT_ANT_PATH_REQUEST_MATCHER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PhoneAuthenticationFilter(AuthenticationManager authenticationManager) &#123;</span><br><span class="line">        super(DEFAULT_ANT_PATH_REQUEST_MATCHER, authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;</span><br><span class="line">        if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;</span><br><span class="line">            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String phone = this.obtainPhone(request);</span><br><span class="line">            phone = phone != null ? phone : &quot;&quot;;</span><br><span class="line"></span><br><span class="line">            //我们需要自己创建一个PhoneAuthenticationToken，可以模仿UserNameAuthenticationToken</span><br><span class="line">            PhoneAuthenticationToken authRequest = new PhoneAuthenticationToken(phone);</span><br><span class="line">            this.setDetails(request, authRequest);</span><br><span class="line">            return this.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    protected String obtainPhone(HttpServletRequest request) &#123;</span><br><span class="line">        return request.getParameter(this.phoneParameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void setDetails(HttpServletRequest request, PhoneAuthenticationToken authRequest) &#123;</span><br><span class="line">        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPhoneParameter(String usernameParameter) &#123;</span><br><span class="line">        Assert.hasText(usernameParameter, &quot;Phone parameter must not be empty or null&quot;);</span><br><span class="line">        this.phoneParameter = usernameParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPostOnly(boolean postOnly) &#123;</span><br><span class="line">        this.postOnly = postOnly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final String getUsernameParameter() &#123;</span><br><span class="line">        return this.phoneParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>再改写这个PhoneAuthenticationFilter类时我们发现UsernamePasswordAuthenticationToken令牌不是我们需要的，所以我们同样要改写，去自定义一个</p>
<p><strong>解下UsernamePasswordAuthenticationToken：</strong></p>
<p>通过类名可以的看出来，用户名密码方式进行认证。就是我们见的最多的认证方式通过用户名密码进行登录。咱们话不多说看看具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsernamePasswordAuthenticationToken</span> <span class="keyword">extends</span> <span class="title class_">AbstractAuthenticationToken</span> &#123;</span><br><span class="line">    <span class="comment">// 序列化id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">530L</span>;</span><br><span class="line">    <span class="comment">// 一般指的是用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line">    <span class="comment">// 一般指的是密码</span></span><br><span class="line">    <span class="keyword">private</span> Object credentials;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">// principal  一般指的是用户名</span></span><br><span class="line">    <span class="comment">// credentials  一般指的是密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化父类构造 权限集合为空</span></span><br><span class="line">        <span class="built_in">super</span>((Collection)<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        <span class="comment">// 设置是否已认证 默认为false</span></span><br><span class="line">        <span class="built_in">this</span>.setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">     <span class="comment">// principal  一般指的是用户名</span></span><br><span class="line">    <span class="comment">// credentials  一般指的是密码</span></span><br><span class="line">    <span class="comment">// authorities 权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> &#123;</span><br><span class="line">       <span class="comment">// // 初始化父类构造 权限集合</span></span><br><span class="line">        <span class="built_in">super</span>(authorities);</span><br><span class="line">        <span class="built_in">this</span>.principal = principal;</span><br><span class="line">        <span class="built_in">this</span>.credentials = credentials;</span><br><span class="line">        <span class="comment">// 设置父类方法表示已经认证</span></span><br><span class="line">        <span class="built_in">super</span>.setAuthenticated(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取密码</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.credentials;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取用户名</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.principal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置是否已认证 默认为false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="comment">// 如果为true</span></span><br><span class="line">        <span class="comment">// 抛出非法参数异常</span></span><br><span class="line">        <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 设置父类是否已认证</span></span><br><span class="line">            <span class="built_in">super</span>.setAuthenticated(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 擦除凭证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eraseCredentials</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">// 调用父类方法</span></span><br><span class="line">        <span class="built_in">super</span>.eraseCredentials();</span><br><span class="line">        <span class="comment">// 将密码设置为空</span></span><br><span class="line">        <span class="built_in">this</span>.credentials = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="PhoneAuthenticationToken："><a href="#PhoneAuthenticationToken：" class="headerlink" title="PhoneAuthenticationToken："></a>PhoneAuthenticationToken：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PhoneAuthenticationToken  extends AbstractAuthenticationToken &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 560L;</span><br><span class="line">    //存放认证信息，认证之前放的是手机号码，认证之后存放UserDetails</span><br><span class="line">    private final Object principal;</span><br><span class="line"></span><br><span class="line">    public PhoneAuthenticationToken(Object principal) &#123;</span><br><span class="line">        super((Collection)null);</span><br><span class="line">        this.principal = principal;</span><br><span class="line">        this.setAuthenticated(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PhoneAuthenticationToken(Object principal, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123;</span><br><span class="line">        super(authorities);</span><br><span class="line">        this.principal = principal;</span><br><span class="line">        super.setAuthenticated(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //由于我们手机号登录不需要密码，这个是获取密码的，我们没有密码就返回null，</span><br><span class="line">    //接口中要求实现</span><br><span class="line">    public Object getCredentials() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getPrincipal() &#123;</span><br><span class="line">        return this.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException &#123;</span><br><span class="line">        Assert.isTrue(!isAuthenticated, &quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;);</span><br><span class="line">        super.setAuthenticated(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eraseCredentials() &#123;</span><br><span class="line">        super.eraseCredentials();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="然后再实现图中第二个步骤："><a href="#然后再实现图中第二个步骤：" class="headerlink" title="然后再实现图中第二个步骤："></a>然后再实现图中第二个步骤：</h4><h5 id="实现鉴定提供者"><a href="#实现鉴定提供者" class="headerlink" title="实现鉴定提供者"></a>实现鉴定提供者</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *创建一个电话号码的鉴定提供者，</span><br><span class="line"> */</span><br><span class="line">public class PhoneAuthenticationProvider implements AuthenticationProvider &#123;</span><br><span class="line"></span><br><span class="line">//这个其实我认为是多余的可以去掉，因为这个我们再使用过滤器进行谜底验证时就已经验证过电话号码的正确性</span><br><span class="line">    private UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    public void setUserDetailsService(UserDetailsService userDetailsService)&#123;</span><br><span class="line">        this.userDetailsService = userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected  UserDetailsService getUserDetailsService()&#123;</span><br><span class="line">        return userDetailsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 具体认证流程</span><br><span class="line">    @Override</span><br><span class="line">    public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</span><br><span class="line">        //获取存放的Token</span><br><span class="line">        PhoneAuthenticationToken phoneAuthenticationToken = (PhoneAuthenticationToken) authentication;</span><br><span class="line">        //phoneAuthenticationToken中的Principal，初始存储的电话号码</span><br><span class="line">        UserDetails userDetails = userDetailsService.loadUserByUsername((String) phoneAuthenticationToken.getPrincipal());</span><br><span class="line"></span><br><span class="line">        //判断使用当前号码是否能获取到用户信息，一般都不会出问题，以为我们在获取验证码时就验证了</span><br><span class="line">        // 也就是PhoneCodeValidateFilter过滤器中验证码了</span><br><span class="line">        if (userDetails == null)&#123;</span><br><span class="line">            throw new InternalAuthenticationServiceException(&quot;无法根据手机号获取用户信息&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //我们在这创建一个Token这次他的Principal就变成了userDetails,</span><br><span class="line">        PhoneAuthenticationToken authenticationToken = new PhoneAuthenticationToken(userDetails,userDetails.getAuthorities());</span><br><span class="line">        //由于我们直接创建的details是没有值的，所以我们要将原来的details赋为我们的details</span><br><span class="line">        authenticationToken.setDetails(phoneAuthenticationToken.getDetails());</span><br><span class="line">        return authenticationToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *    supports函数用来指明该Provider是否适用于该类型的认证，如果不合适，则寻找另一个Provider进行验证处理。</span><br><span class="line">     *    就好比，判断当前Provider是否适用于电话号码的认证，不适合，则寻找另一个Provider进行验证处理。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(Class&lt;?&gt; authentication) &#123;</span><br><span class="line">        //判断当前Provider是否适用于authentication认证</span><br><span class="line">        return PhoneAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>把这个都完成后，再把他们配置到Security配置类中，但是，这个如果配置的话会显得很多，所以我们可以先创建一个电话号码验证单独的配置类，然后再将它放入到核心Security配置类中，</p>
<h5 id="单独配置类"><a href="#单独配置类" class="headerlink" title="单独配置类"></a>单独配置类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 由于要配置电话号码登录配置的话，需要配置很多，</span><br><span class="line"> * 所以我们交配置整合好后在去Security配置类中配置</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class PhoneSecurityConfig extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    //登录信息校验过滤器，也就是过滤登录信息是否正常</span><br><span class="line">    @Autowired</span><br><span class="line">    private PhoneCodeValidateFilter phoneCodeValidateFilter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        //创建一个电话号码登录过滤器，也就是如UsernamePasswordAuthenticationFilter一样的</span><br><span class="line">        PhoneAuthenticationFilter phoneAuthenticationFilter = new PhoneAuthenticationFilter();</span><br><span class="line"></span><br><span class="line">        phoneAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class));</span><br><span class="line">        phoneAuthenticationFilter.setAuthenticationSuccessHandler(myAuthenticationSuccessHandler);//登录成功处理方式</span><br><span class="line">        phoneAuthenticationFilter.setAuthenticationFailureHandler(myAuthenticationFailureHandler);//登录失败处理方式</span><br><span class="line"></span><br><span class="line">        //创建一个我们自定义鉴定提供者，他会自己去匹配当前信息能使用鉴定提供者</span><br><span class="line">        PhoneAuthenticationProvider phoneAuthenticationProvider = new PhoneAuthenticationProvider();</span><br><span class="line">        //其实这个都可以不用，如果不要也就删除PhoneAuthenticationProvider中他对应的操作</span><br><span class="line">        phoneAuthenticationProvider.setUserDetailsService(myUserDetailsService);</span><br><span class="line"></span><br><span class="line">        http.addFilterBefore(phoneCodeValidateFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http.authenticationProvider(phoneAuthenticationProvider)</span><br><span class="line">                .addFilterAfter(phoneAuthenticationFilter,UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Securty配置类："><a href="#Securty配置类：" class="headerlink" title="Securty配置类："></a>Securty配置类：</h5><p>在配置类中加入.apply(phoneSecurityConfig)&#x2F;&#x2F;添加我们的手机号码登录配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //将我们自定义的这两个类使用IOC容器装配</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;  //登录成功处理</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;  //登录失败处理</span><br><span class="line"></span><br><span class="line">    //导入自定义动态授权</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    //退出登录自定义策略</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    //验证码过滤器</span><br><span class="line">    @Autowired</span><br><span class="line">    private CaptchaCodeFilter captchaCodeFilter;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PhoneSecurityConfig phoneSecurityConfig;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //开启formLogin登录认证</span><br><span class="line">        http</span><br><span class="line">                //将验证码过滤器放置在UsernamePasswordAuthenticationFilter过滤器之前执行，AOP思想</span><br><span class="line">                .addFilterBefore(captchaCodeFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  //关闭防御csrf攻击</span><br><span class="line">                .formLogin()//开启formLogin登录认证</span><br><span class="line">                .loginPage(&quot;/logins&quot;)    //用于选择登录页面，没认证时跳转的页面</span><br><span class="line">                .loginProcessingUrl(&quot;/login&quot;)   //选择需要认证的请求，也就是登录表单的提交地址</span><br><span class="line">                .usernameParameter(&quot;user&quot;)   //选择登录请求的哪个参数是用户名</span><br><span class="line">                .passwordParameter(&quot;password&quot;)   //选择登录请求的哪个参数是密码</span><br><span class="line">                //使用自定义的登录失败成功处理方法</span><br><span class="line">                .successHandler(myAuthenticationSuccessHandler)  //登录成功</span><br><span class="line">                .failureHandler(myAuthenticationFailureHandler)  //登录失败</span><br><span class="line"></span><br><span class="line">                //这两会与我们自定义的冲突想要使用自定义的就不能使用这个</span><br><span class="line">//                .defaultSuccessUrl(&quot;/&quot;)   //登录成功跳转的路径</span><br><span class="line">//                .failureForwardUrl(&quot;/logins&quot;)  //登录失败跳转的路径</span><br><span class="line">             .and()</span><br><span class="line">                .apply(phoneSecurityConfig)//添加我们的手机号码登录配置类</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/logins&quot;,&quot;/login&quot;,&quot;/&quot;,&quot;/kaptcha&quot;,&quot;/smscode&quot;,&quot;/PhoneLogin&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //______________________________动态图鉴权_____________________________________________</span><br><span class="line">                    //所有的请求都有经过MyRBACService的hasPermission方法进行鉴权 返回true可以访问，返回false不允许访问，</span><br><span class="line">                    // 也就是验证用户能访问哪些页面</span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .maximumSessions(1)//允许一个账号你个人同时登录，也就是一个session可以几个人同时使用</span><br><span class="line">                .maxSessionsPreventsLogin(false)//false：当登录时，其它登录的登录的地方会被踢下线;true ：当有用户在登录时不允许登录</span><br><span class="line">                .expiredSessionStrategy(new CustomExpiredSessionStrategy());  //session超时，被踢下线的自定义操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //________________ 动态授权，需要实现UserDetailsService____________________________</span><br><span class="line">            //这里才是验证登录信息的</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向数据库操作关于记住我的验证信息</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<p><img src="https://s2.loli.net/2022/03/21/4zJVputoWcDh5P3.png" alt="image-20220317000050986"></p>
<h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;h1&gt;登录&lt;/h1&gt;</span><br><span class="line">&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    账号：&lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;user&quot;&gt;&lt;br&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;</span><br><span class="line">    验证码:&lt;input type=&quot;text&quot; id=&quot;captchaCoed&quot; name=&quot;captchaCoed&quot;&gt;&lt;img src=&quot;/kaptcha&quot; id=&quot;kaptcha&quot; width=&quot;110px&quot; height=&quot;40px&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;login()&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">     记住我&lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; id=&quot;remember-me&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;手机验证码&lt;/h1&gt;</span><br><span class="line">&lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    手机号：&lt;input type=&quot;text&quot; id=&quot;phone&quot; name=&quot;phone&quot;&gt;&lt;br&gt;</span><br><span class="line">    验证码:&lt;input type=&quot;text&quot; id=&quot;phoneCode&quot; name=&quot;phoneCode&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;submitPhone&quot;  onclick=&quot;getPhone()&quot; value=&quot;获取验证码&quot;  &gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; onclick=&quot;PhoneLogin()&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">        //用于点击刷新验证码图片</span><br><span class="line">        $(&quot;#kaptcha&quot;).click(function () &#123;</span><br><span class="line">            $(&quot;#kaptcha&quot;).attr(&quot;src&quot;,&quot;/kaptcha?&quot;+Math.floor(Math.random()*100))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    function login() &#123;</span><br><span class="line">        let username=$(&quot;#username&quot;).val();</span><br><span class="line">        let password=$(&quot;#password&quot;).val();</span><br><span class="line">        let remember=$(&quot;#remember-me&quot;).prop(&quot;checked&quot;);</span><br><span class="line">        let captchaCoed=$(&quot;#captchaCoed&quot;).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &quot;POST&quot;,</span><br><span class="line">            url: &quot;/login&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                &quot;user&quot;: username,</span><br><span class="line">                &quot;password&quot;: password,</span><br><span class="line">                &quot;remember-me&quot;:remember,</span><br><span class="line">                &quot;captchaCoed&quot;:captchaCoed</span><br><span class="line">            &#125;,</span><br><span class="line">            success: function (json) &#123;</span><br><span class="line">              if (json.state == 200)&#123;</span><br><span class="line">                  console.log(json)</span><br><span class="line">                  location.href=&quot;/&quot;;</span><br><span class="line">              &#125;else &#123;</span><br><span class="line">                  alert(json.message)</span><br><span class="line">                  console.log(json)</span><br><span class="line">                  location.href=&quot;/logins&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function getPhone() &#123;</span><br><span class="line">        let phone = $(&quot;#phone&quot;).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &quot;GET&quot;,</span><br><span class="line">            url: &quot;/smscode&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                &quot;phone&quot;: phone,</span><br><span class="line">            &#125;,</span><br><span class="line">            success: function (json) &#123;</span><br><span class="line">                if (json.state == 200) &#123;</span><br><span class="line">                    console.log(json)</span><br><span class="line">                    alert(&quot;验证码已发送&quot;)</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    alert(json.message)</span><br><span class="line">                    console.log(json)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    function PhoneLogin() &#123;</span><br><span class="line">        let phone = $(&quot;#phone&quot;).val();</span><br><span class="line">        let phoneCode = $(&quot;#phoneCode&quot;).val();</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: &quot;POST&quot;,</span><br><span class="line">            url: &quot;/PhoneLogin&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                &quot;phone&quot;: phone,</span><br><span class="line">                &quot;phoneCode&quot;:phoneCode</span><br><span class="line">            &#125;,</span><br><span class="line">            success: function (json) &#123;</span><br><span class="line">                if (json.state == 200) &#123;</span><br><span class="line">                    console.log(json)</span><br><span class="line">                    location.href=&quot;/&quot;;</span><br><span class="line"></span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    alert(json.message)</span><br><span class="line">                    console.log(json)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function (e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>





<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="jwt介绍："><a href="#jwt介绍：" class="headerlink" title="jwt介绍："></a>jwt介绍：</h3><p><img src="https://s2.loli.net/2022/03/21/kKPDMLRAVIpHrvX.png" alt="image-20220317231621407"></p>
<p><img src="https://s2.loli.net/2022/03/21/W1stHFYOvjKd6Uk.png" alt="image-20220317231629433"></p>
<p><img src="https://s2.loli.net/2022/03/21/P2Ik1z493SyCuFO.png" alt="image-20220317231635981"></p>
<p><img src="https://s2.loli.net/2022/03/21/X3od2kYmL4vnl7B.png" alt="image-20220317231642172"></p>
<h3 id="创建JWT工具类："><a href="#创建JWT工具类：" class="headerlink" title="创建JWT工具类："></a>创建JWT工具类：</h3><p>我需要先创建一jwt工具类，这样可以在我们需要给地方使用更方便</p>
<p>注意：获取用户名之类的方法都会去判断jwt令牌是否过期，过期后是获取不到用户名的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JWT的工具类</span><br><span class="line"> * 三个属性需要在配置文件中定义</span><br><span class="line"> */</span><br><span class="line">@Data</span><br><span class="line">@ConfigurationProperties(prefix = &quot;jwt&quot;) //设置application中配置的开头节点</span><br><span class="line">@Component</span><br><span class="line">public class JwtTokenUtil &#123;</span><br><span class="line"></span><br><span class="line">//  这三个属性需要在application配置文件中定义</span><br><span class="line">    //JWT的密钥</span><br><span class="line">    @Value(&quot;$&#123;jwt.secret&#125;&quot;)</span><br><span class="line">    private String secret;</span><br><span class="line">    //JWT的过期时间</span><br><span class="line">    @Value(&quot;$&#123;jwt.expiration&#125;&quot;)</span><br><span class="line">    private Long expiration;</span><br><span class="line">    //在http对象头中携带jwt的key的名称</span><br><span class="line">    @Value(&quot;$&#123;jwt.header&#125;&quot;)</span><br><span class="line">    private String header;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成JWT token令牌</span><br><span class="line">     *</span><br><span class="line">     * @param userDetails 用户信息</span><br><span class="line">     * @return JWT token令牌</span><br><span class="line">     */</span><br><span class="line">    public String generateToken(UserDetails userDetails)&#123;</span><br><span class="line">        //存放用户不敏感信息，等要放入jwt令牌中</span><br><span class="line">        Map&lt;String,Object&gt; claims = new HashMap&lt;&gt;(2);</span><br><span class="line">        claims.put(&quot;sub&quot;,userDetails.getUsername()); //将用户名放入claims</span><br><span class="line">        claims.put(&quot;created&quot;,new Date()); //将令牌创建时间放入claims</span><br><span class="line"></span><br><span class="line">        return generateToken(claims);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从claims中获取用户不敏感信息生成令牌</span><br><span class="line">     *</span><br><span class="line">     * @param claims 用户不敏感信息</span><br><span class="line">     * @return 令牌</span><br><span class="line">     */</span><br><span class="line">    public String generateToken(Map&lt;String,Object&gt; claims)&#123;</span><br><span class="line">           Date expirationDate = new Date(System.currentTimeMillis() + expiration); //获取当前数据，加上过期是长，生成过期时间</span><br><span class="line">        //返回生成的jwt令牌</span><br><span class="line">        return Jwts.builder()//</span><br><span class="line">                .setClaims(claims)  //加入用户名，与用户创建时间</span><br><span class="line">                .setExpiration(System.currentTimeMillis()+expirationDate*1000)//令牌过期时间</span><br><span class="line">                //进行jwt令牌的签约 参数1：设置使用声明方式签名（加密方式）,参数2：使用的密钥（等解签也需要这个密钥）</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512,secret)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从令牌中获取用户名</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @return 该令牌用户名</span><br><span class="line">     */</span><br><span class="line">    public String getUsernameFromToken(String token)&#123;</span><br><span class="line">        String username;</span><br><span class="line">        try &#123;</span><br><span class="line">            //Claims jwt信息类（数据声明），获取jwt信息类</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            username = claims.getSubject(); //在jwt信息类中获取用户名，这个方法是获取用户名的</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            username = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从令牌中获取jwt令牌信息</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @return jwt令牌信息类（数据声明）</span><br><span class="line">     */</span><br><span class="line">    public Claims getClaimsFromToken(String token)&#123;</span><br><span class="line">        //jwt令牌信息类</span><br><span class="line">        Claims claims;</span><br><span class="line">        try &#123;</span><br><span class="line">            //将jwt进行解析，获取jwt信息类</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    .setSigningKey(secret)//解签的密钥</span><br><span class="line">                    .parseClaimsJws(token)//解签的令牌</span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            claims = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断令牌是否过期</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @return 是否过期</span><br><span class="line">     */</span><br><span class="line">    public Boolean isTokenExpired(String token)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            //获取jwt令牌过期时间，过期使用使用这个方法获取</span><br><span class="line">            Date expiration = claims.getExpiration();</span><br><span class="line">            //判断当前时间是否在过期时间之前，也就是判断是否过期</span><br><span class="line">            return expiration.before(new Date());</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新令牌（令牌过期就表示登录过期，为了保证用户体验，在用户使用中要刷新令牌）</span><br><span class="line">     * @param token 原令牌</span><br><span class="line">     * @return 新令牌</span><br><span class="line">     */</span><br><span class="line">    public String refreshToken(String token)&#123;</span><br><span class="line">        String refreshToken;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取jwt信息类</span><br><span class="line">            Claims claims = getClaimsFromToken(token);</span><br><span class="line">            //修改jwt中的新的创建时间</span><br><span class="line">            claims.put(&quot;created&quot;,new Date());</span><br><span class="line">            //生成一个新的令牌，更新它的过期时间</span><br><span class="line">            refreshToken = generateToken(claims);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            refreshToken = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证令牌</span><br><span class="line">     * @param token 令牌</span><br><span class="line">     * @param userDetails 用户详细信息</span><br><span class="line">     * @return 是否有效</span><br><span class="line">     */</span><br><span class="line">    public Boolean validateToken(String token,UserDetails userDetails)&#123;</span><br><span class="line">        //获取用户名</span><br><span class="line">        String username = getUsernameFromToken(token);</span><br><span class="line">        //判断当前jwt令牌用户名是否与登录用户的用户名相同，并且jwt令牌是否过期</span><br><span class="line">        return (username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>yml配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jwt:</span><br><span class="line">  secret: ahjkvhajkhkss2ajdfaj #密钥，签名（加密），解签（解密）都需要该密钥</span><br><span class="line">  expiration: 3600000  #过期时长 </span><br><span class="line">  header: JWTHeaderName  #jwt在http头部信息中的key</span><br></pre></td></tr></table></figure>



<h3 id="JWT实现登录："><a href="#JWT实现登录：" class="headerlink" title="JWT实现登录："></a>JWT实现登录：</h3><p>我们需要配置Controller实现请求，与Service业务层</p>
<p>这些做完我们就可以获取基本的jwt令牌了</p>
<h4 id="Controller："><a href="#Controller：" class="headerlink" title="Controller："></a>Controller：</h4><p>两个请求，一个获取令牌：也就是登录我们需要创建一个jwt令牌返回给客户端，一个刷新：刷新我们的jwt令牌返回回去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class JwtAuthController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtAuthService jwtAuthService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建jwt令牌</span><br><span class="line">     * 记得在SecurityConfig中开放访问权限</span><br><span class="line">     * @param map</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/authentication&quot;)</span><br><span class="line">    public JsonResult login(@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line"></span><br><span class="line">        //获取用户名和密码</span><br><span class="line">        String username = map.get(&quot;username&quot;);</span><br><span class="line">        String password = map.get(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">        //判断用户名与密码是否为空</span><br><span class="line">        if (username.isEmpty() || password.isEmpty())&#123;</span><br><span class="line">            return  new JsonResult().InputError(&quot;用户名或密码不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //返回获取到的jwt令牌</span><br><span class="line">            return new JsonResult().success(jwtAuthService.login(username,password));</span><br><span class="line">        &#125;catch (UsernameNotFoundException e)&#123;</span><br><span class="line">            //如果没有获取到jwt令牌，返回错误信息</span><br><span class="line">            return new JsonResult().InputError(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新jwt令牌</span><br><span class="line">     * @param token  获取http对象头中的jwt令牌，我们以及设置jwt令牌的key为jwt.header</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;/refreshToken&quot;)</span><br><span class="line">    public JsonResult refresh(@RequestHeader(&quot;$&#123;jwt.header&#125;&quot;) String token)&#123;</span><br><span class="line">        return new JsonResult().success(jwtAuthService.refreshToken(token));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Service："><a href="#Service：" class="headerlink" title="Service："></a>Service：</h4><p>业务操作，实际上还是业务层实现真实的操作，访问层只是做一些校验</p>
<p>注意：AuthenticationManager  这个bean在Security配置类中配置了，可以去看看，下面有完整的Security配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class JwtAuthService &#123;</span><br><span class="line"></span><br><span class="line">    //鉴定管理员 </span><br><span class="line">    @Autowired</span><br><span class="line">    private AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证换取JWT令牌</span><br><span class="line">     * @param username</span><br><span class="line">     * @param password</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String login(String username,String password)&#123;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //创建一个用户名密码鉴定令牌</span><br><span class="line">            UsernamePasswordAuthenticationToken authenticationToken = new 				UsernamePasswordAuthenticationToken(username,password);</span><br><span class="line">            //进行认证，如果认证成功返回一个认证信息，如果没有成功就会抛出AuthenticationException异常</span><br><span class="line">            //这个方法中会去数据库中查询认证信息，具体还得网查询</span><br><span class="line">            Authentication authenticate = authenticationManager.authenticate(authenticationToken);</span><br><span class="line">            //将认证信息给Security</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">        &#125;catch (AuthenticationException e)&#123;</span><br><span class="line">            throw new UsernameNotFoundException(&quot;用户名或密码不正确&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //进行用户查询</span><br><span class="line">        UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br><span class="line">        //创建jwt令牌并返回</span><br><span class="line">        return jwtTokenUtil.generateToken(userDetails);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 刷新jwt令牌</span><br><span class="line">     * @param oldToken 旧令牌</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public String refreshToken(String oldToken)&#123;</span><br><span class="line">        //判断当前令牌是否过期</span><br><span class="line">        if (!jwtTokenUtil.isTokenExpired(oldToken))&#123;</span><br><span class="line">            return jwtTokenUtil.refreshToken(oldToken);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，要把当前两个请求路径开放，并将session关闭</strong></p>
<h4 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h4><p>获取到的令牌是可以使用Base64解码的，但密钥是解码不了的</p>
<p><strong>获取令牌：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/kWeJDHTntcVMBfh.png" alt="image-20220320190553251"></p>
<p><strong>刷新令牌：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/etnRIfD1aZVPjTy.png" alt="image-20220320190242450"></p>
<p><strong>解码演示</strong>：</p>
<p>这个图就和介绍中jwt结构分析一样</p>
<p><img src="https://s2.loli.net/2022/03/21/lbj2MnBNmJ87Qoc.png" alt="image-20220320190758729"></p>
<h3 id="jwt用户授权"><a href="#jwt用户授权" class="headerlink" title="jwt用户授权"></a>jwt用户授权</h3><p>我们单纯的只有jwt令牌也没有用，我们需要为当前用户进行授权，那么我们就需要自己去创建一个过滤器放置在UsernamePasswordAuthenticationFilter之前进行授权</p>
<p>介绍下， UsernamePasswordAuthenticationToken authenticationToken<br>        &#x3D; new UsernamePasswordAuthenticationToken(userDetails,null,userDetails.getAuthorities());</p>
<p>这是个特殊的令牌，这个令牌是Security是可以获取到用户认证信息的，而这个令牌里的认证信息是我们放入的，然后将认证信息交给</p>
<p>SecurityContextHolder.getContext().setAuthentication(authenticationToken); </p>
<p>这个方法是将我们有角色认证信息的令牌交给Security这样就完成了角色的认证，就可以判断用户拥有哪些权限了，但每次访问时都会去重写查询（下面代码里可以看到）所以我们可以使用缓存将它存起来，这样就可以提高效率</p>
<h4 id="jwt身份授权鉴权过滤器"><a href="#jwt身份授权鉴权过滤器" class="headerlink" title="jwt身份授权鉴权过滤器"></a><strong>jwt身份授权鉴权过滤器</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 添加jwt过滤器，用于身份授权鉴权</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtTokenUtil jwtTokenUtil;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        //获取http头部信息中的jwtToken</span><br><span class="line">        String jwtToken = request.getHeader(jwtTokenUtil.getHeader());</span><br><span class="line">        //判断是否有jwtToken</span><br><span class="line">        if (!StringUtils.isEmpty(jwtToken))&#123;</span><br><span class="line">            //获取jwt中的用户名,这里已经是判断jwt令牌的有效性，如果无效就获取不到username</span><br><span class="line">            String username = jwtTokenUtil.getUsernameFromToken(jwtToken);</span><br><span class="line"></span><br><span class="line">            //判断jwtToken中用户名不为空并且Security中还没有认证信息</span><br><span class="line">            if (!username.isEmpty()</span><br><span class="line">                    &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null)&#123;</span><br><span class="line">                UserDetails userDetails = myUserDetailsService.loadUserByUsername(username);</span><br><span class="line">                //验证令牌正确性，</span><br><span class="line">                if (jwtTokenUtil.validateToken(jwtToken,userDetails))&#123;</span><br><span class="line">                    // 将jwt令牌转换为Security认识的令牌 参数1：用户信息 参数2：密码 参数3：用户的权限信息</span><br><span class="line">                    UsernamePasswordAuthenticationToken authenticationToken</span><br><span class="line">                            = new UsernamePasswordAuthenticationToken(userDetails,null,userDetails.getAuthorities());</span><br><span class="line">                    //把认证权限信息交给Security，如当UsernamePasswordAuthenticationFilter拦截时，发现已经认证过了就不会再次认证</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用aop的思想将它放在UsernamePasswordAuthenticationFilter之前，所以我们需要去配置</p>
<h4 id="Security配置类-1"><a href="#Security配置类-1" class="headerlink" title="Security配置类"></a>Security配置类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //导入自定义动态授权</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    //退出登录自定义策略</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        http    //将jwtAuthenticationTokenFilter放置在UsernamePasswordAuthenticationFilter之前</span><br><span class="line">                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //令牌仓库默认是在内存中,我们指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  //关闭防御csrf攻击</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/login&quot;,&quot;/authentication&quot;,&quot;/refreshToken&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);//不使用session，关闭session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            //这里才是验证登录信息的</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向数据库操作关于记住我的验证信息</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean(name = BeanIds.AUTHENTICATION_MANAGER)</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception&#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于我们要使用到别的页面查询是否成功授权鉴权，我们需要一个额外的请求资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line"></span><br><span class="line">        return &quot;world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意我们数据库中记得给当前角色这个资源路径的访问资格</p>
<p><strong>现在开始测试：</strong></p>
<p><strong>这是有权限清空访问</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/vzRBIdb9X6WGD5m.png" alt="image-20220320193906937"></p>
<p><img src="https://s2.loli.net/2022/03/21/mjcJ6BY5k3OQ2Rn.png" alt="image-20220320193505218"></p>
<p><strong>无权限清空下访问：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/RBq4fEZdC6J9FIl.png" alt="image-20220320193746967"></p>
<p><img src="https://s2.loli.net/2022/03/21/uVZkJzhapcOG6rF.png" alt="image-20220320193640084"></p>
<h2 id="跨域访问："><a href="#跨域访问：" class="headerlink" title="跨域访问："></a>跨域访问：</h2><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>为什么要跨域访问？跨域访问是什么？</p>
<p>跨域访问也就是A网站直接去访问B网站资源路径，这样的行为是不允许的</p>
<p><strong>如图：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/4arOfdijuIq8bQv.png" alt="image-20220321151443656"></p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a><strong>解决方法：</strong></h3><p><img src="https://s2.loli.net/2022/03/21/XlDL1EcG8rdZ5eb.png" alt="image-20220321152423979"></p>
<h4 id="其他解决方法："><a href="#其他解决方法：" class="headerlink" title="其他解决方法："></a>其他解决方法：</h4><p><img src="https://s2.loli.net/2022/03/21/KRpjq6LcIYf8ZGB.png" alt="image-20220321151622759"></p>
<p><img src="https://s2.loli.net/2022/03/21/aQwmgfGkiMPAVl7.png" alt="image-20220321151629992"></p>
<p><img src="https://s2.loli.net/2022/03/21/fWt3wZsPr1Tupka.png" alt="image-20220321151636299"></p>
<h4 id="SpringBoot解决方法："><a href="#SpringBoot解决方法：" class="headerlink" title="SpringBoot解决方法："></a>SpringBoot解决方法：</h4><p><img src="https://s2.loli.net/2022/03/21/Bnjf38uIDyarETp.png" alt="image-20220321151734457"></p>
<p><img src="https://s2.loli.net/2022/03/21/i6q8xQsg7tDBlIm.png" alt="image-20220321151753953"></p>
<p><img src="https://s2.loli.net/2022/03/21/hMqaYJnE4xoyX7Q.png" alt="image-20220321151800818"></p>
<p><img src="https://s2.loli.net/2022/03/21/GtvJUDmACzo1lrn.png" alt="image-20220321151806595"></p>
<h4 id="SpringBoot-Security解决方法："><a href="#SpringBoot-Security解决方法：" class="headerlink" title="SpringBoot-Security解决方法："></a>SpringBoot-Security解决方法：</h4><p>以上四种其实都可以使用在Security中解决，但是Security有它推荐的方法</p>
<p><strong>其实很简单：</strong></p>
<p>A网站中配置跨域访问权限：http .cors()&#x2F;&#x2F;开启跨域访问</p>
<p>实现bean：</p>
<p>​	注意是这个包下的import org.springframework.web.cors.CorsConfigurationSource;</p>
<pre><code>/**
 * 配置跨域请求CORS源
 * @return
 */
@Bean
public CorsConfigurationSource corsConfigurationSource()&#123;
    CorsConfiguration corsConfiguration = new CorsConfiguration();
    //允许哪些域访问
    corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;http://loaclhost:8080&quot;));
    //访问方式
    corsConfiguration.setAllowedMethods(Arrays.asList(&quot;GET&quot;,&quot;POST&quot;));
    //设置默认参数
    corsConfiguration.applyPermitDefaultValues();

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    //允许跨域访问哪些资源
    source.registerCorsConfiguration(&quot;/**&quot;,corsConfiguration);
    return source;
&#125;
</code></pre>
<p><strong>配置实例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        http .cors()//开启跨域访问</span><br><span class="line">                .and()</span><br><span class="line">                //将jwtAuthenticationTokenFilter放置在UsernamePasswordAuthenticationFilter之前</span><br><span class="line">                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //令牌仓库默认是在内存中,我们指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .csrf().disable()  //关闭防御csrf攻击</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/login&quot;,&quot;/authentication&quot;,&quot;/refreshToken&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);//不使用session，关闭session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            //这里才是验证登录信息的</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向数据库操作关于记住我的验证信息</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 识别jwt令牌需要的</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = BeanIds.AUTHENTICATION_MANAGER)</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception&#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置跨域请求CORS源</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsConfigurationSource corsConfigurationSource()&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        //允许哪些域访问  一定要注意最后以/结尾 不让B网站访问就没有用</span><br><span class="line">        corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;http://loaclhost:8080/&quot;));</span><br><span class="line">        //访问方式</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(&quot;GET&quot;,&quot;POST&quot;));</span><br><span class="line">        //设置默认参数</span><br><span class="line">        corsConfiguration.applyPermitDefaultValues();</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        //允许跨域访问哪些资源</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;,corsConfiguration);</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><p>这里是使用的Security推荐解决方法</p>
<p><strong>B网站向A网站跨域访问前端代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type: &quot;POST&quot;,</span><br><span class="line">    url: &quot;http://localhost:8081/hello&quot;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &#x27;JWTHeaderName&#x27;:&#x27;eyJhbGciOiJIUzUxMiJ9.eyJleHAiOjE2NDc4NTMzNTEsInN1YiI6InVzZXIiLCJjcmVhdGVkIjoxNjQ3ODQ5NzUxODY3fQ.5EC4IhutkrR0er-TkLLHSLXaAZQ1gR48tTi3YOyjJzV-eE9Y0wziMoCRfUb0I4S9eeOr4mG3JloT7HQUTlwF_w&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function (json) &#123;</span><br><span class="line">        alert(&quot;跨域请求配置成功&quot;+json);</span><br><span class="line">    &#125;,</span><br><span class="line">    error: function (e) &#123;</span><br><span class="line">        alert(&quot;跨域请求配置失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><strong>A网站未配置B网站跨域访问权限下访问结果：</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/TD8ZIjuQ7gvC94s.png" alt="image-20220321161337254"></p>
<p><strong>A网站配置B网站跨域访问权限下访问结果：</strong></p>
<p>​	配置了后就没有那个提示了</p>
<p><img src="https://s2.loli.net/2022/03/21/B15f4qExDU2nNFo.png" alt="image-20220321161205428"></p>
<h2 id="开启CSRF防御："><a href="#开启CSRF防御：" class="headerlink" title="开启CSRF防御："></a>开启CSRF防御：</h2><h3 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h3><p>什么是CSRF防御，那我们先得了解下CSRF攻击</p>
<p><a href="https://zhuanlan.zhihu.com/p/114750961">什么是CSRF攻击？如何防御CRSF攻击？ - 知乎 (zhihu.com)</a></p>
<h3 id="在Security中配置："><a href="#在Security中配置：" class="headerlink" title="在Security中配置："></a><strong>在Security中配置：</strong></h3><p>配置后访问资源http请求头中需要携带CSRF令牌才能访问，（GET请求除外，GET请求不需要携带CSRF就可以访问）</p>
<p>没访问资源一次就会发生一次新的CSRF令牌，一个令牌只能使用一次</p>
<p><img src="https://s2.loli.net/2022/03/21/kZmP971nS8AXgTJ.png" alt="image-20220321174052920"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http</span><br><span class="line">        .csrf()//开启CSRF防御（GET请求是不会被防御的）</span><br><span class="line">        //使用cookie存储CSRF令牌（每次防御页面都需要携带该令牌），里面的参数表示这个cookie是可以被js脚本获取到的，</span><br><span class="line">        .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) //</span><br><span class="line">        .ignoringAntMatchers(&quot;/authentication&quot;) //排除哪些请求不需要携带CSRF令牌就可以进行访问</span><br></pre></td></tr></table></figure>

<p><strong>完整配置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //导入自定义动态授权</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyUserDetailsService myUserDetailsService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    //退出登录自定义策略</span><br><span class="line">    @Autowired</span><br><span class="line">    private MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登录认证方法</span><br><span class="line">     * @param http</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">                .csrf()//开启CSRF防御（GET请求是不会被防御的）</span><br><span class="line">                //使用cookie存储CSRF令牌（每次防御页面都需要携带该令牌），里面的参数表示这个cookie是可以被js脚本获取到的，</span><br><span class="line">                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()) //</span><br><span class="line">                .ignoringAntMatchers(&quot;/authentication&quot;) //排除哪些请求不需要携带CSRF令牌就可以进行访问</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .cors()//开启跨域访问</span><br><span class="line">                .and()</span><br><span class="line">                //将jwtAuthenticationTokenFilter放置在UsernamePasswordAuthenticationFilter之前</span><br><span class="line">                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .logout()//开启退出登录</span><br><span class="line">//                .logoutSuccessUrl(&quot;/&quot;) //退出后跳转的页面  默认退出到login页面</span><br><span class="line">                .deleteCookies(&quot;JSESSIONID&quot;) //指定退出后要删除的cookie</span><br><span class="line">                .logoutUrl(&quot;/logout&quot;)  //退出请求路径，也就是页面上退出登录访问的地址  默认logout</span><br><span class="line">                .logoutSuccessHandler(myLogoutSuccessHandler) //使用自定义退出策略 ，不能与logoutSuccessUrl共存，否则失效</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line"></span><br><span class="line">                .rememberMe()//开启记住我功能  ，前端也需要有记住我字段</span><br><span class="line">                .rememberMeCookieName(&quot;rememberMe-Cookie&quot;)  //存在浏览器中cookie的名称</span><br><span class="line">                .rememberMeParameter(&quot;remember-me&quot;)  //表单中 自动登录 勾选框的参数名</span><br><span class="line">                .tokenValiditySeconds(2*24*60*60) //保存Cookie的有效期，默认2周</span><br><span class="line">                .tokenRepository(tokenRepository())  //令牌仓库默认是在内存中,我们指定rememberMe存储到数据库规则方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests() //自定义过滤拦截请求</span><br><span class="line">                .antMatchers(&quot;/login&quot;,&quot;/authentication&quot;,&quot;/refreshToken&quot;) //资源路径</span><br><span class="line">                .permitAll()  //当前资源路径不需要认证就可以访问</span><br><span class="line"></span><br><span class="line">                .anyRequest().access(&quot;@MyRBACService.hasPermission(request,authentication)&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .sessionManagement()//启用session管理</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);//不使用session，关闭session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //.authorizeHttpRequests()   这样方法表示选中的请求</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 授权方法</span><br><span class="line">     * @param auth</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">            //这里才是验证登录信息的</span><br><span class="line">            auth.userDetailsService(myUserDetailsService)</span><br><span class="line">                  .passwordEncoder(passwordEncoder());  //配置BCrypt加密，这个会自动调用matches（）这个方法来为我们输入的密码进行对比</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PasswordEncoder passwordEncoder()&#123;</span><br><span class="line">        return new BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 静态资源路径开放</span><br><span class="line">     * @param web</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">        //将项目中的静态资源路径开放出来，在这开放是不需要经过过滤器拦截的</span><br><span class="line">        web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/img/**&quot;,&quot;/js/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向数据库操作关于记住我的验证信息</span><br><span class="line">     * JdbcTokenRepositoryImpl 这个类中已经固定要存到数据库中的哪个表，我们只需要指定数据源即可</span><br><span class="line">     * initDao() 这个方法有在数据库中创建需要的表，我还没尝试过，我的表是自己手动创建的</span><br><span class="line">     * 设置记住我存储到的数据源是哪个</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public PersistentTokenRepository tokenRepository()&#123;</span><br><span class="line">        JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        return jdbcTokenRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 识别jwt令牌需要的</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Bean(name = BeanIds.AUTHENTICATION_MANAGER)</span><br><span class="line">    @Override</span><br><span class="line">    public AuthenticationManager authenticationManagerBean() throws Exception&#123;</span><br><span class="line">        return super.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 配置跨域请求CORS源</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsConfigurationSource corsConfigurationSource()&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        //允许哪些域访问</span><br><span class="line">        corsConfiguration.setAllowedOrigins(Arrays.asList(&quot;http://localhost:8080&quot;));</span><br><span class="line">        //访问方式</span><br><span class="line">        corsConfiguration.setAllowedMethods(Arrays.asList(&quot;GET&quot;,&quot;POST&quot;));</span><br><span class="line">        //设置默认参数</span><br><span class="line">        corsConfiguration.applyPermitDefaultValues();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        //允许跨域访问哪些资源</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;,corsConfiguration);</span><br><span class="line">        return source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/21/2QsiSmgb1pR6c8k.png" alt="image-20220321172831555"></p>
<h3 id="使用测试"><a href="#使用测试" class="headerlink" title="使用测试"></a>使用测试</h3><p><strong>先使用我们登录的请求获取jwt令牌与CSRF令牌</strong></p>
<p><img src="https://s2.loli.net/2022/03/21/zJYNqRbAeBVXd7G.png" alt="image-20220321171847532"></p>
<p><strong>进行访问&#x2F;hello：</strong></p>
<p>不携带CSRF令牌进行访问：</p>
<p><img src="https://s2.loli.net/2022/03/21/FqsVLNpkCJTfZd7.png" alt="image-20220321171956312"></p>
<p>携带CSRF令牌进行访问：</p>
<p><img src="https://s2.loli.net/2022/03/21/AFh2SfxW9YQv3gH.png" alt="image-20220321172017322"></p>
]]></content>
      <categories>
        <category>SpringBoot-Security</category>
      </categories>
      <tags>
        <tag>安全框架</tag>
      </tags>
  </entry>
</search>
